<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>SpringCloudAlibaba | Cloudy's Blog</title><meta name="author" content="cloudy"><meta name="copyright" content="cloudy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、实用篇1.微服务架构1.1认识微服务①服务架构演变 单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署。 优点：架构简单部署成本低。缺点：耦合度高  分布式架构：根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务。 优点：降低服务耦合有利于服务升级拓展。缺点：架构复杂，难度大  微服务是一种经过良好架构设计的分布式架构方案，微服务架构特征：  单一职责：微服务拆">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringCloudAlibaba">
<meta property="og:url" content="http://pblogs.cn/2024/05/31/SpringCloudAlibaba/index.html">
<meta property="og:site_name" content="Cloudy&#39;s Blog">
<meta property="og:description" content="一、实用篇1.微服务架构1.1认识微服务①服务架构演变 单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署。 优点：架构简单部署成本低。缺点：耦合度高  分布式架构：根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务。 优点：降低服务耦合有利于服务升级拓展。缺点：架构复杂，难度大  微服务是一种经过良好架构设计的分布式架构方案，微服务架构特征：  单一职责：微服务拆">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://pblogs.cn/img/blog_cover/default_cover_2.webp">
<meta property="article:published_time" content="2024-05-30T16:00:00.000Z">
<meta property="article:modified_time" content="2024-05-31T09:34:55.569Z">
<meta property="article:author" content="cloudy">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://pblogs.cn/img/blog_cover/default_cover_2.webp"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://pblogs.cn/2024/05/31/SpringCloudAlibaba/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: cloudy","link":"Link: ","source":"Source: Cloudy's Blog","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SpringCloudAlibaba',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-31 17:34:55'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/blog_cover/default_cover_2.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="Cloudy's Blog"><span class="site-name">Cloudy's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">SpringCloudAlibaba</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-05-30T16:00:00.000Z" title="Created 2024-05-31 00:00:00">2024-05-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-05-31T09:34:55.569Z" title="Updated 2024-05-31 17:34:55">2024-05-31</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">47.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>164mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="SpringCloudAlibaba"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、实用篇"><a href="#一、实用篇" class="headerlink" title="一、实用篇"></a>一、实用篇</h1><h1 id="1-微服务架构"><a href="#1-微服务架构" class="headerlink" title="1.微服务架构"></a>1.微服务架构</h1><h2 id="1-1认识微服务"><a href="#1-1认识微服务" class="headerlink" title="1.1认识微服务"></a>1.1认识微服务</h2><h3 id="①服务架构演变"><a href="#①服务架构演变" class="headerlink" title="①服务架构演变"></a>①服务架构演变</h3><ul>
<li><p><strong>单体架构</strong>：将业务的所有功能集中在一个项目中开发，打成一个包部署。</p>
<p>优点：架构简单部署成本低。缺点：耦合度高</p>
</li>
<li><p><strong>分布式架构</strong>：根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务。</p>
<p>优点：降低服务耦合有利于服务升级拓展。缺点：架构复杂，难度大</p>
</li>
<li><p><strong>微服务</strong>是一种经过良好架构设计的分布式架构方案，微服务架构特征：</p>
<ul>
<li><p>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责，避免重复业务开发</p>
</li>
<li><p>面向服务：微服务对外暴露业务接口</p>
</li>
<li><p>自治：团队独立、技术独立、数据独立、部署独立</p>
</li>
<li><p>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题。</p>
</li>
</ul>
<p><em>优点：拆分粒度更小、服务更独立、耦合度更低</em></p>
<p><em>缺点：架构非常复杂，运维、监控、部署难度提高</em></p>
</li>
</ul>
<h3 id="②微服务技术对比"><a href="#②微服务技术对比" class="headerlink" title="②微服务技术对比"></a>②微服务技术对比</h3><img src="/img/SpringCloudAlibaba.assets/image-20230105163135110.png" alt="image-20230105163135110" style="zoom: 33%;" />

<p><em>从上不难看出springcloudalibaba具有最完善的微服务体系。而springcloudalibaba也只是springcloud的一个组件。</em></p>
<p>常见企业技术需求：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20230105163243799.png" alt="image-20230105163243799" style="zoom: 50%;" />

<h3 id="③SpringCloud"><a href="#③SpringCloud" class="headerlink" title="③SpringCloud"></a>③SpringCloud</h3><p>SpringCloud是目前国内使用最广泛的微服务框架,它集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</p>
<img src="/img/SpringCloudAlibaba.assets/image-20230105163640398.png" alt="image-20230105163640398" style="zoom: 50%;" />

<p><a href="gateway%E7%9A%84module%E4%B8%8D%E8%83%BD%E5%86%8D%E5%8A%A0%E5%85%A5spring-boot-starter-web%E7%9A%84%E4%BE%9D%E8%B5%96">^注意</a>: 课堂学习的版本是 Hoxton.SR10，对应的SpringBoot版本是2.3.x版本。由于版本太低，阿里云镜像的一些依赖可能没有。</p>
<hr>
<h2 id="1-2服务拆分及远程调用"><a href="#1-2服务拆分及远程调用" class="headerlink" title="1.2服务拆分及远程调用"></a>1.2服务拆分及远程调用</h2><p>服务拆分注意事项：</p>
<ul>
<li><p>单一职责：不同微服务，不要重复开发相同业务</p>
</li>
<li><p>数据独立：不要访问其它微服务的数据库</p>
</li>
<li><p>面向服务：将自己的业务暴露为接口，供其它微服务调用</p>
</li>
</ul>
<h3 id="①拆分"><a href="#①拆分" class="headerlink" title="①拆分"></a>①拆分</h3><p>将单体项目拆分成多个项目，其中（idea中）一个project下面有多个module，每一个module就是一个服务，project作为他们的父工程，父工程的pom.xml文件定义所有服务的依赖版本，其他的module要继承这个依赖管理。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--springcloud的依赖版本管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="②远程调用"><a href="#②远程调用" class="headerlink" title="②远程调用"></a>②远程调用</h3><p>案例中拆分有两个服务：order-service与user-service，order-service需要调用user-service中的接口查询订单中的用户信息。</p>
<ol>
<li><p>在配置类中注册RestTemplate的bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">        <span class="keyword">return</span> restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用restTemplate中的getObject方法来访问接口，获取结果</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> restTemplate.getForObject(<span class="string">&quot;http://userservice/user/&quot;</span> + order.getUserId(),</span><br><span class="line">        User.class);</span><br><span class="line"><span class="comment">//新参中的url可以直接放入字符串，也可以new Url()对象</span></span><br></pre></td></tr></table></figure>

<h3 id="③服务提供者与消费者"><a href="#③服务提供者与消费者" class="headerlink" title="③服务提供者与消费者"></a>③服务提供者与消费者</h3><ul>
<li><p>服务提供者：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）</p>
</li>
<li><p>服务消费者：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）</p>
</li>
</ul>
<blockquote>
<p><em>一个服务的角色得看其具体的服务，一个服务既可以是提供者，也可以是消费者</em></p>
</blockquote>
<hr>
<h2 id="1-3Eureka注册中心"><a href="#1-3Eureka注册中心" class="headerlink" title="1.3Eureka注册中心"></a>1.3Eureka注册中心</h2><p>假如我们的服务提供者user-service部署了多个实例，如图：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210713214925388.png" alt="image-20210713214925388" style="zoom:33%;" />



<p>大家思考几个问题：</p>
<ul>
<li>order-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口？</li>
<li>有多个user-service实例地址，order-service调用时该如何选择？</li>
<li>order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</li>
</ul>
<h3 id="①Eureka的结构和作用"><a href="#①Eureka的结构和作用" class="headerlink" title="①Eureka的结构和作用"></a>①Eureka的结构和作用</h3><p>这些问题都需要利用SpringCloud中的注册中心来解决，其中最广为人知的注册中心就是Eureka，其结构如下：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210713220104956.png" alt="image-20210713220104956" style="zoom: 50%;" />



<p>在Eureka架构中，微服务角色有两类：</p>
<ul>
<li><p>EurekaServer：服务端，注册中心记录服务信息心跳监控</p>
</li>
<li><p>EurekaClient：客户端</p>
<ul>
<li>Provider：服务提供者，例如案例中的 user-service注册自己的信息到EurekaServer<strong>每隔30秒向EurekaServer发送心跳</strong>，报告健康状态</li>
<li>consumer：服务消费者，例如案例中的 order-service根据服务名称从EurekaServer拉取服务列表基于服务列表做负载均衡，选中一个微服务后发起远程调用</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：一个微服务，既可以是服务提供者，又可以是服务消费者，因此eureka将服务注册、服务发现等功能统一封装到了eureka-client端</p>
</blockquote>
<blockquote>
<p><strong>问题1：order-service如何得知user-service实例地址？</strong></p>
<p>获取地址信息的流程如下：</p>
<ul>
<li>user-service服务实例启动后，将自己的信息注册到eureka-server（Eureka服务端）。这个叫服务注册</li>
<li>eureka-server保存服务名称到服务实例地址列表的映射关系</li>
<li>order-service根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取</li>
</ul>
<p><strong>问题2：order-service如何从多个user-service实例中选择具体的实例？</strong></p>
<ul>
<li>order-service从实例列表中利用负载均衡算法选中一个实例地址</li>
<li>向该实例地址发起远程调用</li>
</ul>
<p><strong>问题3：order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</strong></p>
<ul>
<li>user-service会每隔一段时间（默认30秒）向eureka-server发起请求，报告自己状态，称为心跳</li>
<li>当超过一定时间没有发送心跳时，eureka-server会认为微服务实例故障，将该实例从服务列表中剔除</li>
<li>order-service拉取服务时，就能将故障实例排除了</li>
</ul>
</blockquote>
<h3 id="②Eureka的使用"><a href="#②Eureka的使用" class="headerlink" title="②Eureka的使用"></a>②Eureka的使用</h3><img src="/img/SpringCloudAlibaba.assets/image-20230106091231320.png" alt="image-20230106091231320" style="zoom: 50%;" />

<p><strong>(1)搭建EurekaServer</strong></p>
<img src="/img/SpringCloudAlibaba.assets/image-20230106092334892.png" alt="image-20230106092334892" style="zoom: 50%;" />

<p>​					<mark>eureka的默认端口号是10086，访问localhost:10086就可以来到管理界面</mark></p>
<p><strong>（2）注册服务</strong></p>
<p>注册user-service:</p>
<img src="/img/SpringCloudAlibaba.assets/image-20230106092558966.png" alt="image-20230106092558966" style="zoom:50%;" />

<p>​					<mark>注册order-service步骤一样，只需要将yml配置文件中spring.application.name换成自己的服务名就行</mark></p>
<p><strong>（3）服务发现</strong></p>
<img src="/img/SpringCloudAlibaba.assets/image-20230106093920976.png" alt="image-20230106093920976" style="zoom: 50%;" />

<h2 id="1-4Ribbon负载均衡"><a href="#1-4Ribbon负载均衡" class="headerlink" title="1.4Ribbon负载均衡"></a>1.4Ribbon负载均衡</h2><p>我们使用@LoadBalanced使得远程调用多个服务可以负载均衡，那么它是怎么实现的呢？</p>
<h3 id="①负载均衡原理"><a href="#①负载均衡原理" class="headerlink" title="①负载均衡原理"></a>①负载均衡原理</h3><p>SpringCloud底层其实是利用了一个名为Ribbon的组件，来实现负载均衡功能的。</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210713224517686.png" alt="image-20210713224517686" style="zoom:50%;" />

<p>那么我们发出的请求明明是<a target="_blank" rel="noopener" href="http://userservice/user/1%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8F%98%E6%88%90%E4%BA%86http://localhost:8081%E7%9A%84%E5%91%A2%EF%BC%9F">http://userservice/user/1，怎么变成了http://localhost:8081的呢？</a></p>
<h3 id="②源码跟踪"><a href="#②源码跟踪" class="headerlink" title="②源码跟踪"></a>②源码跟踪</h3><p>为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。</p>
<p>显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是<code>LoadBalancerInterceptor</code>，这个类会在对RestTemplate的请求进行拦截，然后从Eureka根据服务id获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务id。</p>
<p>我们进行源码跟踪：</p>
<p><mark><strong>（1）LoadBalancerIntercepor</strong></mark></p>
<img src="/img/SpringCloudAlibaba.assets/1525620483637.png" alt="1525620483637" style="zoom: 67%;" />

<p>可以看到这里的intercept方法，拦截了用户的HttpRequest请求，然后做了几件事：</p>
<ul>
<li><code>request.getURI()</code>：获取请求uri，本例中就是 <a target="_blank" rel="noopener" href="http://user-service/user/8">http://user-service/user/8</a></li>
<li><code>originalUri.getHost()</code>：获取uri路径的主机名，其实就是服务id，<code>user-service</code></li>
<li><code>this.loadBalancer.execute()</code>：处理服务id，和用户请求。</li>
</ul>
<p>这里的<code>this.loadBalancer</code>是<code>LoadBalancerClient</code>类型，我们继续跟入。</p>
<p><mark><strong>（2）LoadBalancerClient</strong></mark></p>
<p>继续跟入execute方法：</p>
<img src="/img/SpringCloudAlibaba.assets/1525620787090.png" alt="1525620787090" style="zoom: 67%;" />

<p>代码是这样的：</p>
<ul>
<li>getLoadBalancer(serviceId)：根据服务id获取ILoadBalancer，而ILoadBalancer会拿着服务id去eureka中获取服务列表并保存起来。</li>
<li>getServer(loadBalancer)：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了8082端口的服务</li>
</ul>
<p>放行后，再次访问并跟踪，发现获取的是8081：</p>
<p> <img src="/img/SpringCloudAlibaba.assets/1525620835911.png" alt="1525620835911"></p>
<p>果然实现了负载均衡。</p>
<p><mark><strong>（3）负载均衡策略IRule</strong></mark></p>
<p>在刚才的代码中，可以看到获取服务使通过一个<code>getServer</code>方法来做负载均衡:</p>
<p> <img src="/img/SpringCloudAlibaba.assets/1525620835911.png" alt="1525620835911"></p>
<p>我们继续跟入：</p>
<img src="/img/SpringCloudAlibaba.assets/1544361421671.png" alt="1544361421671" style="zoom:67%;" />

<p>继续跟踪源码chooseServer方法，发现这么一段代码：</p>
 <img src="/img/SpringCloudAlibaba.assets/1525622652849.png" alt="1525622652849" style="zoom:67%;" />

<p>我们看看这个rule是谁：</p>
 <img src="/img/SpringCloudAlibaba.assets/1525622699666.png" alt="1525622699666" style="zoom:67%;" />

<p>这里的rule默认值是一个<code>RoundRobinRule</code>，看类的介绍：</p>
 <img src="/img/SpringCloudAlibaba.assets/1525622754316.png" alt="1525622754316" style="zoom:67%;" />

<p>这不就是轮询的意思嘛。</p>
<p>到这里，整个负载均衡的流程我们就清楚了。</p>
<p><mark><strong>（4）总结</strong></mark></p>
<p>SpringCloudRibbon的底层采用了一个拦截器，拦截了RestTemplate发出的请求，对地址做了修改。用一幅图来总结一下：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210713224724673.png" alt="image-20210713224724673" style="zoom:50%;" />



<p>基本流程如下：</p>
<ul>
<li>拦截我们的RestTemplate请求<a target="_blank" rel="noopener" href="http://userservice/user/1">http://userservice/user/1</a></li>
<li>RibbonLoadBalancerClient会从请求url中获取服务名称，也就是user-service</li>
<li>DynamicServerListLoadBalancer根据user-service到eureka拉取服务列表</li>
<li>eureka返回列表，localhost:8081、localhost:8082</li>
<li>IRule利用内置负载均衡规则，从列表中选择一个，例如localhost:8081</li>
<li>RibbonLoadBalancerClient修改请求地址，用localhost:8081替代userservice，得到<a target="_blank" rel="noopener" href="http://localhost:8081/user/1%EF%BC%8C%E5%8F%91%E8%B5%B7%E7%9C%9F%E5%AE%9E%E8%AF%B7%E6%B1%82">http://localhost:8081/user/1，发起真实请求</a></li>
</ul>
<hr>
<h3 id="③负载均衡策略"><a href="#③负载均衡策略" class="headerlink" title="③负载均衡策略"></a>③负载均衡策略</h3><p>负载均衡的规则都定义在IRule接口中，而IRule有很多不同的实现类：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210713225653000.png" alt="image-20210713225653000" style="zoom:50%;" />

<p>不同规则的含义如下：</p>
<table>
<thead>
<tr>
<th><strong>内置负载均衡规则类</strong></th>
<th><strong>规则描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>RoundRobinRule</td>
<td>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td>
</tr>
<tr>
<td>AvailabilityFilteringRule</td>
<td>对以下两种服务器进行忽略：   （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。  （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<clientName>.<clientConfigNameSpace>.ActiveConnectionsLimit属性进行配置。</td>
</tr>
<tr>
<td>WeightedResponseTimeRule</td>
<td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td>
</tr>
<tr>
<td><strong>ZoneAvoidanceRule</strong></td>
<td>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td>
</tr>
<tr>
<td>BestAvailableRule</td>
<td>忽略那些短路的服务器，并选择并发数较低的服务器。</td>
</tr>
<tr>
<td>RandomRule</td>
<td>随机选择一个可用的服务器。</td>
</tr>
<tr>
<td>RetryRule</td>
<td>重试机制的选择逻辑</td>
</tr>
</tbody></table>
<blockquote>
<p>默认的实现就是ZoneAvoidanceRule，是一种基于区域轮询方案，优先选择最近地区的服务进行轮询</p>
</blockquote>
<h3 id="④自定义负载均衡策略"><a href="#④自定义负载均衡策略" class="headerlink" title="④自定义负载均衡策略"></a>④自定义负载均衡策略</h3><p>通过定义IRule实现可以修改负载均衡规则，有两种方式：</p>
<p>（1）代码方式：在order-service的配置类中，注册一个新的IRule，它就会替代默认的负载均衡策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">randomRule</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userservice:</span> <span class="comment"># 给某个微服务配置负载均衡规则，这里是userservice服务</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment"># 负载均衡规则 </span></span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>注意</strong>，一般用默认的负载均衡规则，不做修改。</p>
</blockquote>
<h3 id="⑤饥饿加载"><a href="#⑤饥饿加载" class="headerlink" title="⑤饥饿加载"></a>⑤饥饿加载</h3><p>Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。</p>
<p>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eager-load:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span>		<span class="comment">#开启饥饿加载</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="string">userservice</span>		<span class="comment">#只针对userservice服务进行饥饿加载，这个属性是一个数组</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="1-5Nacos注册中心"><a href="#1-5Nacos注册中心" class="headerlink" title="1.5Nacos注册中心"></a>1.5Nacos注册中心</h2><p><a target="_blank" rel="noopener" href="https://nacos.io/">Nacos</a>是阿里巴巴的产品，现在是<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-cloud">SpringCloud</a>中的一个组件。相比<a target="_blank" rel="noopener" href="https://github.com/Netflix/eureka">Eureka</a>功能更加丰富，在国内受欢迎程度较高。</p>
<blockquote>
<p>Nacos的安装启动详见老师给的Nacos安装指南.md</p>
</blockquote>
<h3 id="①Nacos注册服务"><a href="#①Nacos注册服务" class="headerlink" title="①Nacos注册服务"></a>①Nacos注册服务</h3><p>​				1.在cloud-demo父工程中添加spring-cloud-alibaba的管理依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>&#123;project-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​					2.注释掉微服务中原有的eruka依赖</p>
<p>​					3.在微服务的pom.xml文件中添加nacos客户端依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/img/SpringCloudAlibaba.assets/image-20230106100708840.png" alt="image-20230106100708840" style="zoom: 50%;" />

<ul>
<li><h5 id="Nacos服务端启动注意事项"><a href="#Nacos服务端启动注意事项" class="headerlink" title="Nacos服务端启动注意事项"></a>Nacos服务端启动注意事项</h5></li>
</ul>
<p>Nacos启动命令（单体模式）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">windows</span></span><br><span class="line">startup.bat -m standalone</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">linux</span></span><br><span class="line">sh startup.sh -m standalone</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker</span></span><br><span class="line">docker run --name nacos -p 8849:8848 -m standalone -d nacos/nacos-server</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<strong>Nacos安装时默认的数据库是内嵌的Derby数据库</strong>。这个数据库用于存储Nacos的配置信息和元数据。然而，在分布式场景下，如果使用多个Nacos作为配置中心和服务注册中心，每个Nacos服务都使用自带的Derby数据库，可能会导致数据不一致的问题。因此，在生产环境中，通常建议将Nacos的数据库配置为外部的MySQL数据库，以确保数据的一致性和可靠性。</p>
<p>我们在Mysql中创建一个nacos-config的数据库，并执行nacos提供的脚本（在<code>nacos/conf</code>目录下，通常叫<code>mysql-schema.sql</code>）</p>
<img src="/img/SpringCloudAlibaba.assets/Snipaste_2024-03-15_23-21-48.png" alt="Snipaste_2024-03-15_23-21-48" style="zoom:50%;" />

<p>并修改<code>nacos/conf</code>目录下的<code>application.properties</code>配置文件：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># db mysql</span></span><br><span class="line"><span class="attr">spring.datasource.platform</span>=<span class="string">mysql</span></span><br><span class="line"><span class="attr">db.num</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">db.url.0</span>=<span class="string">jdbc:mysql://localhost:3306/nacos-config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="attr">db.user</span>=<span class="string">root  # 用户名</span></span><br><span class="line"><span class="attr">db.password</span>=<span class="string">password # 密码</span></span><br></pre></td></tr></table></figure>

<p>而如果是在docker环境下，则需要：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start nacos #启动Nacos容器</span><br><span class="line">docker exec --it nacos bash #进入nacos容器内部</span><br><span class="line">cd /home/nacos/conf</span><br><span class="line">vi application.properties #修改配置文件</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="②Nacos的服务分级存储模型"><a href="#②Nacos的服务分级存储模型" class="headerlink" title="②Nacos的服务分级存储模型"></a>②Nacos的服务分级存储模型</h3><p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的user-service，可以有:</p>
<ul>
<li>127.0.0.1:8081</li>
<li>127.0.0.1:8082</li>
<li>127.0.0.1:8083</li>
</ul>
<p>假如这些实例分布于全国各地的不同机房，例如：</p>
<ul>
<li>127.0.0.1:8081，在上海机房</li>
<li>127.0.0.1:8082，在上海机房</li>
<li>127.0.0.1:8083，在杭州机房</li>
</ul>
<p>Nacos就将同一机房内的实例 划分为一个<strong>集群</strong>。</p>
<p>也就是说，user-service是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210713232522531.png" alt="image-20210713232522531" style="zoom: 33%;" />



<p>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210713232658928.png" alt="image-20210713232658928" style="zoom: 33%;" />

<p>杭州机房内的order-service应该优先访问同机房的user-service。</p>
<h3 id="③Nacos配置集群"><a href="#③Nacos配置集群" class="headerlink" title="③Nacos配置集群"></a>③Nacos配置集群</h3><p>修改user-service的application.yml文件，添加集群配置：<strong>（Nacos的负载均衡也是通过Ribbon实现的）</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment"># 集群名称</span></span><br></pre></td></tr></table></figure>

<p>这样Nacos就会将集群名一样的划分为一个集群。</p>
<hr>
<p><mark><strong>同集群优先的负载均衡：</strong></mark></p>
<p>Nacos默认也是使用的<code>ZoneAvoidanceRule</code>，默认的<code>ZoneAvoidanceRule</code>并不能实现根据同集群优先来实现负载均衡。</p>
<p>因此Nacos中提供了一个<code>NacosRule</code>的实现，可以优先从同集群中挑选实例。</p>
<p>1）给order-service配置集群信息</p>
<p>修改order-service的application.yml文件，添加集群配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment"># 集群名称</span></span><br></pre></td></tr></table></figure>



<p>2）修改负载均衡规则</p>
<p>修改order-service的application.yml文件，修改负载均衡规则：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="comment"># 负载均衡规则 </span></span><br></pre></td></tr></table></figure>

<p>这样在服务远程调用时就会优先调用与自己同一集群的服务</p>
<hr>
<h3 id="④Nacos权重配置"><a href="#④Nacos权重配置" class="headerlink" title="④Nacos权重配置"></a>④Nacos权重配置</h3><p>实际部署中会出现这样的场景：</p>
<p><em><u>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。</u></em></p>
<p><em><u>但默认情况下NacosRule是同集群内随机挑选，不会考虑机器的性能问题。</u></em></p>
<p>因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。</p>
<p>在nacos控制台，找到user-service的实例列表，点击编辑，即可修改权重：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210713235133225.png" alt="image-20210713235133225" style="zoom: 50%;" />

<p>在弹出的编辑窗口，修改权重：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210713235235219.png" alt="image-20210713235235219" style="zoom:50%;" />

<blockquote>
<p><strong>注意</strong>：如果权重修改为0，则该实例永远不会被访问</p>
</blockquote>
<h3 id="⑤Nacos环境隔离"><a href="#⑤Nacos环境隔离" class="headerlink" title="⑤Nacos环境隔离"></a>⑤Nacos环境隔离</h3><blockquote>
<p><strong>namespace</strong>：在Nacos中，namespace主要用来<strong>区分不同的环境</strong>，例如开发环境、测试环境和生产环境等。不同的命名空间下可以存在相同的group或Data ID的配置。这种配置隔离的特性使得不同环境的资源（如配置、服务）能够被有效隔离，防止因为配置冲突而导致的问题。默认情况下，如果不明确指定，namespace的值为public。</p>
<p><strong>group</strong>：group在Nacos中用于<strong>区分不同类型的项目</strong>，进行分组管理。一个group可以代表某个项目或者模块，如“XX医疗项目”或“XX电商项目”。通过group，我们可以对配置文件进行更细粒度的管理和组织。默认情况下，如果不明确指定group配置，那么默认使用的是DEFAULT_GROUP。</p>
</blockquote>
<p>Nacos提供了<code>namespace</code>来实现环境隔离功能。</p>
<ul>
<li>nacos中可以有多个namespace</li>
<li>namespace下可以有group、service等</li>
<li>不同namespace之间相互隔离，例如不同namespace的服务互相不可见</li>
</ul>
<img src="/img/SpringCloudAlibaba.assets/image-20210714000101516.png" alt="image-20210714000101516" style="zoom: 33%;" />

<hr>
<p><em>环境隔离常用与在不同环境下将服务隔离开，其设置也很简单：</em></p>
<ol>
<li>先在Nacos的服务端设置命名空间，ID（可以自己填写，默认自动生成）</li>
<li>在服务的yaml文件中设置其命名空间的ID，将其加入该命名空间</li>
</ol>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">492a7d5d-237b-46a1-a99a-fa8e98e4b0f9</span> <span class="comment"># 命名空间，填ID</span></span><br></pre></td></tr></table></figure>

<p><mark>这样的话，不在同一个命名空间下的服务就无法相互访问</mark></p>
<h3 id="⑥Nacos与Eureka的区别"><a href="#⑥Nacos与Eureka的区别" class="headerlink" title="⑥Nacos与Eureka的区别"></a>⑥Nacos与Eureka的区别</h3><p>Nacos的服务实例分为两种类型：</p>
<ul>
<li><p>临时实例：如果实例宕机超过一定时间，会从服务列表剔除，<strong>默认的类型</strong>。</p>
</li>
<li><p>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</p>
</li>
</ul>
<p>配置一个服务实例为永久实例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">ephemeral:</span> <span class="literal">false</span> <span class="comment"># 设置为非临时实例</span></span><br></pre></td></tr></table></figure>





<p>Nacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210714001728017.png" alt="image-20210714001728017" style="zoom:50%;" />



<ul>
<li><p>Nacos与eureka的共同点</p>
<ul>
<li>都支持服务注册和服务拉取</li>
<li>都支持服务提供者心跳方式做健康检测</li>
</ul>
</li>
<li><p>Nacos与Eureka的区别</p>
<ul>
<li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li>
<li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li>
<li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li>
<li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li>
</ul>
</li>
</ul>
<hr>
<h2 id="1-6Nacos配置管理"><a href="#1-6Nacos配置管理" class="headerlink" title="1.6Nacos配置管理"></a>1.6Nacos配置管理</h2><p>Nacos除了做注册中心，还可以进行配置管理</p>
<h3 id="①统一配置管理"><a href="#①统一配置管理" class="headerlink" title="①统一配置管理"></a>①统一配置管理</h3><img src="/img/SpringCloudAlibaba.assets/image-20210714164426792-16729845558881.png" alt="image-20210714164426792" style="zoom:50%;" />

<p>Nacos一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。</p>
<p><strong>（1）在nacos中添加配置文件</strong></p>
<ol>
<li>现在nacos客户端新建一个配置文件，具体命名如下格式，一般设置为yaml格式</li>
</ol>
<img src="/img/SpringCloudAlibaba.assets/image-20230106135858509.png" alt="image-20230106135858509" style="zoom:50%;" />

<p>服务名称以及Profiles开发环境的配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">application:</span> </span><br><span class="line">		<span class="attr">name:</span> <span class="string">微服务名称</span></span><br><span class="line">     <span class="attr">profiles:</span> </span><br><span class="line">     	<span class="attr">active:</span> <span class="string">开发环境</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：项目的核心配置，需要热更新的配置才有放到nacos管理的必要。基本不会变更的一些配置还是保存在微服务本地比较好。</p>
</blockquote>
<p><strong>（2）从配置中心拉取配置</strong></p>
<p>微服务要拉取nacos中管理的配置，并且与本地的application.yml配置合并，才能完成项目启动。</p>
<p>但项目启动时首先要读取application.yml文件，但我们关于nacos的配置又是写在application.yml中的，这个问题如何解决？</p>
<p>*<u>因此spring引入了一种新的配置文件：bootstrap.yaml文件，会在application.yml之前被读取</u>*，流程如下：</p>
<img src="/img/SpringCloudAlibaba.assets/L0iFYNF.png" alt="img" style="zoom:50%;" />



<p>1）引入nacos-config依赖</p>
<p>首先，在user-service服务中，引入nacos-config的客户端依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos配置管理依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2）添加bootstrap.yaml</p>
<p>然后，在user-service中添加一个bootstrap.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment">#开发环境，这里是dev </span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># Nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">          <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#文件后缀名</span></span><br><span class="line">          <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">xuecheng-plus-project</span></span><br><span class="line">          <span class="attr">refresh-enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>这里会根据spring.cloud.nacos.server-addr获取nacos地址，再根据<code>$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</code>作为文件id，去Nacos配置文件中读取配置。再将两个配置文件合并。</p>
<blockquote>
<p><mark>我们可以通过@Value或者@ConfigurationProperties注解将nacos配置中心的配置文件信息注入属性。</mark></p>
</blockquote>
<hr>
<h3 id="②配置热更新"><a href="#②配置热更新" class="headerlink" title="②配置热更新"></a>②配置热更新</h3><p>我们最终的目的，是修改nacos中的配置后，微服务中无需重启即可让配置生效，也就是<strong>配置热更新</strong>。</p>
<p>要实现配置热更新，可以使用两种方式：</p>
<p><strong>（1）方式一：</strong></p>
<p>在@Value注入的变量所在类上添加注解@RefreshScope：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210714171036335.png" alt="image-20210714171036335" style="zoom: 50%;" />

<p><strong>（2）方式二：</strong></p>
<p>使用@ConfigurationProperties注解代替@Value注解。</p>
<p>在user-service服务中，添加一个实体类，读取patterrn.dateformat属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;pattern&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PatternProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><u>之后就可以利用@Autowired注解自动装配这个对象并使用，无需其他注解</u></em></p>
<hr>
<h3 id="③配置共享"><a href="#③配置共享" class="headerlink" title="③配置共享"></a>③配置共享</h3><p>​		<strong>（1）相同服务共享配置</strong></p>
<p>微服务启动时，会去nacos读取多个配置文件，例如：</p>
<ul>
<li><p><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：userservice-dev.yaml</p>
</li>
<li><p><code>[spring.application.name].yaml</code>，例如：userservice.yaml</p>
</li>
</ul>
<p>而<code>[spring.application.name].yaml</code>不包含环境，<strong>因此可以被多个环境共享</strong>。比如userservice.yaml中的内容，它就可以被所有userservice服务读取到。</p>
<p>​		<strong>（2）多服务共享配置</strong></p>
<p><u><em>方式一：使用<code>shared-configs字段</code></em></u></p>
<p>​																			<img src="/img/SpringCloudAlibaba.assets/image-20230106151133688.png" alt="image-20230106151133688" style="zoom:33%;" />														</p>
<p><u><em>方式二：使用<code>extends-configs字段</code></em></u></p>
<img src="/img/SpringCloudAlibaba.assets/image-20230106150910743.png" alt="image-20230106150910743" style="zoom:33%;" />

<p><em><mark>配置共享的优先级：</mark></em></p>
<p><strong>（1）相同服务：</strong></p>
<p>当nacos、服务本地同时出现相同属性时，优先级有高低之分：**[服务名]-[环境].yaml &gt;[服务名].yaml &gt; 本地配置**</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210714174623557.png" alt="image-20210714174623557" style="zoom: 67%;" />

<p>而如果需要本地配置优先则需要在配置文件中配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">cloud:</span></span><br><span class="line">		<span class="attr">config:</span></span><br><span class="line">			<span class="attr">override-none:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>有了这个配置后如果我们将<code>server.port</code>这个配置放在nacos配置文件中，就可以通过<code>VM Options</code>的<code>-Dserver.port=....</code>来启动端口号不同的另一个微服务。</p>
<p><strong>（2）多服务：</strong></p>
<ul>
<li>微服务默认读取的配置文件：</li>
</ul>
<p>[服务名]-[spring.profile.active].yaml，默认配置[服务名].yaml，</p>
<ul>
<li><p>多环境共享不同微服务共享的配置文件：通过<code>shared-configs</code>指定、通过<code>extension-configs</code>指定</p>
</li>
<li><p>优先级：环境配置 &gt;服务名.yaml &gt; extension-config &gt; extension-configs &gt; shared-configs &gt; 本地配置</p>
</li>
</ul>
<hr>
<h3 id="④搭建Nacos集群"><a href="#④搭建Nacos集群" class="headerlink" title="④搭建Nacos集群"></a>④搭建Nacos集群</h3><p>详见老师给的nacos集群搭建md文件</p>
<p><a href="">“D:\Java\黑马程序员\第4阶段—微服务&amp;中间件\1、微服务开发框架SpringCloud+RabbitMQ+Docker+Redis+搜索+分布式史上最全面的微服务全技术栈课程\1.实用篇\学习资料\day02-SpringCloud02\资料\nacos集群搭建.md”</a></p>
<hr>
<h2 id="1-7RestTemplate"><a href="#1-7RestTemplate" class="headerlink" title="1.7RestTemplate"></a>1.7RestTemplate</h2><blockquote>
<p><code>RestTemplate</code> 是 Spring 框架中的一个同步客户端，用于执行 HTTP 请求。它简化了与 HTTP 服务器的通信，并遵循 RESTful 原则。在基于 Spring 的应用程序中，<code>RestTemplate</code> 通常用于消费 RESTful Web 服务。以下是其主要功能和基本用法的概述：</p>
</blockquote>
<h3 id="①主要功能"><a href="#①主要功能" class="headerlink" title="①主要功能"></a>①主要功能</h3><ol>
<li><strong>简化操作:</strong> 提供常见 HTTP 操作的方法（如 GET、POST、PUT、DELETE 等），这些方法对底层 HTTP 交互进行了抽象，简化了开发工作。</li>
<li><strong>异常处理:</strong> 自动处理 HTTP 响应状态码异常，使得代码更简洁、可读。</li>
<li><strong>灵活性:</strong> 支持各种消息转换器（Message Converters），可以处理 JSON、XML 等多种数据格式。</li>
<li><strong>扩展性:</strong> 可以自定义请求工厂、消息转换器、错误处理器等，以满足特殊需求。</li>
</ol>
<h3 id="②基本用法"><a href="#②基本用法" class="headerlink" title="②基本用法"></a>②基本用法</h3><p><strong>1.添加依赖</strong></p>
<p><code>spring-boot-starter-web</code>中已经包含了<code>RestTemplate</code>相关依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2.在配置类中配置RestTemplate Bean</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//GET</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://api.example.com/data&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(url, String.class);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//POST</span></span><br><span class="line">    <span class="keyword">public</span> MyResponseObject <span class="title function_">createData</span><span class="params">(MyRequestObject requestObject)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://api.example.com/data&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.postForObject(url, requestObject, MyResponseObject.class);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//PUT</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">(Long id, MyRequestObject updateObject)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://api.example.com/data/&quot;</span> + id;</span><br><span class="line">        restTemplate.put(url, updateObject);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteData</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;https://api.example.com/data/&quot;</span> + id;</span><br><span class="line">        restTemplate.delete(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="1-8Feign远程调用"><a href="#1-8Feign远程调用" class="headerlink" title="1.8Feign远程调用"></a>1.8Feign远程调用</h2><blockquote>
<p>先来看我们以前利用RestTemplate发起远程调用的代码：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210714174814204.png" alt="image-20210714174814204" style="zoom:50%;" />

<p>存在下面的问题：</p>
<p>•代码可读性差，编程体验不统一</p>
<p>•参数复杂URL难以维护</p>
<p>Feign是一个声明式的http客户端，官方地址：<a target="_blank" rel="noopener" href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p>
<p>其作用就是<strong>帮助我们优雅的实现http请求的发送，解决上面提到的问题</strong>。</p>
</blockquote>
<h3 id="①Feign替代RestTemplate"><a href="#①Feign替代RestTemplate" class="headerlink" title="①Feign替代RestTemplate"></a>①Feign替代RestTemplate</h3><p><strong>(1)引入依赖</strong></p>
<p>我们在order-service服务的pom文件中引入feign的依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）添加<code>@EnableFeignClients</code>注解</strong></p>
<p>在order-service的启动类添加注解开启Feign的功能：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210714175102524.png" alt="image-20210714175102524" style="zoom:50%;" />



<p><strong>(3)编写Feign的客户端</strong></p>
<p>在order-service中新建一个接口，内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;userservice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@FeignClient</code>注解的<code>value</code>属性为远程调用的目标服务的名称	</p>
<p>这个客户端主要是基于SpringMVC的注解来声明远程调用的信息，比如：</p>
<ul>
<li>服务名称：<code>userservice</code></li>
<li>请求方式：GET</li>
<li>请求路径：<code>/user/&#123;id&#125;</code></li>
<li>请求参数：Long id</li>
<li>返回值类型：User</li>
</ul>
<p>这样，Feign就可以帮助我们发送http请求，无需自己使用RestTemplate来发送了。</p>
<blockquote>
<p>注意：<code>@FeignClient</code>注解声明的微服务只用于声明服务的<code>ip</code>和端口号，下面的<code>Mapping</code>注解中应该声明包括微服务<code>context-path</code>的完整接口路径。</p>
<p>也可以在<code>Client</code>接口上添加<code>Mapping</code>注解声明请求的微服务的<code>context-path</code>。</p>
</blockquote>
<p><strong>（4）使用client</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserClient userClient;</span><br><span class="line"><span class="keyword">public</span> Order <span class="title function_">queryOrderById</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询订单</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderMapper.findById(orderId);</span><br><span class="line">    <span class="comment">//2.利用client对象调用方法发送请求</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userClient.findById(order.getUserId());</span><br><span class="line">    <span class="comment">//3.set数据</span></span><br><span class="line">    order.setUser(user);</span><br><span class="line">    <span class="comment">// 4.返回</span></span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="②Feign的自定义配置"><a href="#②Feign的自定义配置" class="headerlink" title="②Feign的自定义配置"></a>②Feign的自定义配置</h3><p>Feign可以支持很多的自定义配置，如下表所示：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>feign.Logger.Level</strong></td>
<td>修改日志级别</td>
<td>包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td>
</tr>
<tr>
<td>feign.codec.Decoder</td>
<td>响应结果的解析器</td>
<td>http远程调用的结果做解析，例如解析json字符串为java对象</td>
</tr>
<tr>
<td>feign.codec.Encoder</td>
<td>请求参数编码</td>
<td>将请求参数编码，便于通过http请求发送</td>
</tr>
<tr>
<td>feign. Contract</td>
<td>支持的注解格式</td>
<td>默认是SpringMVC的注解</td>
</tr>
<tr>
<td>feign. Retryer</td>
<td>失败重试机制</td>
<td>请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td>
</tr>
</tbody></table>
<p>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的@Bean覆盖默认Bean即可。（一般我们也只是修改日志配置）。</p>
<p><em><u>下面以日志为例来演示如何自定义配置：</u></em></p>
<p><strong>（1）修改application配置文件的方式：</strong></p>
<p>基于配置文件修改feign的日志级别可以针对单个服务：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span>  </span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span> </span><br><span class="line">      <span class="attr">userservice:</span> <span class="comment"># 针对某个微服务的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">FULL</span> <span class="comment">#  日志级别 </span></span><br></pre></td></tr></table></figure>

<p>也可以针对所有服务：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span>  </span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span> </span><br><span class="line">      <span class="attr">default:</span> <span class="comment"># 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">FULL</span> <span class="comment">#  日志级别 </span></span><br></pre></td></tr></table></figure>

<p>而日志的级别分为四种：</p>
<ul>
<li>NONE：不记录任何日志信息，这是默认值。</li>
<li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li>
<li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li>
<li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li>
</ul>
<p><strong>（2）Java代码的方式:</strong></p>
<p>也可以基于Java代码来修改日志级别，先声明一个类，然后声明一个Logger.Level的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultFeignConfiguration</span>  &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.Level <span class="title function_">feignLogLevel</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.BASIC; <span class="comment">// 日志级别为BASIC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果要<strong>全局生效</strong>，将其放到启动类的@EnableFeignClients这个注解中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class)</span> </span><br></pre></td></tr></table></figure>



<p>如果是<strong>局部生效</strong>，则把它放到对应的@FeignClient这个注解中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;userservice&quot;, configuration = DefaultFeignConfiguration .class)</span> </span><br></pre></td></tr></table></figure>



<h3 id="③Feign传输文件"><a href="#③Feign传输文件" class="headerlink" title="③Feign传输文件"></a>③Feign传输文件</h3><p>Feign传文件报错，Feign不支持上传文件需要借助外面的依赖才可以实现上传<br>具体报错内容：</p>
<p>FileUploadException: the request was rejected because no multipart boundary<br>原因就是Feigin相互调用不支持文件上传，怎么才可支持呢？那就是借助feign-form-spring、feign-form。</p>
<p>在消费端引入依赖并创建一个配置类:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign.form<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-form<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign.form<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-form-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><mark><strong>配置类：</strong></mark></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultipartSupportConfig</span> &#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Encoder <span class="title function_">feignFormEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringFormEncoder</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FeignClient接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;benjamin-service&quot;, path = &quot;/benjamin/service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SaveBenjaminInfoFeign</span> &#123;</span><br><span class="line">	<span class="meta">@PostMapping(value = &quot;/benjamin/uploadFiles&quot;, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uploadFiles</span><span class="params">(<span class="meta">@RequestPart(&quot;file&quot;)</span> MultipartFile file)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费方这里需要使用<code>@RequestPart</code>注解，而不是<code>@RequestParam</code>注解。并且需要指定<code>consumes=MediaType.Multipart_FORM_DATA_VALUE</code></strong></p>
<p>服务器端还是和原来一样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;benjamin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BenjaminController</span>&#123;</span><br><span class="line">	<span class="meta">@PostMapping(value = &quot;uploadFiles&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uploadFiles</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// do somthing</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			log.error(<span class="string">&quot;上传文件失败：&quot;</span>, e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这样就支持服务之间通过Feigin相互调用实现文件上传。</p>
<p>这就顺利解决了服务之间相互调用通过Feigin实现文件上传。</p>
<p><strong><mark>将<code>File</code>转化为<code>MultipartFile</code>的代码：</mark></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将file转为Multipart</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> MultipartFile <span class="title function_">getMultipartFile</span><span class="params">(File file)</span> &#123;</span><br><span class="line">    <span class="type">FileItem</span> <span class="variable">item</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DiskFileItemFactory</span>().createItem(<span class="string">&quot;file&quot;</span>, MediaType.MULTIPART_FORM_DATA_VALUE, <span class="literal">true</span>, file.getName());</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">         <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> item.getOutputStream();) &#123;</span><br><span class="line">        IOUtils.copy(inputStream, outputStream);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonsMultipartFile</span>(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="④Feign使用优化"><a href="#④Feign使用优化" class="headerlink" title="④Feign使用优化"></a>④Feign使用优化</h3><p>Feign底层发起http请求，依赖于其它的框架。其底层客户端实现包括：</p>
<ul>
<li><p>URLConnection：默认实现，不支持连接池</p>
</li>
<li><p>Apache HttpClient ：支持连接池</p>
</li>
<li><p>OKHttp：支持连接池</p>
</li>
</ul>
<p>因此提高Feign的性能主要手段就是<strong>使用连接池代替默认的URLConnection</strong>(因为不使用连接池的方式会频繁的创建连接销毁连接，降低性能)。</p>
<p>下面用Apache的HttpClient来演示。</p>
<p><strong>（1）引入依赖</strong></p>
<p>在order-service的pom文件中引入Apache的HttpClient依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--httpClient的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）配置连接池</strong></p>
<p>在order-service的application.yml中添加配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span> <span class="comment"># default全局的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">BASIC</span> <span class="comment"># 日志级别，BASIC就是基本的请求和响应信息</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启feign对HttpClient的支持</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">200</span> <span class="comment"># 最大的连接数</span></span><br><span class="line">    <span class="attr">max-connections-per-route:</span> <span class="number">50</span> <span class="comment"># 每个路径的最大连接数</span></span><br></pre></td></tr></table></figure>

<p><mark>总结，Feign的优化：</mark></p>
<p>1.日志级别尽量用basic</p>
<p>2.使用HttpClient或OKHttp代替URLConnection</p>
<p>①  引入feign-httpClient依赖</p>
<p>②  配置文件开启httpClient功能，设置连接池参数</p>
<hr>
<h3 id="⑤Feign的最佳实践"><a href="#⑤Feign的最佳实践" class="headerlink" title="⑤Feign的最佳实践"></a>⑤Feign的最佳实践</h3><blockquote>
<p>所谓最近实践，就是使用过程中总结的经验，最好的一种使用方式。</p>
<p><strong>仔细观察可以发现，Feign的客户端与服务提供者的controller代码非常相似</strong>：</p>
<p>feign客户端：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210714190542730.png" alt="image-20210714190542730" style="zoom: 50%;" />

<p>UserController：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20230106165131266.png" alt="image-20230106165131266" style="zoom: 33%;" />
</blockquote>
<p><em><u>有没有一种办法简化这种重复的代码编写呢？</u></em></p>
<p><strong>（1）方式一：继承</strong></p>
<p>一样的代码可以通过继承来共享：</p>
<p>1）定义一个API接口，利用定义方法，并基于SpringMVC注解做声明。</p>
<p>2）Feign客户端和Controller都继承该接口</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210714190640857.png" alt="image-20210714190640857" style="zoom: 50%;" />

<p>优点：</p>
<ul>
<li>简单</li>
<li>实现了代码共享</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>服务提供方、服务消费方紧耦合</p>
</li>
<li><p>参数列表中的注解映射并不会继承，因此Controller中必须再次声明方法、参数列表、注解</p>
</li>
</ul>
<p><strong>（2）方式二：抽取</strong></p>
<p>将<strong>Feign的Client抽取为独立模块（新建module）</strong>，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用，要使用时其他服务直接引用该模块的依赖即可。</p>
<p>例如，将UserClient、User、Feign的默认配置都抽取到一个feign-api包中，所有微服务引用该依赖包，即可直接使用。</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210714214041796.png" alt="image-20210714214041796" style="zoom: 33%;" />



<p><mark>注意：</mark></p>
<p><mark>之前的@FeignClient注解修饰的client接口能被识别到并创建代理实现类对象是因为它在springboot自动扫描的路径下，但是现在是通过引入依赖来使用，所以是无法自动装配client代理实现类的对象的，解决方法<em>（你可能会想到在启动类上添加@import等注解来引入这个类，但这样是不合适的）</em>：</mark></p>
<p><em>方式一：</em></p>
<p>指定Feign应该扫描的包：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;cn.itcast.feign.clients&quot;)</span></span><br></pre></td></tr></table></figure>

<p><em>方式二：</em></p>
<p>指定需要加载的Client接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(clients = &#123;UserClient.class&#125;)</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="1-9Gateway服务网关"><a href="#1-9Gateway服务网关" class="headerlink" title="1.9Gateway服务网关"></a>1.9Gateway服务网关</h2><blockquote>
<p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</p>
</blockquote>
<h3 id="①为什么需要网关"><a href="#①为什么需要网关" class="headerlink" title="①为什么需要网关"></a>①为什么需要网关</h3><p>Gateway网关是我们服务的守门神，所有微服务的统一入口。</p>
<p>网关的<strong>核心功能特性</strong>：</p>
<ul>
<li>请求路由</li>
<li>权限控制</li>
<li>限流</li>
</ul>
<p>架构图：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210714210131152.png" alt="image-20210714210131152" style="zoom: 50%;" />



<p><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</p>
<p><strong>路由和负载均衡</strong>：一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</p>
<p><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</p>
<p>在SpringCloud中网关的实现包括两种：</p>
<ul>
<li>gateway</li>
<li>zuul</li>
</ul>
<p>Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p>
<hr>
<h3 id="②Gateway使用"><a href="#②Gateway使用" class="headerlink" title="②Gateway使用"></a>②Gateway使用</h3><p><strong>（1）引入gateway和nacos依赖</strong>（因为gateway也是一个服务，需要注册到nacos中）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--网关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--nacos服务发现依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）编写application.yml配置文件</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span> <span class="comment"># 网关端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span> <span class="comment"># 网关路由配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> <span class="comment"># 路由id，自定义，只要唯一即可</span></span><br><span class="line">          <span class="comment"># uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userservice</span> <span class="comment"># 路由的目标地址 lb就是负载均衡，后面跟服务名称</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 路由断言，也就是判断请求是否符合路由规则的条件</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 这个是按照路径匹配，只要以/user/开头就符合要求</span></span><br></pre></td></tr></table></figure>

<p>路由配置包括：</p>
<ol>
<li><p>路由id：路由的唯一标示</p>
</li>
<li><p>路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</p>
</li>
<li><p>路由断言（predicates）：判断路由的规则</p>
</li>
<li><p>路由过滤器（filters）：对请求或响应做处理</p>
</li>
</ol>
<p>我们将符合<code>Path</code> 规则的一切请求，都代理到 <code>uri</code>参数指定的地址。</p>
<p>本例中，我们将 <code>/user/**</code>开头的请求，代理到<code>lb://userservice</code>（注意后面没加斜杠），<strong>lb代表loadbalance是负载均衡</strong>，根据服务名拉取服务列表，实现负载均衡。</p>
<blockquote>
<p>这里注意，所有<code>/user/**</code>开头的请求，最终会转到<code>http://userservice/user/**</code>这个URI。也就是说当网关匹配到<code>/user/**</code>是，它会<strong>将请求的路径一起路由到<code>userservice</code>这个微服务指定的地址</strong>。</p>
<p>这与nginx的反向代理<code>proxy_pass</code>同理。</p>
</blockquote>
<p><strong>(3)测试</strong></p>
<p>重启网关，访问<a target="_blank" rel="noopener" href="http://localhost:10010/user/1%E6%97%B6%EF%BC%8C%E7%AC%A6%E5%90%88%60/user/**%60%E8%A7%84%E5%88%99%EF%BC%8C%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%88%B0URI%EF%BC%9Ahttp://userservice/user/1%EF%BC%8C%E5%BE%97%E5%88%B0%E4%BA%86%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:10010/user/1时，符合`/user/**`规则，请求转发到URI：http://userservice/user/1，得到了结果：</a></p>
<img src="/img/SpringCloudAlibaba.assets/image-20210714211908341.png" alt="image-20210714211908341" style="zoom: 50%;" />

<p><mark>下面是整个访问的流程图：</mark></p>
<img src="/img/SpringCloudAlibaba.assets/image-20230107132241241.png" alt="image-20230107132241241" style="zoom:50%;" />

<hr>
<h3 id="③断言工厂"><a href="#③断言工厂" class="headerlink" title="③断言工厂"></a>③断言工厂</h3><p>我们在配置文件中写的断言规则只是字符串，这些字符串<em><strong>会被Predicate Factory读取并处理，转变为路由判断的条件</strong></em></p>
<p>例如Path&#x3D;&#x2F;user&#x2F;**是按照路径匹配，这个规则是由</p>
<p><code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code>类来</p>
<p>处理的，像这样的断言工厂在SpringCloudGateway还有十几个:</p>
<img src="/img/SpringCloudAlibaba.assets/image-20230107132644436.png" alt="image-20230107132644436" style="zoom:50%;" />

<blockquote>
<p>我们掌握一下Path这种路由工程就可</p>
</blockquote>
<hr>
<h3 id="④过滤器工厂"><a href="#④过滤器工厂" class="headerlink" title="④过滤器工厂"></a>④过滤器工厂</h3><p>GatewayFilter是网关中提供的一种过滤器，可以对进入网关的<strong>请求</strong>和微服务返回的<strong>响应</strong>做处理：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210714212312871.png" alt="image-20210714212312871" style="zoom:50%;" />

<p><strong>（1）过滤器的种类</strong></p>
<p>Spring提供了31种不同的路由过滤器工厂。例如：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20230107133139847.png" alt="image-20230107133139847" style="zoom: 50%;" />

<p><strong>（2）请求头过滤器</strong></p>
<p>下面我们以AddRequestHeader 为例来讲解。</p>
<blockquote>
<p><strong>需求</strong>：给所有进入userservice的请求添加一个请求头：authorization &#x3D; admin</p>
</blockquote>
<p>只需要修改gateway服务的application.yml文件，添加路由过滤即可：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> </span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://userservice</span> </span><br><span class="line">        <span class="attr">predicates:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/user/**</span> </span><br><span class="line">        <span class="attr">filters:</span> <span class="comment"># 过滤器</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=authorization,admin</span>  <span class="comment"># 添加请求头</span></span><br></pre></td></tr></table></figure>

<p>当前过滤器写在userservice路由下，因此仅仅对访问userservice的请求有效。</p>
<p><em>当我们通过10010端口访问userservice时，就会带上这个请求头</em></p>
<hr>
<p><strong>（3）默认过滤器</strong></p>
<p>如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> </span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://userservice</span> </span><br><span class="line">        <span class="attr">predicates:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/user/**</span></span><br><span class="line">      <span class="attr">default-filters:</span> <span class="comment"># 默认过滤项</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">AddRequestHeader=authorization,</span> <span class="string">admin!</span> </span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：</p>
<p>过滤器的作用是什么？</p>
<p>① 对路由的请求或响应做加工处理，比如添加请求头</p>
<p>② 配置在路由下的过滤器只对当前路由的请求生效</p>
<p>defaultFilters的作用是什么？</p>
<p>① 对所有路由都生效的过滤器</p>
</blockquote>
<hr>
<h3 id="⑤全局过滤器"><a href="#⑤全局过滤器" class="headerlink" title="⑤全局过滤器"></a>⑤全局过滤器</h3><p>上一节学习的过滤器，网关提供了31种，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现。</p>
<p><strong>（1）全局过滤器作用</strong></p>
<p>全局过滤器的作用也是*<mark>处理一切进入网关的请求和微服务响应</mark>*，与GatewayFilter的作用一样。区别在于GatewayFilter通过配置定义，处理逻辑是固定的；而GlobalFilter的逻辑需要自己写代码实现。</p>
<p>定义方式是实现GlobalFilter接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  处理当前请求，有必要的话通过&#123;<span class="doctag">@link</span> GatewayFilterChain&#125;将请求交给下一个过滤器处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange 请求上下文，里面可以获取Request、Response等信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chain 用来把请求委托给下一个过滤器 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> Mono&lt;Void&gt;&#125; 返回标示当前过滤器业务结束</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><u>通过exchange我们可以获得request和response的信息来编写业务逻辑，通过chain我们能放行</u></em></p>
<p>在filter中编写自定义逻辑，可以实现下列功能：</p>
<ul>
<li>登录状态判断</li>
<li>权限校验</li>
<li>请求限流等</li>
</ul>
<p><strong>（2）全局过滤器的使用示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order(1)</span>       <span class="comment">//设置过滤器的优先级，数字越小越优先,也可通过实现Order接口设置</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interceptor</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">//1.获取请求参数</span></span><br><span class="line">        MultiValueMap&lt;String, String&gt; queryParams = exchange.getRequest().getQueryParams();</span><br><span class="line">        <span class="comment">//2.获取authorization参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">authorization</span> <span class="operator">=</span> queryParams.getFirst(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="comment">//3.校验</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(authorization))&#123;</span><br><span class="line">            <span class="comment">//放行（其实是交给下一个过滤器处理）</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.拦截</span></span><br><span class="line">            <span class="comment">//设置响应状态码</span></span><br><span class="line">        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            <span class="comment">//拦截</span></span><br><span class="line">        <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）过滤器的执行顺序</strong></p>
<p>请求进入网关会碰到三类过滤器：*<u>当前路由的过滤器</u><em>、<u><em>DefaultFilter</em></u>、</em><u>GlobalFilter</u>*</p>
<p>请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，<mark>合并到一个过滤器链（集合）中</mark>，排序后依次执行每个过滤器：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210714214228409.png" alt="image-20210714214228409" style="zoom:50%;" />



<p>排序的规则是什么呢？</p>
<ul>
<li>每一个过滤器都必须指定一个int类型的order值，<strong>order值越小，优先级越高，执行顺序越靠前</strong>。</li>
<li>GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定</li>
<li><strong>路由过滤器和defaultFilter的order由Spring指定</strong>，默认是按照声明顺序从1递增，（在yml文件中写在越前面就越先执行）。</li>
<li>当过滤器的order值一样时，会按照 <mark>defaultFilter &gt; 路由过滤器 &gt; GlobalFilter</mark>的顺序执行。</li>
</ul>
<p>详细内容，可以查看源码：</p>
<ul>
<li><p><code>org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator#getFilters()</code>方法是先加载defaultFilters，然后再加载某个route的filters，然后合并。</p>
</li>
<li><p><code>org.springframework.cloud.gateway.handler.FilteringWebHandler#handle()</code>方法会加载全局过滤器，与前面的过滤器合并后根据order排序，组织过滤器链</p>
</li>
</ul>
<hr>
<h3 id="⑥跨域问题"><a href="#⑥跨域问题" class="headerlink" title="⑥跨域问题"></a>⑥跨域问题</h3><p><strong>（1）什么是跨域问题</strong></p>
<p>跨域：域名不一致就是跨域，主要包括：</p>
<ul>
<li><p>域名不同： <a target="_blank" rel="noopener" href="http://www.taobao.com/">www.taobao.com</a> 和 <a target="_blank" rel="noopener" href="http://www.taobao.org/">www.taobao.org</a> 和 <a target="_blank" rel="noopener" href="http://www.jd.com/">www.jd.com</a> 和 miaosha.jd.com</p>
</li>
<li><p>域名相同，端口不同：localhost:8080和localhost8081</p>
</li>
</ul>
<p>跨域问题：<mark>浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题</mark></p>
<p>解决方案：CORS，这个以前应该学习过，这里不再赘述了。不知道的小伙伴可以查看<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2016/04/cors.html">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>
<p><strong>（2）gateway网关跨域问题解决</strong></p>
<p>在gateway服务的application.yml文件中，添加下面的配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="comment"># 。。。</span></span><br><span class="line">      <span class="attr">globalcors:</span> <span class="comment"># 全局的跨域处理</span></span><br><span class="line">        <span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span> <span class="comment"># 解决options请求被拦截问题</span></span><br><span class="line">        <span class="attr">corsConfigurations:</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span>		<span class="comment">#表示拦截所有请求</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span> <span class="comment"># 允许哪些网站的跨域请求 </span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://localhost:8090&quot;</span></span><br><span class="line">            <span class="attr">allowedMethods:</span> <span class="comment"># 允许的跨域ajax的请求方式</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;GET&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;POST&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;DELETE&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;PUT&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;OPTIONS&quot;</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span> <span class="comment"># 允许在请求中携带的头信息</span></span><br><span class="line">            <span class="attr">allowCredentials:</span> <span class="literal">true</span> <span class="comment"># 是否允许携带cookie</span></span><br><span class="line">            <span class="attr">maxAge:</span> <span class="number">360000</span> <span class="comment"># 这次跨域检测的有效期</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="2-容器技术Docker"><a href="#2-容器技术Docker" class="headerlink" title="2.容器技术Docker"></a>2.容器技术Docker</h1><h2 id="2-1认识Docker"><a href="#2-1认识Docker" class="headerlink" title="2.1认识Docker"></a>2.1认识Docker</h2><h3 id="①什么是Docker"><a href="#①什么是Docker" class="headerlink" title="①什么是Docker?"></a>①什么是Docker?</h3><blockquote>
<p>微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。</p>
<ul>
<li>分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。</li>
<li>在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题</li>
</ul>
</blockquote>
<p>大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：</p>
<ul>
<li><p>依赖关系复杂，容易出现兼容性问题</p>
</li>
<li><p>开发、测试、生产环境有差异</p>
</li>
</ul>
<p><em><u>例如一个项目中，部署时需要依赖于node.js、Redis、RabbitMQ、MySQL等，这些服务部署时所需要的函数库、依赖项各不相同，甚至会有冲突。给部署带来了极大的困难。</u></em></p>
<img src="/img/SpringCloudAlibaba.assets/image-20210731141907366.png" alt="image-20210731141907366" style="zoom: 25%;" />





<p><strong>而Docker则是解决了这些问题</strong>：</p>
<p><mark>（1）Docker解决了应用部署的环境问题：</mark></p>
<p>Docker为了解决依赖的兼容问题的，采用了两个手段：</p>
<ul>
<li><p>将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包</p>
</li>
<li><p>将每个应用放到一个<strong>隔离容器</strong>去运行，避免互相干扰</p>
</li>
</ul>
<p>这样打包好的应用包中，既包含应用本身，也保护应用所需要的Libs、Deps，无需再操作系统上安装这些，自然就不存在不同应用之间的兼容问题了。</p>
<img src="/img/SpringCloudAlibaba.assets/image-20230108090647294.png" alt="image-20230108090647294" style="zoom: 25%;" />

<p><mark>（2）Docker解决了操作系统环境差异：</mark></p>
<p>操作系统结构包括：</p>
<ul>
<li>计算机硬件：例如CPU、内存、磁盘等</li>
<li>系统内核：所有Linux发行版的内核都是Linux，例如CentOS、Ubuntu、Fedora等。内核可以与计算机硬件交互，对外提供<strong>内核指令</strong>，用于操作计算机硬件。</li>
<li>系统应用：操作系统本身提供的应用、函数库。这些函数库是对内核指令的封装，使用更加方便。</li>
</ul>
<p>应用于计算机交互的流程如下：</p>
<p>1）应用调用操作系统应用（函数库），实现各种功能</p>
<p>2）系统函数库是对内核指令集的封装，会调用内核指令</p>
<p>3）内核指令操作计算机硬件</p>
<p><em><u>因此，如果一个应用适配的操作系统与当前操作系统不一致，那么就会发生应用找不到系统函数库而报错。</u></em></p>
<p><strong>Docker如何解决不同系统环境的问题？</strong></p>
<ul>
<li>Docker将用户程序与所需要调用的系统(比如Ubuntu)函数库一起打包</li>
<li>Docker运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的Linux内核来运行</li>
</ul>
<p>如图：</p>
<hr>
<p><mark>总结：</mark></p>
<p>Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？</p>
<ul>
<li>Docker允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li>
<li>Docker应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li>
</ul>
<p>Docker如何解决开发、测试、生产环境有差异的问题？</p>
<ul>
<li>Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</li>
</ul>
<p>Docker是一个<strong>快速交付应用、运行应用的技术</strong>，具备下列优势：</p>
<ul>
<li>可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统</li>
<li>运行时利用沙箱机制形成隔离容器，各个应用互不干扰</li>
<li>启动、移除都可以通过一行命令完成，方便快捷</li>
</ul>
<hr>
<h3 id="②Docker与虚拟机的区别"><a href="#②Docker与虚拟机的区别" class="headerlink" title="②Docker与虚拟机的区别"></a>②Docker与虚拟机的区别</h3><p>Docker可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。</p>
<p>两者有什么差异呢？</p>
<p><strong>虚拟机</strong>（virtual machine）是在操作系统中<strong>模拟硬件设备</strong>，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的Ubuntu应用了。</p>
<p><strong>Docker</strong>仅仅是封装函数库，并没有模拟完整的操作系统，如图：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210731145914960.png" alt="image-20210731145914960" style="zoom: 25%;" />

<p>对比来看：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210731152243765.png" alt="image-20210731152243765" style="zoom: 25%;" />



<p>小结：</p>
<p>Docker和虚拟机的差异：</p>
<ul>
<li><p>docker是一个系统进程；虚拟机是在操作系统中的操作系统</p>
</li>
<li><p>docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般</p>
</li>
</ul>
<hr>
<h3 id="③Docker架构"><a href="#③Docker架构" class="headerlink" title="③Docker架构"></a>③Docker架构</h3><h4 id="1-镜像和容器"><a href="#1-镜像和容器" class="headerlink" title="(1) 镜像和容器"></a>(1) 镜像和容器</h4><p>Docker中有几个重要的概念：</p>
<p><strong>镜像（Image）</strong>：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</p>
<p><strong>容器（Container）</strong>：<em><strong>镜像中的应用程序运行后形成的进程就是容器</strong></em>，只是Docker会给容器进程做隔离，对外不可见。</p>
<p>一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的<strong>文件</strong>。只有运行时，才会加载到内存，形成进程。</p>
<p>而<strong>镜像</strong>，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。</p>
<p><strong>容器</strong>呢，就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。因此一个镜像可以启动多次，形成多个容器进程。</p>
<p><mark>镜像中不允许写入数据，数据写入都是在容器中</mark></p>
<img src="/img/SpringCloudAlibaba.assets/image-20210731153059464.png" alt="image-20210731153059464" style="zoom:25%;" />



<p>例如你下载了一个QQ，如果我们将QQ在磁盘上的运行<strong>文件</strong>及其运行的操作系统依赖打包，形成QQ镜像。然后你可以启动多次，双开、甚至三开QQ，跟多个妹子聊天。</p>
<hr>
<h4 id="2-Dockerhub"><a href="#2-Dockerhub" class="headerlink" title="(2) Dockerhub"></a>(2) Dockerhub</h4><p>开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如Redis、MySQL镜像放到网络上，共享使用，就像GitHub的代码共享一样。</p>
<ul>
<li><p>DockerHub：*<u>DockerHub是一个官方的Docker镜像的托管平台</u>*。这样的平台称为Docker Registry。</p>
</li>
<li><p>国内也有类似于DockerHub 的公开服务，比如 <a target="_blank" rel="noopener" href="https://c.163yun.com/hub">网易云镜像服务</a>、<a target="_blank" rel="noopener" href="https://cr.console.aliyun.com/">阿里云镜像库</a>等。</p>
</li>
</ul>
<p>我们一方面可以将自己的镜像共享到DockerHub，另一方面也可以从DockerHub拉取镜像：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210731153743354.png" alt="image-20210731153743354" style="zoom: 20%;" />

<hr>
<h4 id="3-Docker架构"><a href="#3-Docker架构" class="headerlink" title="(3) Docker架构"></a>(3) Docker架构</h4><p>我们要使用Docker来<strong>操作镜像、容器</strong>，就必须要安装Docker。</p>
<p>Docker是一个CS架构的程序，由两部分组成：</p>
<ul>
<li><p><strong>服务端</strong>(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等</p>
</li>
<li><p>**客户端(**client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</p>
</li>
</ul>
<p>如图：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210731154257653.png" alt="image-20210731154257653" style="zoom:20%;" />

<hr>
<h4 id="4-总结"><a href="#4-总结" class="headerlink" title="(4) 总结"></a>(4) 总结</h4><p>镜像：</p>
<ul>
<li>将应用程序及其依赖、环境、配置打包在一起</li>
</ul>
<p>容器：</p>
<ul>
<li>镜像运行起来就是容器，一个镜像可以运行多个容器</li>
</ul>
<p>Docker结构：</p>
<ul>
<li><p>服务端：接收命令或远程请求，操作镜像或容器</p>
</li>
<li><p>客户端：发送命令或者请求到Docker服务端</p>
</li>
</ul>
<p>DockerHub：</p>
<ul>
<li>一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry</li>
</ul>
<hr>
<h3 id="④安装Docker"><a href="#④安装Docker" class="headerlink" title="④安装Docker"></a>④安装Docker</h3><p>详见老师的centos7安装Docker.md笔记</p>
<p>镜像最好更换为国内的比如阿里云私服，下载速度快</p>
<hr>
<h2 id="2-2Docker的基本操作"><a href="#2-2Docker的基本操作" class="headerlink" title="2.2Docker的基本操作"></a>2.2Docker的基本操作</h2><h3 id="①镜像操作"><a href="#①镜像操作" class="headerlink" title="①镜像操作"></a>①镜像操作</h3><h4 id="1-镜像名称"><a href="#1-镜像名称" class="headerlink" title="(1) 镜像名称"></a>(1) 镜像名称</h4><p>首先来看下镜像的名称组成：</p>
<ul>
<li>镜名称一般分两部分组成：**[repository]:[tag]**。</li>
<li>tag代表镜像版本。在没有指定tag时，默认是latest，代表最新版本的镜像</li>
</ul>
<p>如图：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210731155141362.png" alt="image-20210731155141362" style="zoom:25%;" />

<p>这里的mysql就是repository，5.7就是tag，合一起就是镜像名称，代表5.7版本的MySQL镜像。</p>
<h4 id="2-镜像命令"><a href="#2-镜像命令" class="headerlink" title="(2) 镜像命令"></a>(2) 镜像命令</h4><p>常见的镜像操作命令如图：*<u>通过<code>docker xxx --help</code>命令就可以查看xxx命令的用法</u>*</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210731155649535.png" alt="image-20210731155649535" style="zoom:20%;" />

<ul>
<li>拉取镜像：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名称</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取最新版本镜像</span></span><br><span class="line">docker pull 镜像名称:latest</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取指定版本的镜像</span></span><br><span class="line">docker pull 镜像名称:ba&#x27;ne&#x27;b&#x27;n</span><br></pre></td></tr></table></figure>

<ul>
<li>将镜像打包保存：（-o表示output）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o 保存的目标文件名称 镜像名称</span><br></pre></td></tr></table></figure>

<ul>
<li>加载打包的镜像：（-i表示input）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i 包的文件名</span><br></pre></td></tr></table></figure>

<ul>
<li>移除镜像：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [选项：-f表示强制删除] 镜像名 [镜像名...]</span><br></pre></td></tr></table></figure>

<ul>
<li>查看所有镜像：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<ul>
<li>通过一个Dockerfile文件构建镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build [选项] Dockerfile文件所在路径</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">选项一般用 -t 指定镜像名（名称:版本）			.表示当前路径</span></span><br></pre></td></tr></table></figure>



<p><mark>示例：从dockerhub中拉取一个nginx镜像并查看：</mark></p>
<blockquote>
<p>这些命令在dockerhub官网搜索对应的镜像也能查看</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.从dockerhub上拉取镜像</span></span><br><span class="line">docker pull nginx</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2.查看所有镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3.将镜像保存为一个压缩包</span></span><br><span class="line">docker save -o nginx.tar nginx:latest</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4.强制删除nginx镜像</span></span><br><span class="line">docker rmi -f nginx</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">5.加载nginx镜像</span></span><br><span class="line">docker load -i nginx.tar</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="②容器操作"><a href="#②容器操作" class="headerlink" title="②容器操作"></a>②容器操作</h3><h4 id="1-容器命令"><a href="#1-容器命令" class="headerlink" title="(1) 容器命令"></a>(1) 容器命令</h4><p>常见容器操作的命令如图：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210731161950495.png" alt="image-20210731161950495" style="zoom:25%;" />

<p>容器保护三个状态：</p>
<ul>
<li>运行：进程正常运行</li>
<li>暂停：进程暂停，CPU不再运行，并不释放内存</li>
<li>停止：进程终止，回收进程占用的内存、CPU等资源</li>
</ul>
<p>命令详解：</p>
<ul>
<li><mark>暂停容器</mark></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pause 容器名 [容器名...]</span><br></pre></td></tr></table></figure>

<ul>
<li><mark>让一个容器从暂停状态恢复运行</mark></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker unpause 容器名 [容器名...]</span><br></pre></td></tr></table></figure>

<ul>
<li><mark>停止一个运行的容器</mark></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop [选项] 容器名 [容器名...]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">选项： -t :设置多少秒后停止，默认为10s</span></span><br></pre></td></tr></table></figure>

<ul>
<li><mark>让一个停止的容器再次运行</mark></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start [选项] 容器名 [容器名...]</span><br></pre></td></tr></table></figure>

<ul>
<li><mark>重启一个容器</mark></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker restart [选项] 容器名 [容器名...]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">选项： -t :设置多少秒后重启，默认为10s</span></span><br></pre></td></tr></table></figure>

<ul>
<li><mark>删除一个容器</mark></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rm [选项] 容器名 [容器名]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">其中一个选项是-f代表强制删除</span></span><br></pre></td></tr></table></figure>

<ul>
<li><mark>创建并运行nginx容器</mark></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name containerName -p 81:80 --restart=always [-e MYSQL_ROOT_PASSWORD=123456] -d mysql</span><br></pre></td></tr></table></figure>

<p>命令解读：</p>
<ul>
<li>docker run ：创建并运行一个容器</li>
<li>–name : 给容器起一个名字，比如叫做mn</li>
<li>-p ：将宿主机端口与容器端口映射，<strong>冒号左侧是宿主机端口，右侧是容器端口</strong></li>
<li>-d：后台运行容器</li>
<li>mysql：镜像名称，例如mysql</li>
<li>–restart&#x3D;always：容器随着docker重启而重启</li>
<li>-e MYSQL_ROOT_PASSWORD&#x3D;123456：用于设置MYSQL的初始密码</li>
</ul>
<p><u><em>这里的<code>-p</code>参数，是将容器端口映射到宿主机端口。</em></u></p>
<p><u><em>默认情况下，容器是隔离环境，我们直接访问宿主机的80端口，肯定访问不到容器中的nginx。</em></u></p>
<p><u><em>现在，将容器的80与宿主机的81关联起来，当我们访问宿主机的81端口时，就会被映射到容器的80，这样就能访问到nginx了。</em></u></p>
<ul>
<li><mark>查看当前正在运行的容器</mark></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps [选项]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">选项中包括 -a 表示显示所有容器包括已停止的</span></span><br></pre></td></tr></table></figure>

<ul>
<li><mark>查看容器日志</mark></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs [选项] 容器名</span><br></pre></td></tr></table></figure>

<ul>
<li><mark>进入容器</mark></li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mn bash</span><br><span class="line"><span class="comment">#退出容器：exit</span></span><br></pre></td></tr></table></figure>

<p>命令解读：</p>
<ul>
<li><p>docker exec ：进入容器内部，执行一个命令</p>
</li>
<li><p>-it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</p>
</li>
<li><p>mn ：要进入的容器的名称</p>
</li>
<li><p>bash：进入容器后执行的命令，bash是一个linux终端交互命令</p>
</li>
</ul>
<hr>
<h3 id="③数据卷"><a href="#③数据卷" class="headerlink" title="③数据卷"></a>③数据卷</h3><blockquote>
<p>在之前的nginx案例中，修改nginx的html页面时，需要进入nginx内部。并且因为没有编辑器，修改文件也很麻烦。</p>
<p>这就是因为容器与数据（容器内文件）耦合带来的后果。</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210731172440275.png" alt="image-20210731172440275" style="zoom:25%;" />

<p>要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。</p>
</blockquote>
<h4 id="（1）什么是数据卷"><a href="#（1）什么是数据卷" class="headerlink" title="（1）什么是数据卷"></a>（1）什么是数据卷</h4><p><strong>数据卷（volume）</strong>是一个虚拟目录，指向宿主机文件系统中的某个目录。</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210731173541846.png" alt="image-20210731173541846" style="zoom: 33%;" />

<p>一旦完成数据卷挂载，<strong>对容器的一切操作都会作用在数据卷对应的宿主机文件目录</strong>了。</p>
<p>这样，我们操作宿主机的&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;html目录，就等于操作容器内的&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html目录了</p>
<hr>
<h4 id="（2）数据集操作命令"><a href="#（2）数据集操作命令" class="headerlink" title="（2）数据集操作命令"></a>（2）数据集操作命令</h4><blockquote>
<p>数据卷操作的基本语法如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume [COMMAND]</span><br></pre></td></tr></table></figure>

<p>docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：</p>
<ul>
<li>create 创建一个volume</li>
<li>inspect 显示一个或多个volume的信息</li>
<li>ls 列出所有的volume</li>
<li>prune 删除未使用的volume</li>
<li>rm 删除一个或多个指定的volume</li>
</ul>
</blockquote>
<ul>
<li><mark>创建数据卷</mark></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create [选项] 数据卷名</span><br></pre></td></tr></table></figure>

<ul>
<li><mark>查看所有数据卷</mark></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls [选项]</span><br></pre></td></tr></table></figure>

<ul>
<li><mark>查看数据卷详细信息，包括关联的宿主机目录位置</mark></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect [选项] 数据卷名 [数据卷名...]</span><br></pre></td></tr></table></figure>

<ul>
<li><mark>删除指定数据卷</mark></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker volume rm [选项] 数据卷名 [数据卷名...]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">选项只有一个: -f 表示强制删除</span></span><br></pre></td></tr></table></figure>

<ul>
<li><mark>删除所有未使用的数据卷</mark></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker volume prune [选项]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">选项: -f 表示强制删除</span></span><br></pre></td></tr></table></figure>

<hr>
<p>上面的<code>docker volume create 数据卷名</code>的命令，创建的数据卷对应宿主机上的文件目录<strong>是docker自动为我们创建的</strong></p>
<p>而我们在创建容器时可以通过<code>-v</code>参数来自定义挂载一个数据卷到某个容器内目录：</p>
<ul>
<li><mark>自定义挂载一个数据卷到某个容器内目录示例：</mark></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --name mn \</span><br><span class="line">  -v html:/root/html \		#-v 数据卷名称:/将其挂载到容器的目录</span><br><span class="line">  -p 8080:80 \</span><br><span class="line">  -d \</span><br><span class="line">  nginx \</span><br></pre></td></tr></table></figure>

<blockquote>
<p>命令如果想写多行就可以在每一行末尾加上下划线\</p>
</blockquote>
<p>这里的-v就是挂载数据卷的命令：</p>
<p>​		<code>-v html:/root/htm</code> ：将名为html数据卷挂载到容器内的&#x2F;root&#x2F;html这个目录中。</p>
<p><em><u>在创建数据卷是docker自动将数据卷挂在到了宿主机的一个文件目录上，又通过<code>-v</code>将数据卷挂在到了容器上，这样容器与宿主机才一一对应起来。</u></em></p>
<hr>
<h4 id="（3）容器直接挂载宿主机目录"><a href="#（3）容器直接挂载宿主机目录" class="headerlink" title="（3）容器直接挂载宿主机目录"></a>（3）容器直接挂载宿主机目录</h4><p><strong>容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上</strong>。关联关系如下：</p>
<ul>
<li><em><u>带数据卷模式：宿主机目录 –&gt; 数据卷 —&gt; 容器内目录</u></em></li>
<li><em><u>直接挂载模式：宿主机目录 —&gt; 容器内目录</u></em></li>
</ul>
<p>如图：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210731175155453.png" alt="image-20210731175155453" style="zoom:30%;" />

<p><strong>语法</strong>：</p>
<p>目录挂载与数据卷挂载的语法是类似的：</p>
<ul>
<li><mark>-v [宿主机目录]:[容器内目录]</mark></li>
<li><mark>-v [宿主机文件]:[容器内文件]</mark></li>
</ul>
<p><u><em>数据卷挂载与目录直接挂载的</em></u></p>
<ul>
<li><u><em>数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找</em></u></li>
<li><u><em>目录挂载耦合度高，需要我们自己管理目录，不过目录是我们自己创建的，容易寻找查看</em></u></li>
</ul>
<hr>
<h2 id="2-3Dockerfile自定义镜像"><a href="#2-3Dockerfile自定义镜像" class="headerlink" title="2.3Dockerfile自定义镜像"></a>2.3Dockerfile自定义镜像</h2><p>常见的镜像在DockerHub就能找到，但是我们自己写的项目就必须自己构建镜像了。</p>
<h3 id="①镜像结构"><a href="#①镜像结构" class="headerlink" title="①镜像结构"></a>①镜像结构</h3><p>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。</p>
<p>我们以MySQL为例，来看看镜像的组成结构：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210731175806273.png" alt="image-20210731175806273" style="zoom:20%;" />



<p>简单来说，镜像就是<strong>在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合</strong>，然后编写好启动脚本打包在一起形成的文件。</p>
<h3 id="②Dockerfile语法"><a href="#②Dockerfile语法" class="headerlink" title="②Dockerfile语法"></a>②Dockerfile语法</h3><p>构建自定义的镜像时，并不需要一个个文件去拷贝，打包。*<u>我们只需要告诉Docker，我们的镜像的组成，需要哪些BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来Docker会帮助我们构建镜像。</u>*</p>
<p>在需要一个名为Dockerfile的文件来构建镜像，<strong>Dockerfile</strong>就是一个文本文件，其中包含一个个的**指令(Instruction)**，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。</p>
<img src="/img/SpringCloudAlibaba.assets/image-20230109192941911.png" alt="image-20230109192941911" style="zoom: 33%;" />

<p>更新详细语法说明，请参考官网文档： <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder">https://docs.docker.com/engine/reference/builder</a></p>
<p><mark>示例：</mark></p>
<p>Dockerfile文件如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="comment"># 配置环境变量，JDK的安装目录</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_DIR=/usr/local</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝jdk和java项目的包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./jdk8.tar.gz <span class="variable">$JAVA_DIR</span>/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./docker-demo.jar /tmp/app.jar</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装JDK</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> <span class="variable">$JAVA_DIR</span> \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">mv</span> ./jdk1.8.0_144 ./java8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8</span><br><span class="line"><span class="keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8090</span></span><br><span class="line"><span class="comment"># 入口，java项目的启动命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>将项目打成jar包，将其与java8的依赖包、Dockerfile都放到对应目录下，然后执行<code>docker build -t javaweb:1.0 .</code>命令</p>
</blockquote>
<img src="/img/SpringCloudAlibaba.assets/image-20230109205638643.png" alt="image-20230109205638643" style="zoom: 50%;" />



<h3 id="③基于Java8构建镜像"><a href="#③基于Java8构建镜像" class="headerlink" title="③基于Java8构建镜像"></a>③基于Java8构建镜像</h3><p>由上面的Dockerfile文件可以看到，诸如配置安装jdk、配置系统环境变量都是固定的操作，因此我们可以用一个前人已经写好的镜像java:8-alpine在此基础上构建项目：</p>
<p><strong>实现思路如下：</strong></p>
<ul>
<li><p>① 新建一个空的目录，然后在目录中新建一个文件，命名为Dockerfile</p>
</li>
<li><p>② 拷贝课前资料提供的docker-demo.jar到这个目录中</p>
</li>
<li><p>③ 编写Dockerfile文件：</p>
<ul>
<li><p>a ）基于java:8-alpine作为基础镜像</p>
</li>
<li><p>b ）将app.jar拷贝到镜像中</p>
</li>
<li><p>c ）暴露端口</p>
</li>
<li><p>d ）编写入口ENTRYPOINT</p>
<p><strong>内容如下：</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>-alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./app.jar /tmp/app.jar</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8090</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>④ 使用docker build命令构建镜像</p>
</li>
<li><p>⑤ 使用docker run创建容器并运行</p>
</li>
</ul>
<p><mark>总结：</mark></p>
<ol>
<li><p><u><em>Dockerfile的本质是一个文件，通过指令描述镜像的构建过程</em></u></p>
</li>
<li><p><u><em>Dockerfile的第一行必须是FROM，从一个基础镜像来构建</em></u></p>
</li>
<li><p><u><em>基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine</em></u></p>
</li>
</ol>
<hr>
<h2 id="2-4Docker-Compose"><a href="#2-4Docker-Compose" class="headerlink" title="2.4Docker-Compose"></a>2.4Docker-Compose</h2><blockquote>
<p>Docker Compose可以基于Compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！</p>
</blockquote>
<img src="/img/SpringCloudAlibaba.assets/image-20210731180921742.png" alt="image-20210731180921742" style="zoom:33%;" />

<p>Compose 使用的三个步骤：</p>
<ul>
<li>使用 Dockerfile 定义应用程序的环境。</li>
<li>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</li>
<li>最后，执行 docker-compose up 命令来启动并运行整个应用程序。</li>
</ul>
<h3 id="①docker-compose-yml"><a href="#①docker-compose-yml" class="headerlink" title="①docker-compose.yml"></a>①docker-compose.yml</h3><p>Compose文件是一个文本文件，通过指令定义集群中的每个容器如何运行。示例如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"> <span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="string">image:</span> <span class="string">mysql:5.7.25</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">     <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span> </span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">     <span class="string">-</span> <span class="string">&quot;/tmp/mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">     <span class="string">-</span> <span class="string">&quot;/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf&quot;</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="string">build:</span> <span class="string">.</span>		<span class="comment">#.号表示当前路径</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&quot;8090:8090&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的Compose文件就描述一个项目，其中包含两个容器：</p>
<ul>
<li>mysql：一个基于<code>mysql:5.7.25</code>镜像构建的容器，并且挂载了两个目录</li>
<li>web：一个基于<code>docker build</code>（主要靠当前路径下的Dockerfile文件）临时构建的镜像容器，映射端口时8090</li>
</ul>
<p>DockerCompose的详细语法参考官网：<a target="_blank" rel="noopener" href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a></p>
<p>其实DockerCompose文件可以看做是将多个docker run命令写到一个文件，只是语法稍有差异。</p>
<h3 id="②示例：将cloud-demo项目部署微服务集群"><a href="#②示例：将cloud-demo项目部署微服务集群" class="headerlink" title="②示例：将cloud-demo项目部署微服务集群"></a>②示例：将cloud-demo项目部署微服务集群</h3><p><strong>(1)docker-compose文件</strong></p>
<p>内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nacos/nacos-server</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MODE:</span> <span class="string">standalone</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8848:8848&quot;</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7.25</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;$PWD/mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;$PWD/mysql/conf:/etc/mysql/conf.d/&quot;</span></span><br><span class="line">  <span class="attr">userservice:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./user-service</span></span><br><span class="line">  <span class="attr">orderservice:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./order-service</span></span><br><span class="line">  <span class="attr">gateway:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./gateway</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;10010:10010&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，其中包含5个service服务：</p>
<ul>
<li><p><code>nacos</code>：作为注册中心和配置中心</p>
<ul>
<li><code>image: nacos/nacos-server</code>： 基于nacos&#x2F;nacos-server镜像构建</li>
<li><code>environment</code>：环境变量<ul>
<li><code>MODE: standalone</code>：单点模式启动</li>
</ul>
</li>
<li><code>ports</code>：端口映射，这里暴露了8848端口</li>
</ul>
</li>
<li><p><code>mysql</code>：数据库</p>
<ul>
<li><code>image: mysql:5.7.25</code>：镜像版本是mysql:5.7.25</li>
<li><code>environment</code>：环境变量<ul>
<li><code>MYSQL_ROOT_PASSWORD: 123</code>：设置数据库root账户的密码为123</li>
</ul>
</li>
<li><code>volumes</code>：数据卷挂载，这里挂载了mysql的data、conf目录，其中有我提前准备好的数据。其中$PWD环境变量代表当前路径。</li>
</ul>
<img src="/img/SpringCloudAlibaba.assets/image-20230109203910538.png" alt="image-20230109203910538" style="zoom:25%;" />
</li>
<li><p><code>userservice</code>、<code>orderservice</code>、<code>gateway</code>：都是基于Dockerfile临时构建的</p>
</li>
</ul>
<hr>
<p><strong>（2）Dockerfile文件：</strong></p>
<p><mark>每个微服务都要写自己的Dockerfile文件</mark></p>
<img src="/img/SpringCloudAlibaba.assets/image-20230109204026723.png" alt="image-20230109204026723" style="zoom:25%;" />

<p>基本内容如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>-alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./app.jar /tmp/app.jar		<span class="comment">#每个微服务项目打包的jar包名叫app.jar</span></span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>(3)修改服务配置：</strong></p>
<p>因为微服务将来要部署为docker容器，**<u>而容器之间互联不是通过IP地址，而是通过容器名</u>**。这里我们将order-service、user-service、gateway服务的mysql、nacos地址都修改为基于容器名的访问。</p>
<p>如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://mysql:3306/cloud_order?useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">orderservice</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">nacos:8848</span> <span class="comment"># nacos服务地址</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>（4）打包：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 服务打包的最终名称 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>app<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--springboot项目的打包插件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>将每个微服务都打成jar包，分别与自己服务的Dockerfile文件放在一个目录下，分开命名为自己的服务名称，像下面这样。</p>
<img src="/img/SpringCloudAlibaba.assets/image-20230109205051945.png" alt="image-20230109205051945" style="zoom: 50%;" />

<hr>
<p><strong>（5）部署：</strong></p>
<p>最后，我们需要将文件整个cloud-demo文件夹上传到虚拟机中，由DockerCompose部署。</p>
<p>上传到任意目录：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210801100955653.png" alt="image-20210801100955653" style="zoom: 33%;" />

<p>进入cloud-demo目录（也就是有docker-compose.yml文件与各个微服务目录的目录），然后运行下面的命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br><span class="line"><span class="comment">#-d表示后台运行</span></span><br></pre></td></tr></table></figure>

<p><mark>执行dockercompose命令后，会自动通过我们设置的Dockerfile构建镜像并生成运行容器，完成部署。</mark></p>
<hr>
<h2 id="2-5Docker镜像仓库"><a href="#2-5Docker镜像仓库" class="headerlink" title="2.5Docker镜像仓库"></a>2.5Docker镜像仓库</h2><h3 id="①搭建私有镜像仓库"><a href="#①搭建私有镜像仓库" class="headerlink" title="①搭建私有镜像仓库"></a>①搭建私有镜像仓库</h3><p>详见老师给的docker安装.md文件</p>
<h3 id="②推送、拉取镜像"><a href="#②推送、拉取镜像" class="headerlink" title="②推送、拉取镜像"></a>②推送、拉取镜像</h3><p>推送镜像到私有镜像服务必须先tag，步骤如下：</p>
<p>① 重新tag本地镜像，<strong>名称前缀为私有仓库的地址</strong>：192.168.238.100:8080&#x2F;</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag nginx:latest 192.168.238.100:8080/nginx:1.0 </span><br></pre></td></tr></table></figure>

<p><em><u><code>docker tag</code>命令：给本地镜像重命名（是重命名并新建一个文件，并不会替换原文件）</u></em></p>
<p>② 推送镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 192.168.238.100:8080/nginx:1.0 </span><br></pre></td></tr></table></figure>



<p>③ 拉取镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 192.168.238.100:8080/nginx:1.0 </span><br></pre></td></tr></table></figure>

<hr>
<h1 id="3-消息队列RabbitMQ"><a href="#3-消息队列RabbitMQ" class="headerlink" title="3.消息队列RabbitMQ"></a>3.消息队列RabbitMQ</h1><h2 id="3-1认识MQ"><a href="#3-1认识MQ" class="headerlink" title="3.1认识MQ"></a>3.1认识MQ</h2><blockquote>
<p><strong><mark>同步与异步：</mark></strong></p>
<ul>
<li><p><strong>同步</strong>（synchronized）：同步是指一个线程程在执行某个请求的时候，如果该请求需要一段时间处理后才能返回信息，那么这个线程会一直等待下去，直到处理完成收到返回信息才会继续执行后面的操作。</p>
</li>
<li><p><strong>异步</strong>（Asynchronous）：异步是指线程不需要执行请求后不需要等待处理结果，而是直接继续执行下面的操作，不管其他进程的状态，处理请求是异步线程进行处理的。我们不许要等待处理完成，而是将它交给异步线程处理，完了我们直接执行后面的操作即可。</p>
</li>
</ul>
</blockquote>
<h3 id="①同步通讯与异步通讯"><a href="#①同步通讯与异步通讯" class="headerlink" title="①同步通讯与异步通讯"></a>①同步通讯与异步通讯</h3><p>微服务间通讯有同步和异步两种方式：</p>
<p>同步通讯：就像打电话，需要实时响应。</p>
<p>异步通讯：就像发邮件，不需要马上回复。</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210717161939695.png" alt="image-20210717161939695" style="zoom: 33%;" />

<p>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。</p>
<hr>
<h3 id="②同步通讯"><a href="#②同步通讯" class="headerlink" title="②同步通讯"></a>②同步通讯</h3><p>我们之前学习的Feign调用就属于同步方式，虽然调用可以实时得到结果，但存在下面的问题：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210717162004285.png" alt="image-20210717162004285" style="zoom:40%;" />



<p>总结：</p>
<p>同步调用的优点：</p>
<ul>
<li>时效性较强，可以立即得到结果</li>
</ul>
<p>同步调用的缺点：</p>
<ul>
<li>耦合度高</li>
<li>性能和吞吐能力下降</li>
<li>有额外的资源消耗</li>
<li>有级联失败问题</li>
</ul>
<hr>
<h3 id="③异步通讯"><a href="#③异步通讯" class="headerlink" title="③异步通讯"></a>③异步通讯</h3><p>异步调用则可以避免上述问题：</p>
<p>我们以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。</p>
<p>在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单id。</p>
<p>订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。</p>
<p>为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。<u><em>发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。</em></u></p>
<p><img src="/img/SpringCloudAlibaba.assets/image-20210422095356088.png" alt="image-20210422095356088"></p>
<p><mark>优点：</mark></p>
<ul>
<li><p>吞吐量提升：无需等待订阅者处理完成，响应更快速</p>
</li>
<li><p>故障隔离：服务没有直接调用，不存在级联失败问题</p>
</li>
<li><p>调用间没有阻塞，不会造成无效的资源占用</p>
</li>
<li><p>耦合度极低，每个服务都可以灵活插拔，可替换</p>
</li>
<li><p>流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件</p>
</li>
</ul>
<p><mark>缺点：</mark></p>
<ul>
<li>架构复杂了，业务没有明显的流程线，不好管理</li>
<li>需要依赖于Broker的可靠、安全、性能</li>
</ul>
<p>好在现在开源软件或云平台上 Broker 的软件是非常成熟的，比较常见的一种就是我们今天要学习的MQ技术。</p>
<hr>
<h3 id="④技术对比"><a href="#④技术对比" class="headerlink" title="④技术对比"></a>④技术对比</h3><p>MQ，中文是消息队列（MessageQueue），字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。</p>
<p>比较常见的MQ实现：</p>
<ul>
<li>ActiveMQ</li>
<li>RabbitMQ</li>
<li>RocketMQ</li>
<li>Kafka</li>
</ul>
<p>几种常见MQ的对比：</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>RabbitMQ</strong></th>
<th><strong>ActiveMQ</strong></th>
<th><strong>RocketMQ</strong></th>
<th><strong>Kafka</strong></th>
</tr>
</thead>
<tbody><tr>
<td>公司&#x2F;社区</td>
<td>Rabbit</td>
<td>Apache</td>
<td>阿里</td>
<td>Apache</td>
</tr>
<tr>
<td>开发语言</td>
<td>Erlang</td>
<td>Java</td>
<td>Java</td>
<td>Scala&amp;Java</td>
</tr>
<tr>
<td>协议支持</td>
<td>AMQP，XMPP，SMTP，STOMP</td>
<td>OpenWire,STOMP，REST,XMPP,AMQP</td>
<td>自定义协议</td>
<td>自定义协议</td>
</tr>
<tr>
<td>可用性</td>
<td>高</td>
<td>一般</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>单机吞吐量</td>
<td>一般</td>
<td>差</td>
<td>高</td>
<td>非常高</td>
</tr>
<tr>
<td>消息延迟</td>
<td>微秒级</td>
<td>毫秒级</td>
<td>毫秒级</td>
<td>毫秒以内</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>高</td>
<td>一般</td>
<td>高</td>
<td>一般</td>
</tr>
</tbody></table>
<p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p>
<p>追求可靠性：RabbitMQ、RocketMQ</p>
<p>追求吞吐能力：RocketMQ、Kafka</p>
<p>追求消息低延迟：RabbitMQ、Kafka</p>
<hr>
<h2 id="3-2原生RabbitMQ"><a href="#3-2原生RabbitMQ" class="headerlink" title="3.2原生RabbitMQ"></a>3.2原生RabbitMQ</h2><h3 id="①RabbitMQ的基本结构"><a href="#①RabbitMQ的基本结构" class="headerlink" title="①RabbitMQ的基本结构"></a>①RabbitMQ的基本结构</h3><img src="/img/SpringCloudAlibaba.assets/image-20230110151910271.png" alt="image-20230110151910271" style="zoom: 50%;" />

<p>RabbitMQ中的一些角色：</p>
<ul>
<li>publisher：生产者</li>
<li>consumer：消费者</li>
<li>exchange个：交换机，负责消息路由</li>
<li>queue：队列，存储消息</li>
<li>virtualHost：虚拟主机，隔离不同租户的exchange、queue、消息的隔离</li>
</ul>
<hr>
<h3 id="②RabbitMQ的消息模型"><a href="#②RabbitMQ的消息模型" class="headerlink" title="②RabbitMQ的消息模型"></a>②RabbitMQ的消息模型</h3><p>RabbitMQ官方提供了5个不同的Demo示例，对应了不同的消息模型：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20230110152315536.png" alt="image-20230110152315536" style="zoom: 40%;" />

<hr>
<h3 id="③原生RabbitMQ的Java代码——基本消息队列"><a href="#③原生RabbitMQ的Java代码——基本消息队列" class="headerlink" title="③原生RabbitMQ的Java代码——基本消息队列"></a>③原生RabbitMQ的Java代码——基本消息队列</h3><blockquote>
<p>下面是基本消息队列用RabbitMQ的原生实现方式，仅做了解</p>
</blockquote>
<p>基本队列模式的模型图：</p>
 <img src="/img/SpringCloudAlibaba.assets/image-20210717163434647.png" alt="image-20210717163434647" style="zoom:50%;" />

<p>官方的HelloWorld是基于最基础的消息队列模型来实现的，只包括三个角色：</p>
<ul>
<li>publisher：消息发布者，将消息发送到队列queue</li>
<li>queue：消息队列，负责接受并缓存消息</li>
<li>consumer：订阅队列，处理队列中的消息</li>
</ul>
<hr>
<h2 id="3-3SpringAMQP"><a href="#3-3SpringAMQP" class="headerlink" title="3.3SpringAMQP"></a>3.3SpringAMQP</h2><p>SpringAMQP是<strong>基于RabbitMQ封装的一消息队列模板</strong>，并且还利用SpringBoot对其实现了自动装配，使用起来非常方便。</p>
<p>SpringAMQP的官方地址：<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-amqp">https://spring.io/projects/spring-amqp</a></p>
<p><img src="/img/SpringCloudAlibaba.assets/image-20230110153214309.png" alt="image-20230110153214309"></p>
<p>SpringAMQP提供了三个功能：</p>
<ul>
<li>自动声明队列、交换机及其绑定关系</li>
<li>基于注解的监听器模式，异步接收消息</li>
<li>封装了RabbitTemplate工具，用于发送消息</li>
</ul>
<h3 id="①BasicQueue简单队列模型"><a href="#①BasicQueue简单队列模型" class="headerlink" title="①BasicQueue简单队列模型"></a>①BasicQueue简单队列模型</h3><blockquote>
<ul>
<li>也称为点对点（Point-to-Point）模型。</li>
<li>消息被发送到队列，只有一个消费者可以接收和处理消息。</li>
<li>当消费者接收并确认消息后，消息从队列中删除。</li>
<li>适用于一对一的通信。</li>
</ul>
</blockquote>
<p><mark>使用步骤：</mark></p>
<p><em><u>引入依赖和配置文件配置MQ操作与上面一致，下面介绍的队列模型都不再赘述</u></em></p>
<p><strong>（1）引入依赖</strong></p>
<p>在父工程mq-demo中引入依赖（发送消息跟接受消息的服务就无需再引入）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）在application.yml中配置MQ</strong></p>
<p>首先配置MQ地址，分别在publisher和consumer服务的application.yml中添加配置：</p>
<p>​	<mark>若发送消息跟接受消息分别是两个服务，则两个服务的配置文件都要配置</mark></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.238</span><span class="number">.100</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">PCH1774943099</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure>

<p><strong>(3)消息发送</strong></p>
<blockquote>
<p>编写springboot测试类，自动装配RabbitTemplate对象并实现消息发送：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span>		<span class="comment">//自动装配RabbitTemplate对象</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSimpleQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        <span class="comment">// 消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, spring amqp!&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(4)消息接收</strong></p>
<p>在consumer服务的路径下创建一个类，其中的方法用<code>@RabbitListener</code>修饰，表示用于接收消息的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringRabbitListener</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span>	<span class="comment">//queues属性设置队列名称</span></span><br><span class="line">    		<span class="comment">//方法形参接受消息，类型已自动处理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（5）测试</strong></p>
<p>启动consumer服务，执行发送消息的test方法，看控制台是否打印出该消息。</p>
<hr>
<h3 id="②WorkQueue"><a href="#②WorkQueue" class="headerlink" title="②WorkQueue"></a>②WorkQueue</h3><p>Work queues，也被称为（Task queues），任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。</p>
<p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。</p>
<p>此时就可以*<u>使用work 模型，多个消费者共同处理消息处理，速度就能大大提高了。</u>*</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210717164238910.png" alt="image-20210717164238910" style="zoom: 50%;" />

<blockquote>
<p>引入依赖和配置文件配置MQ操作与上面一致，下面介绍的队列模型都不再赘述</p>
</blockquote>
<p><strong>（1）消息发送</strong></p>
<p>发送消息与上面的BasicQueue一致</p>
<p><strong>（2）消息接受</strong></p>
<p>可用<code>@RabbitListener</code>新建多个消息接受方法（多个消费者），<code>queue</code>属性都设置为一个队列名称</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue1</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">20</span>);		<span class="comment">//利用线程休眠来模拟两个consumer处理消息能力不一致</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue2</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;消费者2........接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）测试</strong></p>
<p>当我们利用<code>Thread.sleep()</code>方法来模拟处理消息速度的差异时，我们会发现这两个消费者他们并不是谁处理的快，谁就处理的多，而是消息被均分成了两份，两个消费者各自出来。为什么会导致这种情况，这就要提到rabbitMQ的<strong>消息预取机制</strong>。</p>
<p>​		rabbitMQ内部有消息预取机制（<mark>消息会按照消费者数量均分，两个消费者在未处理之前各自预取</mark>），比如有两个消费队列，共同去消费50条消息，即便这两台机器有差异，也会因为消息预取机制，每台机器去抢25条消息，从而影响整体效率。</p>
<p>​		要解决可以*<u>在配置中限制消息预取的数量，原来默认是没有上限，现在可以限制为1，即每次处理完当前的消息之后再去队列中获取新的消息。</u>*</p>
<blockquote>
<p>在消费者服务的application.yml文件中配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment">#每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure>

</blockquote>
<hr>
<hr>
<blockquote>
<p><mark>发布订阅模型概述：</mark></p>
<p>发布订阅的模型如图：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210717165309625.png" alt="image-20210717165309625" style="zoom:40%;" />



<p>可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化：</p>
<ul>
<li>Publisher：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</li>
<li>Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型：<ul>
<li>Fanout：广播，将消息交给所有绑定到交换机的队列</li>
<li>Direct：定向，把消息交给符合指定routing key 的队列</li>
<li>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</li>
</ul>
</li>
<li>Consumer：消费者，与以前一样，订阅队列，没有变化</li>
<li>Queue：消息队列也与以前一样，接收消息、缓存消息。</li>
</ul>
<p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p>
</blockquote>
<p>下面将介绍的Fanout、Direct、Topic就是根据转化机类型分的三中发布订阅模型</p>
<hr>
<h3 id="③Fanout"><a href="#③Fanout" class="headerlink" title="③Fanout"></a>③Fanout</h3><p>Fanout，英文翻译是扇出，我觉得在MQ中叫广播更合适。</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210717165438225.png" alt="image-20210717165438225" style="zoom: 45%;" />

<p>在广播模式下，消息发送流程是这样的：</p>
<ul>
<li>1）  可以有多个队列</li>
<li>2）  每个队列都要绑定到Exchange（交换机）</li>
<li>3）  <strong>生产者发送的消息，只能先发送到交换机</strong>，交换机来决定要发给哪个队列，生产者无法决定</li>
<li>4）  交换机把消息发送给绑定过的所有队列</li>
<li>5）  订阅队列的消费者都能拿到消息(当然一个队列也可以有多消费者)</li>
</ul>
<p><strong>（1）声明队列和交换机并进行绑定</strong></p>
<p>Spring提供了一个接口Exchange，来表示所有不同类型的交换机：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210717165552676.png" alt="image-20210717165552676" style="zoom:60%;" />

<p><mark>基于注册Bean的方式声明队列和交换机：（还有基于注解的方式，下面会讲到）</mark></p>
<p>在consumer服务中创建配置类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Fanout类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;itcast.fanout&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第1个队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">//绑定队列1和交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1</span><span class="params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第2个队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定队列2和交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2</span><span class="params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）消息发送</strong></p>
<p>在publisher服务的SpringAmqpTest类中添加测试方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFanoutExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;itcast.fanout&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, everyone!&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;&quot;</span>, message);	<span class="comment">//中间的routeKey参数这个模型中用不到，设置为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）消息接受</strong></p>
<p>在consumer服务的SpringRabbitListener中添加两个方法，作为消费者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><mark>总结：</mark></p>
<p><u><em>交换机的作用是什么？</em></u></p>
<ul>
<li>接收publisher发送的消息</li>
<li>将消息按照规则路由到与之绑定的队列</li>
<li>不能缓存消息，路由失败，消息丢失</li>
<li>FanoutExchange的会将消息路由到每个绑定的队列</li>
</ul>
<p><u><em>声明队列、交换机、绑定关系的Bean是什么？</em></u></p>
<ul>
<li>Queue</li>
<li>FanoutExchange</li>
<li>Binding</li>
</ul>
<hr>
<h3 id="④Direct"><a href="#④Direct" class="headerlink" title="④Direct"></a>④Direct</h3><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210717170041447.png" alt="image-20210717170041447" style="zoom:50%;" />

<p> 在Direct模型下：</p>
<ul>
<li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li>
<li>消息的发送方在向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li>
<li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列与交换机绑定的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li>
</ul>
<p><strong>（1）消息发送</strong></p>
<p>在publisher服务的SpringAmqpTest类中添加测试方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendDirectExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;itcast.direct&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;red&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）消息接受</strong></p>
<p><mark>基于注解声明队列和交换机并绑定：</mark></p>
<p>在consumer的SpringRabbitListener中添加两个消费者，同时基于<code>@RabbitListener</code>注解的bindings属性来声明队列和交换机并绑定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到direct.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到direct.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><mark>总结：</mark></p>
<p><u><em>描述下Direct交换机与Fanout交换机的差异？</em></u></p>
<ul>
<li>Fanout交换机将消息路由给每一个与之绑定的队列</li>
<li>Direct交换机根据RoutingKey判断路由给哪个队列</li>
<li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li>
</ul>
<p><u><em>基于@RabbitListener注解声明队列和交换机有哪些常见注解？</em></u></p>
<ul>
<li>@Queue</li>
<li>@Exchange</li>
</ul>
<hr>
<h3 id="⑤Topic"><a href="#⑤Topic" class="headerlink" title="⑤Topic"></a>⑤Topic</h3><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！</p>
<p><code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以<code>.</code>分割，例如： <code>item.insert</code></p>
<p> 通配符规则：</p>
<p><strong><code>#</code>：匹配一个或多个任意的词</strong></p>
<p><strong><code>*</code>：匹配1个任意的词</strong></p>
<p>举例：</p>
<p><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code></p>
<p><code>item.*</code>：只能匹配<code>item.spu</code></p>
<p>​     </p>
<p>图示：</p>
 <img src="/img/SpringCloudAlibaba.assets/image-20210717170705380.png" alt="image-20210717170705380" style="zoom:50%;" />

<p>解释：</p>
<ul>
<li>Queue1：绑定的是<code>china.#</code> ，因此凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到。包括china.news和china.weather</li>
<li>Queue2：绑定的是<code>#.news</code> ，因此凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括china.news和japan.news</li>
</ul>
<p><strong>（1）消息发送</strong></p>
<p>在publisher服务的SpringAmqpTest类中添加测试方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendTopicExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;itcast.topic&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;喜报！孙悟空大战哥斯拉，胜!&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;china.news&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）消息接受</strong></p>
<p>在consumer服务的SpringRabbitListener中添加方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;china.#&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到topic.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;#.news&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到topic.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><mark>总结：</mark></p>
<p>描述下Direct交换机与Topic交换机的差异？</p>
<ul>
<li>Topic交换机接收的消息RoutingKey必须是多个单词，以 <code>**.**</code> 分割</li>
<li>Topic交换机与队列绑定时的bindingKey可以指定通配符</li>
<li><code>#</code>：代表0个或多个词</li>
<li><code>*</code>：代表1个词</li>
</ul>
<hr>
<h3 id="⑥消息转换器"><a href="#⑥消息转换器" class="headerlink" title="⑥消息转换器"></a>⑥消息转换器</h3><p>之前说过，Spring会把你发送的消息<strong>序列化为字节发送给MQ</strong>，接收消息的时候，还会把字节<strong>反序列化为Java对象</strong>。</p>
<img src="/img/SpringCloudAlibaba.assets/image-20200525170410401.png" alt="image-20200525170410401" style="zoom:50%;" />

<p>只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p>
<ul>
<li>数据体积过大</li>
<li>有安全漏洞</li>
<li>可读性差</li>
</ul>
<p>我们来测试一下。</p>
<p><strong>（1）测试默认转换器</strong></p>
<p>我们修改消息发送的代码，发送一个Map对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMap</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 准备消息</span></span><br><span class="line">    Map&lt;String,Object&gt; msg = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    msg.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    msg.put(<span class="string">&quot;age&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;simple.queue&quot;</span>,<span class="string">&quot;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>停止consumer服务</p>
<p>发送消息后进入rabbitMQ的管理平台查看控制台：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210422232835363.png" alt="image-20210422232835363" style="zoom:50%;" />

<p><strong>（2）配置Json转换器</strong></p>
<p>显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。</p>
<p>在publisher和consumer两个服务中都引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置消息转换器。</p>
<p>在启动类（或者配置类）中注册一个Bean即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">jsonMessageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话在publisher和consumer服务中无论是消息序列化还是反序列化，都是采用的json形式。</p>
<hr>
<h1 id="4-搜索引擎Elasticsearch"><a href="#4-搜索引擎Elasticsearch" class="headerlink" title="4.搜索引擎Elasticsearch"></a>4.搜索引擎Elasticsearch</h1><h2 id="4-1初识Elasticsearch"><a href="#4-1初识Elasticsearch" class="headerlink" title="4.1初识Elasticsearch"></a>4.1初识Elasticsearch</h2><h3 id="①认识Elasticsearch"><a href="#①认识Elasticsearch" class="headerlink" title="①认识Elasticsearch"></a>①认识Elasticsearch</h3><blockquote>
<p>elasticsearch是一款非常强大的开源搜索引擎，具备非常多强大功能，可以帮助我们从海量数据中快速找到需要的内容</p>
</blockquote>
<p><strong>（1）ELK技术栈</strong></p>
<p>elasticsearch结合kibana、Logstash、Beats，也就是elastic stack（ELK）。被广泛应用在日志数据分析、实时监控等领域。</p>
<p>而elasticsearch是elastic stack的核心，<strong>负责存储、搜索、分析数据</strong>。</p>
<img src="/img/SpringCloudAlibaba.assets/image-20230111190844770.png" alt="image-20230111190844770" style="zoom: 33%;" />

<p><strong>（2）elasticsearch和lucene</strong></p>
<p>elasticsearch底层是基于<strong>lucene</strong>来实现的。</p>
<p><strong>Lucene</strong>是一个Java语言的搜索引擎类库，是Apache公司的顶级项目，由DougCutting于1999年研发。官网地址：<a target="_blank" rel="noopener" href="https://lucene.apache.org/">https://lucene.apache.org/</a> 。</p>
<p><strong>elasticsearch</strong>的发展历史：</p>
<ul>
<li>2004年Shay Banon基于Lucene开发了Compass</li>
<li>2010年Shay Banon 重写了Compass，取名为Elasticsearch。</li>
</ul>
<p>目前比较知名的搜索引擎技术排名：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210720195142535.png" alt="image-20210720195142535" style="zoom:50%;" />

<p>虽然在早期，Apache Solr是最主要的搜索引擎技术，但随着发展elasticsearch已经渐渐超越了Solr，独占鳌头。</p>
<p><mark>总结：</mark></p>
<p><em><u>什么是elasticsearch？</u></em></p>
<ul>
<li>一个开源的分布式搜索引擎，可以用来实现搜索、日志统计、分析、系统监控等功能</li>
</ul>
<p><u><em>什么是elastic stack（ELK）？</em></u></p>
<ul>
<li>是以elasticsearch为核心的技术栈，包括beats、Logstash、kibana、elasticsearch</li>
</ul>
<p><em><u>什么是Lucene？</u></em></p>
<ul>
<li>是Apache的开源搜索引擎类库，提供了搜索引擎的核心API</li>
</ul>
<hr>
<h3 id="②倒排索引"><a href="#②倒排索引" class="headerlink" title="②倒排索引"></a>②倒排索引</h3><blockquote>
<p>倒排索引的概念是基于MySQL这样的正向索引而言的。</p>
</blockquote>
<p><strong>（1）正向索引</strong></p>
<img src="/img/SpringCloudAlibaba.assets/image-20230111191615806.png" alt="image-20230111191615806" style="zoom:50%;" />

<p>如图所示的这样一张表，如果根据id进行查询（走索引），那么数据库查询效率将非常的快。</p>
<p>但如果是根据title进行模糊匹配查询，那么数据库只能逐行扫描，每一行数据都去根据条件匹配，效率则是非常的差。</p>
<p><em><u>逐行扫描，也就是全表扫描，随着数据量增加，其查询效率也会越来越低。当数据量达到数百万时，就是一场灾难。</u></em></p>
<p><strong>（2）倒排索引</strong></p>
<p>倒排索引中有两个非常重要的概念：</p>
<ul>
<li><mark>文档</mark>（<code>Document</code>）：用来搜索的数据，其中的每一条数据就是一个文档。例如一个网页、一个商品信息</li>
<li><mark>词条</mark>（<code>Term</code>）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条</li>
</ul>
<img src="/img/SpringCloudAlibaba.assets/image-20230111194824243.png" alt="image-20230111194824243" style="zoom:25%;" />

<p><strong>创建倒排索引</strong>是对正向索引的一种特殊处理，流程如下：</p>
<ul>
<li>将每一个文档的数据利用算法分词，得到一个个词条</li>
<li>创建表，每行数据包括词条、词条所在文档id、位置等信息</li>
<li>因为词条唯一性，可以给词条创建索引，例如hash表结构索引</li>
</ul>
<p>如图：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210720200457207.png" alt="image-20210720200457207" style="zoom:50%;" />

<p>倒排索引的<strong>搜索流程</strong>如下（以搜索”华为手机”为例）：</p>
<p>1）用户输入条件<code>&quot;华为手机&quot;</code>进行搜索。</p>
<p>2）对用户输入内容<strong>分词</strong>，得到词条：<code>华为</code>、<code>手机</code>。</p>
<p>3）拿着词条在倒排索引中查找，可以得到包含词条的文档id：1、2、3。</p>
<p>4）拿着文档id到正向索引中查找具体文档。</p>
<p>如图：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210720201115192.png" alt="image-20210720201115192" style="zoom:50%;" />



<p>虽然要先查询倒排索引，再查询正向索引，但是无论是词条、还是文档id都建立了索引，查询速度非常快！无需全表扫描。</p>
<p><strong>（3）正向和倒排</strong></p>
<ul>
<li><p><strong>正向索引</strong>是最传统的，根据id索引的方式。但根据词条查询时，必须先逐条获取每个文档，然后判断文档中是否包含所需要的词条，是<strong>根据文档找词条的过程</strong>。</p>
</li>
<li><p>而<strong>倒排索引</strong>则相反，是先找到用户要搜索的词条，根据词条得到保护词条的文档的id，然后根据id获取文档。是<strong>根据词条找文档的过程</strong>。</p>
</li>
</ul>
<p><mark>两者方式的优缺点</mark></p>
<p><strong>正向索引</strong>：</p>
<ul>
<li>优点：<ul>
<li>可以给多个字段创建索引</li>
<li>根据索引字段搜索、排序速度非常快</li>
</ul>
</li>
<li>缺点：<ul>
<li>根据非索引字段，或者索引字段中的部分词条查找时，只能全表扫描。</li>
</ul>
</li>
</ul>
<p><strong>倒排索引</strong>：</p>
<ul>
<li>优点：<ul>
<li>根据词条搜索、模糊搜索时，速度非常快</li>
</ul>
</li>
<li>缺点：<ul>
<li>只能给词条创建索引，而不是字段</li>
<li>无法根据字段做排序</li>
</ul>
</li>
</ul>
<hr>
<h3 id="③ES中的一些概念"><a href="#③ES中的一些概念" class="headerlink" title="③ES中的一些概念"></a>③ES中的一些概念</h3><p><strong>（1）文档</strong></p>
<p>elasticsearch是面向<strong>文档（Document）</strong>存储的，可以是数据库中的一条商品数据，一个订单信息。文档数据会被序列化为<code>json</code>格式后存储在elasticsearch中：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210720202707797.png" alt="image-20210720202707797" style="zoom: 40%;" />

<p>也就是说，es中一个文档就是数据库表中的一行数据，包含多个字段(column)</p>
<p><strong>(2)索引和映射</strong></p>
<ul>
<li><p><strong>索引（Index）</strong>，就是相同类型的文档的集合。</p>
<p>例如：</p>
<ul>
<li>所有用户文档，就可以组织在一起，称为用户的索引；</li>
<li>所有商品的文档，可以组织在一起，称为商品的索引；</li>
</ul>
<p><u><em>可以把索引当成数据库中的一张表。</em></u></p>
</li>
<li><p><strong>映射（mapping）</strong>，是索引中文档的字段约束信息，类似表的结构约束，定义文档中各个字段的类型等信息。</p>
</li>
</ul>
<hr>
<h3 id="④mysql与es"><a href="#④mysql与es" class="headerlink" title="④mysql与es"></a>④mysql与es</h3><img src="/img/SpringCloudAlibaba.assets/image-20230111195944229.png" alt="image-20230111195944229" style="zoom: 40%;" />

<p>是不是说，我们学习了elasticsearch就不再需要mysql了呢？</p>
<p>并不是如此，两者各自有自己的擅长支出：</p>
<ul>
<li><p>Mysql：擅长事务类型操作，可以确保数据的安全和一致性</p>
</li>
<li><p>Elasticsearch：擅长海量数据的搜索、分析、计算</p>
</li>
</ul>
<p>因此在企业中，往往是两者结合使用：</p>
<ul>
<li><u><em>对安全性要求较高的写操作，使用mysql实现</em></u></li>
<li><u><em>对查询性能要求较高的搜索需求，使用elasticsearch实现</em></u></li>
<li>两者再基于某种方式，实现数据的同步，保证一致性</li>
</ul>
<img src="/img/SpringCloudAlibaba.assets/image-20210720203534945.png" alt="image-20210720203534945" style="zoom:50%;" />

<hr>
<h3 id="⑤安装ES"><a href="#⑤安装ES" class="headerlink" title="⑤安装ES"></a>⑤安装ES</h3><blockquote>
<p>安装kibana的原因是为了使用它的客户端跟方便的写DLS</p>
</blockquote>
<hr>
<h3 id="⑥ES中的分词器"><a href="#⑥ES中的分词器" class="headerlink" title="⑥ES中的分词器"></a>⑥ES中的分词器</h3><p><em><u>分词器的作用是什么？</u></em></p>
<ul>
<li>创建倒排索引时对文档分词</li>
<li>用户搜索时，对输入的内容分词</li>
</ul>
<p><u><em>IK分词器有几种模式？</em></u></p>
<ul>
<li>ik_smart：智能切分，粗粒度</li>
<li>ik_max_word：最细切分，细粒度</li>
</ul>
<p><u><em>IK分词器如何拓展词条？如何停用词条？</em></u></p>
<ul>
<li>利用config目录的IkAnalyzer.cfg.xml文件添加拓展词典和停用词典</li>
<li>在词典中添加拓展词条或者停用词条</li>
</ul>
<img src="/img/SpringCloudAlibaba.assets/image-20230111201258593.png" alt="image-20230111201258593" style="zoom:50%;" />

<hr>
<h2 id="4-2索引库操作"><a href="#4-2索引库操作" class="headerlink" title="4.2索引库操作"></a>4.2索引库操作</h2><blockquote>
<p>索引库就类似数据库表，mapping映射就类似表的结构。在向索引库添加文档前我们需要先创建索引库、用mapping定义字段结构</p>
</blockquote>
<h3 id="①mapping映射属性"><a href="#①mapping映射属性" class="headerlink" title="①mapping映射属性"></a>①mapping映射属性</h3><p>mapping是对索引库中文档的约束，常见的mapping属性包括：</p>
<ul>
<li>type：字段数据类型，常见的简单类型有：<ul>
<li>字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）</li>
<li>数值：long、integer、short、byte、double、float、</li>
<li>布尔：boolean</li>
<li>日期：date</li>
<li>对象：object</li>
</ul>
</li>
<li>index：是否参与搜索，默认为true</li>
<li>analyzer：使用哪种分词器</li>
<li>properties：该字段的子字段</li>
</ul>
<p>地理坐标说明：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210720222110126.png" alt="image-20210720222110126" style="zoom:50%;" />

<p>copy_to说明：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210720222221516.png" alt="image-20210720222221516" style="zoom: 50%;" />

<p>​												<em>copy_to主要应用于需要多字段条件搜索时，看多个字段中是否包含你想搜索的数据</em></p>
<hr>
<h3 id="②索引库的CRUD"><a href="#②索引库的CRUD" class="headerlink" title="②索引库的CRUD"></a>②索引库的CRUD</h3><p><strong>（1）创建索引库和映射</strong></p>
<p>PUT请求，请求参数为mapping映射</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PUT /索引库名称</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;mapping&quot;</span><span class="punctuation">:</span></span><br><span class="line">     <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span></span><br><span class="line">      <span class="attr">&quot;字段1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    	<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="attr">&quot;字段2&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    	 <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">    	 <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="attr">&quot;字段3&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    	  <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    		<span class="attr">&quot;子字段&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                </span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span>······</span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）查询索引库</strong></p>
<p>GET请求，无请求参数，请求路径为<code>/索引库名称</code></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /索引库名称</span><br></pre></td></tr></table></figure>

<p><strong>（3）修改索引库</strong></p>
<p>倒排索引结构虽然不复杂，但是一旦数据结构改变（比如改变了分词器），就需要重新创建倒排索引，这简直是灾难。</p>
<p>因此索引库<strong>一旦创建，无法修改mapping</strong>。</p>
<p>虽然无法修改mapping中已有的字段，但是却*<u>允许添加新的字段到mapping中，因为不会对倒排索引产生影响。</u>*</p>
<p>PUT请求，请求路径为<code>/索引库名/_mapping</code>，请求参数为新字段属性</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT /索引库名/_mapping</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;新字段名&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>（4）删除索引库</strong></p>
<p>DELETE请求，无请求参数，请求路径为<code>/索引库名</code></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /索引库名</span><br></pre></td></tr></table></figure>



<p><mark>总结：</mark></p>
<p><em><u>索引库操作有哪些？</u></em></p>
<ul>
<li>创建索引库：PUT &#x2F;索引库名</li>
<li>查询索引库：GET &#x2F;索引库名</li>
<li>删除索引库：DELETE &#x2F;索引库名</li>
<li>添加字段：PUT &#x2F;索引库名&#x2F;_mapping</li>
</ul>
<hr>
<h2 id="4-3文档操作"><a href="#4-3文档操作" class="headerlink" title="4.3文档操作"></a>4.3文档操作</h2><h3 id="①文档的CRUD"><a href="#①文档的CRUD" class="headerlink" title="①文档的CRUD"></a>①文档的CRUD</h3><p><strong>（1）新增文档</strong></p>
<p>POST请求，请求参数为文档数据，请求路径为<code>/索引库名/_doc/文档id</code></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST /索引库名/_doc/文档id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;字段1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;字段2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;字段3&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;子属性1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值3&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;子属性2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值4&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）查询文档</strong></p>
<p>GET请求，无请求参数，请求路径为<code>/索引库名/_doc/文档id</code></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /<span class="punctuation">&#123;</span>索引库名称<span class="punctuation">&#125;</span>/_doc/<span class="punctuation">&#123;</span>文档id</span><br></pre></td></tr></table></figure>

<p><strong>批量查询：</strong>查询对应索引库所有文档</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /<span class="punctuation">&#123;</span>索引库名称<span class="punctuation">&#125;</span>/_search</span><br></pre></td></tr></table></figure>

<p><strong>（3）删除文档</strong></p>
<p>DELETE请求，无请求参数，请求路径为<code>/&#123;索引库名&#125;/_doc/id值</code></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span>/_doc/<span class="punctuation">&#123;</span>文档id<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>（4）修改文档</strong></p>
<p>修改有两种方式：</p>
<ul>
<li>全量修改：直接覆盖原来的文档</li>
<li>增量修改：修改文档中的部分字段</li>
</ul>
<p><mark>全量修改：</mark></p>
<p>全量修改是覆盖原来的文档，其本质是：</p>
<ul>
<li>根据指定的id删除文档</li>
<li>新增一个相同id的文档</li>
</ul>
<p><strong>注意</strong>：如果根据id删除时，id不存在，第二步的新增也会执行，也就从修改变成了新增操作了。</p>
<p>PUT请求</p>
<p><strong>语法：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span>/_doc/文档id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;字段1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;字段2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><mark>增量修改：</mark></p>
<p>增量修改是只修改指定id匹配的文档中的部分字段。</p>
<p>POST请求</p>
<p><strong>语法：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span>/_update/文档id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span> <span class="string">&quot;新的值&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<p><mark>总结：</mark></p>
<p><em><u>文档操作有哪些？</u></em></p>
<ul>
<li>创建文档：<code>POST /&#123;索引库名&#125;/_doc/文档id   &#123; json文档 &#125;</code></li>
<li>查询文档：<code>GET /&#123;索引库名&#125;/_doc/文档id</code></li>
<li>删除文档：<code>DELETE /&#123;索引库名&#125;/_doc/文档id</code></li>
<li>修改文档：<ul>
<li>全量修改：<code>PUT /&#123;索引库名&#125;/_doc/文档id &#123; json文档 &#125;</code></li>
<li>增量修改：<code>POST /&#123;索引库名&#125;/_update/文档id &#123; &quot;doc&quot;: &#123;字段&#125;&#125;</code></li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-4RestAPI-in-Java"><a href="#4-4RestAPI-in-Java" class="headerlink" title="4.4RestAPI in Java"></a>4.4RestAPI in Java</h2><h3 id="①在Java中使用RestAPI"><a href="#①在Java中使用RestAPI" class="headerlink" title="①在Java中使用RestAPI"></a>①在Java中使用RestAPI</h3><blockquote>
<p>ES官方提供了各种不同语言的客户端，用来操作ES。这些客户端的本质就是组装DSL语句，通过http请求发送给ES。官方文档地址：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">https://www.elastic.co/guide/en/elasticsearch/client/index.html</a></p>
<p>其中的Java Rest Client又包括两种：</p>
<ul>
<li>Java Low Level Rest Client</li>
<li>Java High Level Rest Client</li>
</ul>
</blockquote>
<p><a href="gateway%E7%9A%84module%E4%B8%8D%E8%83%BD%E5%86%8D%E5%8A%A0%E5%85%A5spring-boot-starter-web%E7%9A%84%E4%BE%9D%E8%B5%96">^注意</a>: 我们使用的是Java High Level Rest Client，它相较于前者功能更加完善</p>
<p><mark>使用步骤：</mark></p>
<p><strong>（1）引入es的RestHighLevelClient依赖：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">elasticsearch.version</span>&gt;</span>7.12.1<span class="tag">&lt;/<span class="name">elasticsearch.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）初始化RestHighLevelClient：</strong></p>
<p>指定Ip地址和端口号</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RestHighLevelClient</span> <span class="variable">restClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(</span><br><span class="line">        HttpHost.create(<span class="string">&quot;http://192.168.238.100:9200&quot;</span>)</span><br><span class="line">));</span><br></pre></td></tr></table></figure>

<p><em><u>再利用restClient对象去使用即可。</u></em></p>
<hr>
<h3 id="②RestClient操作索引库"><a href="#②RestClient操作索引库" class="headerlink" title="②RestClient操作索引库"></a>②RestClient操作索引库</h3><p><strong>（1）新建索引库</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createHotelIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    <span class="type">CreateIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备请求的参数：DSL语句</span></span><br><span class="line">    request.source(MAPPING_TEMPLATE, XContentType.JSON);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）删除索引库</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteHotelIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    <span class="type">DeleteIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteIndexRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    client.indices().delete(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）判断索引库是否存在</strong></p>
<blockquote>
<p>判断索引库是否存在，本质就是查询，对应的DSL是：<code>GET /索引库名</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testExistsHotelIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    <span class="type">GetIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetIndexRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> client.indices().exists(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 3.输出</span></span><br><span class="line">    System.err.println(exists ? <span class="string">&quot;索引库已经存在！&quot;</span> : <span class="string">&quot;索引库不存在！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><mark>总结：</mark></p>
<p><em><u>JavaRestClient操作elasticsearch的流程基本类似。核心是client.indices()方法来获取索引库的操作对象。</u></em></p>
<p><em><u>索引库操作的基本步骤：</u></em></p>
<ul>
<li>初始化RestHighLevelClient</li>
<li>创建XxxIndexRequest。XXX是Create、Get、Delete</li>
<li>准备DSL（ Create时需要，其它是无参）</li>
<li>发送请求。调用RestHighLevelClient#indices().xxx()方法，xxx是create、exists、delete</li>
</ul>
<hr>
<h3 id="③RestClient操作文档"><a href="#③RestClient操作文档" class="headerlink" title="③RestClient操作文档"></a>③RestClient操作文档</h3><blockquote>
<p>在案例中，因为在数据库中的存储地理坐标数据类型与es中不一样，因此要为两者分别创建实体类，并通过构造器属性赋值让两者可以相互转换</p>
</blockquote>
<p><strong>（1）新增文档</strong></p>
<p>新增文档用Index</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">newDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//先从数据库中查出数据</span></span><br><span class="line">        <span class="type">Hotel</span> <span class="variable">hotel</span> <span class="operator">=</span> hotelService.getById(<span class="number">38609</span>);</span><br><span class="line">        <span class="comment">//转换成与es中字段对应的实体类</span></span><br><span class="line">        <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HotelDoc</span>(hotel);</span><br><span class="line">        <span class="comment">//转换为json</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> JSON.toJSONString(hotelDoc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建请求对象</span></span><br><span class="line">        <span class="type">IndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;hotel&quot;</span>).id(<span class="string">&quot;38609&quot;</span>);	<span class="comment">//38609为文档id，对应数据库中表里的id</span></span><br><span class="line">        <span class="comment">//2.准备json文档</span></span><br><span class="line">        request.source(str, XContentType.JSON);</span><br><span class="line">        <span class="comment">//3.发送</span></span><br><span class="line">        restClient.index(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）查询文档</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">getDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.新建请求对象</span></span><br><span class="line">        <span class="type">GetRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetRequest</span>(<span class="string">&quot;hotel&quot;</span>,<span class="string">&quot;38609&quot;</span>);	<span class="comment">//38609为文档id，对应数据库中表里的id</span></span><br><span class="line">        <span class="comment">//2.发送请求，得到返回结果</span></span><br><span class="line">        <span class="type">GetResponse</span> <span class="variable">response</span> <span class="operator">=</span> restClient.get(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">//3.获得json类型返回数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> response.getSourceAsString();</span><br><span class="line">        <span class="comment">//4.将json转换为对应实体类</span></span><br><span class="line">        <span class="type">HotelDoc</span> <span class="variable">doc</span> <span class="operator">=</span> JSON.parseObject(json, HotelDoc.class);</span><br><span class="line">        System.out.println(doc);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）删除文档</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deleteDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.新建请求对象</span></span><br><span class="line">    <span class="type">DeleteRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteRequest</span>(<span class="string">&quot;hotel&quot;</span>, <span class="string">&quot;38609&quot;</span>);	<span class="comment">//38609为文档id，对应数据库中表里的id</span></span><br><span class="line">    <span class="comment">//2.发送请求</span></span><br><span class="line">    restClient.delete(request,RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（4）修改文档</strong></p>
<p>修改我们讲过两种方式：</p>
<ul>
<li>全量修改：本质是先根据id删除，再新增</li>
<li>增量修改：修改文档中的指定字段值</li>
</ul>
<p><em><u>这里我们主要讲增量修改，全量修改用新增文档的方式即可</u></em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">updateDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.新建请求对象</span></span><br><span class="line">    <span class="type">UpdateRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateRequest</span>(<span class="string">&quot;hotel&quot;</span>, <span class="string">&quot;38609&quot;</span>);	<span class="comment">//38609为文档id，对应数据库中表里的id</span></span><br><span class="line">    <span class="comment">//2.准备请求参数,这里是局部修改文档</span></span><br><span class="line">    request.doc(</span><br><span class="line">            <span class="string">&quot;price&quot;</span>,<span class="number">100</span>,</span><br><span class="line">            <span class="string">&quot;star_name&quot;</span>,<span class="string">&quot;四星&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//3.发送请求</span></span><br><span class="line">    restClient.update(request,RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（5）批量添加文档</strong></p>
<p>批量处理使用BulkRequest请求对象，其本质就是将多个普通的CRUD请求组合在一起发送。</p>
<p>其中提供了一个add方法，用来添加其他请求：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210720232105943.png" alt="image-20210720232105943" style="zoom: 50%;" />

<p>可以看到，能添加的请求包括：</p>
<ul>
<li>IndexRequest，也就是新增</li>
<li>UpdateRequest，也就是修改</li>
<li>DeleteRequest，也就是删除</li>
</ul>
<p><mark>因此BulkRequest对象不但可以批量添加，还可以批量修改可批量删除</mark></p>
<p>我们想要批量添加，则用<code>BulkRequest</code>对象多次调用add方法即可：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20230112103702069.png" alt="image-20230112103702069" style="zoom: 50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBulkRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 批量查询酒店数据</span></span><br><span class="line">    List&lt;Hotel&gt; hotels = hotelService.list();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">BulkRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BulkRequest</span>();</span><br><span class="line">    <span class="comment">// 2.准备参数，添加多个新增的Request</span></span><br><span class="line">    <span class="keyword">for</span> (Hotel hotel : hotels) &#123;</span><br><span class="line">        <span class="comment">// 2.1.转换为文档类型HotelDoc</span></span><br><span class="line">        <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HotelDoc</span>(hotel);</span><br><span class="line">        <span class="comment">// 2.2.创建新增文档的Request对象</span></span><br><span class="line">        request.add(<span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;hotel&quot;</span>)</span><br><span class="line">                    .id(hotelDoc.getId().toString())</span><br><span class="line">                    .source(JSON.toJSONString(hotelDoc), XContentType.JSON));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.bulk(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><mark>总结：</mark></p>
<p><em><u>文档操作的基本步骤：</u></em></p>
<ul>
<li>初始化RestHighLevelClient</li>
<li>创建XxxRequest。XXX是Index、Get、Update、Delete、Bulk</li>
<li>准备参数（Index、Update、Bulk时需要）</li>
<li>发送请求。调用RestHighLevelClient#.xxx()方法，xxx是index、get、update、delete、bulk</li>
<li>解析结果（Get时需要）</li>
</ul>
<hr>
<h2 id="4-5DSL查询文档"><a href="#4-5DSL查询文档" class="headerlink" title="4.5DSL查询文档"></a>4.5DSL查询文档</h2><blockquote>
<p>elasticsearch的查询依然是基于JSON风格的DSL来实现的。</p>
</blockquote>
<h3 id="①DSL查询分类"><a href="#①DSL查询分类" class="headerlink" title="①DSL查询分类"></a>①DSL查询分类</h3><p>Elasticsearch提供了基于JSON的DSL（<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html">Domain Specific Language</a>）来定义查询。常见的查询类型包括：</p>
<ul>
<li><p><strong>查询所有</strong>：查询出所有数据，一般测试用。例如：match_all</p>
</li>
<li><p><strong>全文检索（full text）查询</strong>：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如：</p>
<ul>
<li>match_query</li>
<li>multi_match_query</li>
</ul>
</li>
<li><p><strong>精确查询</strong>：根据精确词条值查找数据，一般是查找keyword、数值、日期、boolean等类型字段。例如：</p>
<ul>
<li>ids</li>
<li>range</li>
<li>term</li>
</ul>
</li>
<li><p><strong>地理（geo）查询</strong>：根据经纬度查询。例如：</p>
<ul>
<li>geo_distance</li>
<li>geo_bounding_box</li>
</ul>
</li>
<li><p><strong>复合（compound）查询</strong>：复合查询可以将上述各种查询条件组合起来，合并查询条件。例如：</p>
<ul>
<li>bool</li>
<li>function_score</li>
</ul>
</li>
</ul>
<p>查询的语法基本一致：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;查询类型&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;查询条件&quot;</span><span class="punctuation">:</span> <span class="string">&quot;条件值&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="②全文检索查询"><a href="#②全文检索查询" class="headerlink" title="②全文检索查询"></a>②全文检索查询</h3><p>全文检索查询的基本流程如下：</p>
<ul>
<li><strong>对用户搜索的内容做分词，得到词条</strong></li>
<li>根据词条去倒排索引库中匹配，得到文档id</li>
<li>根据文档id找到文档，返回给用户（*<u>查询出的都是整条文档，并不是像数据库那样可以查询指定字段</u>*）</li>
</ul>
<p><strong>（1）查询所有</strong></p>
<ul>
<li>查询类型为<code>match_all</code></li>
<li>没有查询条件</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有</span></span><br><span class="line">GET /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span>/_search			<span class="comment">//只要这一句也可以查询所有</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><em><u>虽然是查询所有，但不会把所有数据都列出来，会有一个分页的功能，默认只返回10条数据。</u></em></p>
<p><strong>（2）单字段查询</strong></p>
<ul>
<li>查询类型为<code>match</code></li>
<li>查询条件为要查询字段，及其词条</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span>/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="string">&quot;TEXT&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>（3）多字段查询</strong></p>
<blockquote>
<p>多字段查询，任意一个字段符合词条就算符合查询条件</p>
</blockquote>
<ul>
<li><p>查询类型为<code>multi_match</code></p>
</li>
<li><p>查询条件<code>query</code>中放入要搜索的词条，<code>fields</code>数组中放入多个字段名</p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span>/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;multi_match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;TEXT&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;FIELD1&quot;</span><span class="punctuation">,</span> <span class="string">&quot; FIELD12&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="③精准查询"><a href="#③精准查询" class="headerlink" title="③精准查询"></a>③精准查询</h3><blockquote>
<p>精确查询一般是查找keyword、数值、日期、boolean等类型字段。所以<strong>不会对搜索条件分词</strong>。常见的有：</p>
<ul>
<li>term：根据词条精确值查询</li>
<li>range：根据值的范围查询</li>
</ul>
</blockquote>
<p><strong>（1）term查询</strong></p>
<blockquote>
<p>根据词条精准查询，不会对词条分词</p>
</blockquote>
<ul>
<li>查询类型为<code>term</code></li>
<li>查询条件<code>FIELD</code>为要查询的字段，<code>VALUE</code>中设置要查询的词条</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// term查询</span></span><br><span class="line">GET /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span>/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;VALUE&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><mark>示例：</mark></p>
<img src="/img/SpringCloudAlibaba.assets/image-20230114100316866.png" alt="image-20230114100316866" style="zoom:50%;" />

<p><strong>（2）range查询</strong></p>
<blockquote>
<p>范围查询，一般应用在对数值类型做范围过滤的时候。比如做价格范围过滤。</p>
</blockquote>
<ul>
<li>查询类型为<code>range</code></li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// range查询</span></span><br><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>		</span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>	<span class="comment">//FIELD为要查询的字段名</span></span><br><span class="line">        <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> <span class="comment">// 这里的gte代表大于等于，gt则代表大于</span></span><br><span class="line">        <span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="number">20</span> <span class="comment">// lte代表小于等于，lt则代表小于</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="④地理坐标查询"><a href="#④地理坐标查询" class="headerlink" title="④地理坐标查询"></a>④地理坐标查询</h3><blockquote>
<p>所谓的地理坐标查询，其实就是根据经纬度查询，官方文档：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html%EF%BC%8C%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9C%89%EF%BC%9A">https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html，常用的有：</a></p>
<ul>
<li>矩形范围查询<code>geo_bounding_box</code></li>
<li>附近查询<code>geo_distance</code></li>
</ul>
</blockquote>
<p><strong>（1）矩形范围查询</strong></p>
<blockquote>
<p>矩形范围查询，也就是geo_bounding_box查询，查询坐标落在某个矩形范围的所有文档：</p>
<p><img src="/img/SpringCloudAlibaba.assets/DKV9HZbVS6-16736623624361.gif" alt="DKV9HZbVS6"></p>
</blockquote>
<ul>
<li>查询类型为<code>geo_bounding_box</code></li>
</ul>
<p>查询时，需要指定矩形的<strong>左上</strong>、<strong>右下</strong>两个点的坐标，然后画出一个矩形，落在该矩形内的都是符合条件的点。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// geo_bounding_box查询</span></span><br><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;geo_bounding_box&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;top_left&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 左上点</span></span><br><span class="line">          <span class="attr">&quot;lat&quot;</span><span class="punctuation">:</span> <span class="number">31.1</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;lon&quot;</span><span class="punctuation">:</span> <span class="number">121.5</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;bottom_right&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 右下点</span></span><br><span class="line">          <span class="attr">&quot;lat&quot;</span><span class="punctuation">:</span> <span class="number">30.9</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;lon&quot;</span><span class="punctuation">:</span> <span class="number">121.7</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）附近查询</strong></p>
<blockquote>
<p>附近查询，也叫做距离查询（geo_distance）：查询到指定中心点小于某个距离值的所有文档。</p>
<p>换句话来说，在地图上找一个点作为圆心，以指定距离为半径，画一个圆，落在圆内的坐标都算符合条件：</p>
<img src="/img/SpringCloudAlibaba.assets/vZrdKAh19C.gif" alt="vZrdKAh19C" style="zoom: 50%;" />
</blockquote>
<ul>
<li>查询类型为<code>geo_distance</code></li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// geo_distance 查询</span></span><br><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;geo_distance&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;distance&quot;</span><span class="punctuation">:</span> <span class="string">&quot;15km&quot;</span><span class="punctuation">,</span> <span class="comment">// 半径</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="string">&quot;31.21,121.5&quot;</span> <span class="comment">// 圆心		也可以把经纬度分开作为</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<p><mark>示例：</mark></p>
<p>我们先搜索陆家嘴附近15km的酒店：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210721175443234.png" alt="image-20210721175443234" style="zoom:50%;" />

<p>发现共有47家酒店。</p>
<p>然后把半径缩短到3公里：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210721182031475.png" alt="image-20210721182031475" style="zoom:50%;" />

<p>可以发现，搜索到的酒店数量减少到了5家。</p>
<hr>
<h3 id="⑤复合查询"><a href="#⑤复合查询" class="headerlink" title="⑤复合查询"></a>⑤复合查询</h3><blockquote>
<p>复合（compound）查询：复合查询可以<strong>将其它简单查询组合起来</strong>，实现更复杂的搜索逻辑。常见的有两种：</p>
<ul>
<li>fuction score：算分函数查询，可以控制文档相关性算分，控制文档排名</li>
<li>bool query：布尔查询，利用逻辑关系组合多个其它的查询，实现复杂搜索</li>
</ul>
</blockquote>
<h4 id="（1）相关性算分介绍"><a href="#（1）相关性算分介绍" class="headerlink" title="（1）相关性算分介绍"></a><strong>（1）相关性算分介绍</strong></h4><p>当我们利用match查询时，*<u>文档结果会根据与搜索词条的关联度打分（_score），返回结果时<strong>按照分值降序排列</strong>。</u>*</p>
<p>例如，我们搜索 “虹桥如家”，结果如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;_score&quot;</span> <span class="punctuation">:</span> <span class="number">17.850193</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_source&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;虹桥如家酒店真不错&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;_score&quot;</span> <span class="punctuation">:</span> <span class="number">12.259849</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_source&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;外滩如家酒店真不错&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>在elasticsearch中，早期使用的打分算法是<strong>TF-IDF算法</strong>，公式如下：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210721190152134.png" alt="image-20210721190152134" style="zoom:50%;" />

<p>在后来的5.1版本升级中，elasticsearch将算法改进为<strong>BM25算法</strong>，公式如下：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210721190416214.png" alt="image-20210721190416214" style="zoom:50%;" />



<p>TF-IDF算法有一各缺陷，就是词条频率越高，文档得分也会越高，单个词条对文档影响较大。而BM25则会让单个词条的算分有一个上限，曲线更加平滑：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210721190907320.png" alt="image-20210721190907320" style="zoom:50%;" />

<hr>
<h4 id="（2）算分函数查询"><a href="#（2）算分函数查询" class="headerlink" title="（2）算分函数查询"></a><strong>（2）算分函数查询</strong></h4><blockquote>
<p>根据相关度打分是比较合理的需求，但<strong>合理的不一定是产品经理需要</strong>的。</p>
<p>以百度为例，你搜索的结果中，并不是相关度越高排名越靠前，<strong>而是谁掏的钱多排名就越靠前</strong>。要想人为控制相关性算分，就需要利用elasticsearch中的function score 查询了。</p>
</blockquote>
<p>语法说明：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20230114104441630.png" alt="image-20230114104441630" style="zoom: 60%;" />

<p><mark>function score 查询中包含四部分内容：</mark></p>
<ul>
<li><strong>原始查询</strong>条件：<code>query</code>部分，基于这个条件搜索文档，并且基于BM25算法给文档打分，<strong>原始算分</strong>（query score)</li>
<li><strong>过滤条件</strong>：<code>filter</code>部分，符合该条件的文档才会重新算分</li>
<li><strong>算分函数</strong>：符合filter条件的文档要根据这个函数做运算，得到的<strong>函数算分</strong>（function score），有四种函数<ul>
<li><code>weight</code>：函数结果是常量</li>
<li><code>field_value_factor</code>：以文档中的某个字段值作为函数结果</li>
<li><code>random_score</code>：以随机数作为函数结果</li>
<li><code>script_score</code>：自定义算分函数算法</li>
</ul>
</li>
<li><strong>运算模式</strong>：算分函数的结果、原始查询的相关性算分，两者之间的运算方式，包括：<ul>
<li><code>multiply</code>：相乘</li>
<li><code>replace</code>：用function score替换query score</li>
<li>其它，例如：<code>sum</code>、<code>avg</code>、<code>max</code>、<code>min</code></li>
</ul>
</li>
</ul>
<p>function score的运行流程如下：</p>
<ul>
<li>1）根据<strong>原始条件</strong>查询搜索文档，并且计算相关性算分，称为<strong>原始算分</strong>（query score）</li>
<li>2）根据<strong>过滤条件</strong>，过滤文档</li>
<li>3）符合<strong>过滤条件</strong>的文档，基于<strong>算分函数</strong>运算，得到<strong>函数算分</strong>（function score）</li>
<li>4）将<strong>原始算分</strong>（query score）和<strong>函数算分</strong>（function score）基于<strong>运算模式</strong>做运算，得到最终结果，作为相关性算分。</li>
</ul>
<p>因此，其中的关键点是：</p>
<ul>
<li>过滤条件：决定哪些文档的算分被修改</li>
<li>算分函数：决定函数算分的算法</li>
<li>运算模式：决定最终算分结果</li>
</ul>
<p><mark>示例：</mark></p>
<p>翻译一下这个需求，转换为之前说的四个要点：</p>
<ul>
<li>原始条件：不确定，可以任意变化</li>
<li>过滤条件：brand &#x3D; “如家”</li>
<li>算分函数：可以简单粗暴，直接给固定的算分结果，weight</li>
<li>运算模式：比如求和</li>
</ul>
<p>因此最终的DSL语句如下：</p>
<p><strong>查询类型为<code>function_score</code></strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;function_score&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  .... <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="comment">// 原始查询，可以是任意条件</span></span><br><span class="line">      <span class="attr">&quot;functions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">// 算分函数</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 满足的条件，品牌必须是如家</span></span><br><span class="line">            <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span> <span class="string">&quot;如家&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;weight&quot;</span><span class="punctuation">:</span> <span class="number">2</span> <span class="comment">// 算分权重为2</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;boost_mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sum&quot;</span> <span class="comment">// 加权模式，求和</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>测试，在未添加算分函数时，如家得分如下：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210721193152520.png" alt="image-20210721193152520" style="zoom:50%;" />

<p>添加了算分函数后，如家得分就提升了：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210721193458182.png" alt="image-20210721193458182" style="zoom:50%;" />

<hr>
<h4 id="（3）布尔查询"><a href="#（3）布尔查询" class="headerlink" title="（3）布尔查询"></a>（3）布尔查询</h4><blockquote>
<p>比如在搜索酒店时，除了关键字搜索外，我们还可能根据品牌、价格、城市等字段做过滤：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210721193822848-16736652812417.png" alt="image-20210721193822848" style="zoom:50%;" />

<p>每一个不同的字段，其查询的条件、方式都不一样，必须是多个不同的查询，而要组合这些查询，就必须用bool查询了。</p>
<p>需要注意的是，搜索时，参与<strong>算分的字段越多，查询的性能也越差</strong>。因此这种多条件查询时，建议这样做：</p>
<ul>
<li>搜索框的关键字搜索，是全文检索查询，使用must查询，参与算分</li>
<li>其它过滤条件，采用filter查询。不参与算分</li>
</ul>
</blockquote>
<p>布尔查询是一个或多个查询子句的组合，每一个子句就是一个<strong>子查询</strong>（理解为是多条件查询就行）。子查询的组合方式有：</p>
<ul>
<li>must：必须匹配每个子查询，类似“与”</li>
<li>should：选择性匹配子查询，类似“或”</li>
<li>must_not：必须不匹配，<strong>不参与算分</strong>，类似“非”</li>
<li>filter：必须匹配，<strong>不参与算分</strong></li>
</ul>
<p><mark>语法示例：</mark></p>
<ul>
<li>查询类型为<code>bool</code>。<code>must</code>、<code>should</code>、<code>must_not</code>、<code>filter</code>都看成是一个一个的查询条件。</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>			<span class="comment">//查询类型：bool</span></span><br><span class="line">      <span class="attr">&quot;must&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="string">&quot;上海&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;should&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span> <span class="string">&quot;皇冠假日&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span> <span class="string">&quot;华美达&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;must_not&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="number">500</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;score&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="number">45</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><mark>案例：</mark></p>
<p>分析：</p>
<ul>
<li>名称搜索，属于全文检索查询，应该参与算分。放到must中</li>
<li>价格不高于400，用range查询，属于过滤条件，不参与算分。放到must_not中</li>
<li>周围10km范围内，用geo_distance查询，属于过滤条件，不参与算分。放到filter中</li>
</ul>
<img src="/img/SpringCloudAlibaba.assets/image-20210721194744183.png" alt="image-20210721194744183" style="zoom:50%;" />

<hr>
<h2 id="4-6搜索结果处理"><a href="#4-6搜索结果处理" class="headerlink" title="4.6搜索结果处理"></a>4.6搜索结果处理</h2><blockquote>
<p>搜索的结果可以按照用户指定的方式去处理或展示。</p>
</blockquote>
<h3 id="①排序"><a href="#①排序" class="headerlink" title="①排序"></a>①排序</h3><blockquote>
<p>elasticsearch<strong>默认是根据相关度算分（_score）来排序</strong>，但是也支持自定义方式对搜索<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/sort-search-results.html">结果排序</a>。可以排序字段类型有：keyword类型（根据字母大小排序）、数值类型、地理坐标类型、日期类型等。</p>
<p><strong>DSL中<code>sort</code>字段与<code>query</code>在同一级</strong></p>
</blockquote>
<h4 id="（1）普通字段排序"><a href="#（1）普通字段排序" class="headerlink" title="（1）普通字段排序"></a><strong>（1）普通字段排序</strong></h4><blockquote>
<p>keyword、数值、日期类型排序的语法基本一致。</p>
</blockquote>
<p><mark>语法：</mark></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>			<span class="comment">//sort字段与query放在同一级</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span>  <span class="comment">// 排序字段、排序方式ASC、DESC</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><em><u>排序条件是一个数组，也就是可以写多个排序条件。按照声明的顺序，当第一个条件相等时，再按照第二个条件排序，以此类推</u></em></p>
<p><mark>示例：</mark></p>
<p>需求描述：酒店数据按照用户评价（score)降序排序，评价相同的按照价格(price)升序排序</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210721195728306.png" alt="image-20210721195728306" style="zoom:60%;" />



<h4 id="（2）地理坐标排序"><a href="#（2）地理坐标排序" class="headerlink" title="（2）地理坐标排序"></a><strong>（2）地理坐标排序</strong></h4><blockquote>
<p>地理坐标排序略有不同。</p>
</blockquote>
<p><mark>语法示例：</mark></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;_geo_distance&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;FIELD&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;纬度，经度&quot;</span><span class="punctuation">,</span> <span class="comment">// FIELD代表文档中geo_point类型的字段名，其值代表目标坐标点</span></span><br><span class="line">          <span class="attr">&quot;order&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span><span class="punctuation">,</span> <span class="comment">// 排序方式</span></span><br><span class="line">          <span class="attr">&quot;unit&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;km&quot;</span> <span class="comment">// 排序的距离单位</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这个查询的含义是：</p>
<p><u><em>指定一个坐标，作为目标点。计算每一个文档中，指定字段（必须是geo_point类型）的坐标 到目标点的距离是多少。</em></u></p>
<p><u><em>并根据距离排序。</em></u></p>
<p><mark>示例：</mark></p>
<p>提示：获取你的位置的经纬度的方式：<a target="_blank" rel="noopener" href="https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/">https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/</a></p>
<p>假设我的位置是：31.034661，121.612282，寻找我周围距离最近的酒店。</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210721200214690.png" alt="image-20210721200214690" style="zoom:50%;" />

<hr>
<h3 id="②分页"><a href="#②分页" class="headerlink" title="②分页"></a>②分页</h3><blockquote>
<p>elasticsearch <strong>默认情况下只返回top10的数据</strong>。而如果要查询更多数据就需要修改分页参数了。</p>
<p><u>elasticsearch中通过修改from、size参数来控制要返回的分页结果：</u></p>
<ul>
<li>from：从第几个文档开始</li>
<li>size：总共查询几个文档</li>
</ul>
<p>类似于mysql中的<code>limit ?, ?</code>      <strong>DSL中<code>from</code>字段与<code>size</code>字段都与<code>query</code>在同一级</strong></p>
</blockquote>
<p><strong>（1）基本分页</strong></p>
<p>分页的基本语法如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span>	<span class="comment">//from与size都与query在同一级</span></span><br><span class="line">  <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> <span class="comment">// 分页开始的位置，默认为0</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> <span class="comment">// 期望获取的文档总数</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）深度分页问题</strong></p>
<p>如果要查询990~1000的数据，查询逻辑要这么写：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">990</span><span class="punctuation">,</span> <span class="comment">// 分页开始的位置，默认为0</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> <span class="comment">// 期望获取的文档总数</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这里是查询990开始的数据，也就是 第990~第1000条 数据。</p>
<p>不过，elasticsearch内部分页时，必须先查询 0~1000条，然后截取其中的990 ~ 1000的这10条：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210721200643029.png" alt="image-20210721200643029" style="zoom:50%;" />



<p>查询TOP1000，如果es是单点模式，这并无太大影响。</p>
<p>但是elasticsearch将来一定是<strong>集群</strong>，例如我集群有5个节点，我要查询TOP1000的数据，并不是每个节点查询200条就可以了。</p>
<p>因为节点A的TOP200，在另一个节点可能排到10000名以外了。</p>
<p>因此要想获取整个集群的TOP1000，<strong>必须先查询出每个节点的TOP1000，汇总结果后，重新排名，重新截取TOP1000。</strong></p>
<img src="/img/SpringCloudAlibaba.assets/image-20210721201003229.png" alt="image-20210721201003229" style="zoom:50%;" />



<p>那如果我要查询9900~10000的数据呢？是不是要先查询TOP10000呢？那每个节点都要查询10000条？汇总到内存中？</p>
<p><em><u>当查询分页深度较大时，汇总数据过多，对内存和CPU会产生非常大的压力，因此elasticsearch会禁止from+ size 超过10000的请求。</u></em></p>
<p><strong>针对深度分页，ES提供了两种解决方案</strong>，<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html">官方文档</a>：</p>
<ul>
<li><p>search after：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。</p>
<ul>
<li><p>优点：没有查询上限（单次查询的size不超过10000）</p>
</li>
<li><p>缺点：只能向后逐页查询，不支持随机翻页</p>
</li>
<li><p>场景：没有随机翻页需求的搜索，例如手机向下滚动翻页</p>
</li>
</ul>
</li>
<li><p>scroll：原理将排序后的文档id形成快照，保存在内存。官方已经不推荐使用。</p>
<ul>
<li>优点：没有查询上限（单次查询的size不超过10000）</li>
<li>缺点：会有额外内存消耗，并且搜索结果是非实时的</li>
<li>场景：海量数据的获取和迁移。从ES7.1开始不推荐，建议用 after search方案。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="③高亮"><a href="#③高亮" class="headerlink" title="③高亮"></a>③高亮</h3><p><strong>（1）高亮显示原理</strong></p>
<p>我们在百度，京东搜索时，关键字会变成红色，比较醒目，这叫高亮显示：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210721202705030.png" alt="image-20210721202705030" style="zoom:50%;" />

<p>高亮显示的实现分为两步：</p>
<ul>
<li>1）给文档中的所有关键字都添加一个标签，例如<code>&lt;em&gt;</code>标签</li>
<li>2）页面给<code>&lt;em&gt;</code>标签编写CSS样式</li>
</ul>
<p><strong>（2）实现高亮</strong></p>
<p><mark>语法示例：</mark></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="string">&quot;TEXT&quot;</span> <span class="comment">// 查询条件，高亮一定要使用全文检索查询，用term其实也可以，但没必要</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;highlight&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 指定要高亮的字段</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;pre_tags&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;em&gt;&quot;</span><span class="punctuation">,</span>  <span class="comment">// 用来标记高亮字段的前置标签，默认就是&lt;em&gt;</span></span><br><span class="line">        <span class="attr">&quot;post_tags&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;/em&gt;&quot;</span> <span class="comment">// 用来标记高亮字段的后置标签</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><mark>注意：</mark></p>
<ul>
<li>高亮是对关键字高亮，因此<strong>搜索条件必须带有关键字</strong>，而不能是范围这样的查询。</li>
<li>默认情况下，<strong>高亮的字段，必须与搜索指定的字段一致</strong>，否则无法高亮</li>
<li>高亮的字段都存放<code>&quot;source&quot;</code>后面的<code>&quot;highlight&quot;</code>属性中，因为source中是原文档不能被修改</li>
<li>如果要对非搜索字段高亮，则需要添加一个属性：required_field_match&#x3D;false。而如果对非搜锁字段高亮，则该字段中一定要含有搜索字短指定的关键字，否则肯定是没有高亮结果的。</li>
</ul>
<p><mark>示例</mark>：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210721203349633.png" alt="image-20210721203349633" style="zoom:50%;" />

<hr>
<p>总结：</p>
<p>查询的DSL是一个大的JSON对象，包含下列属性：</p>
<ul>
<li>query：查询条件</li>
<li>from和size：分页条件</li>
<li>sort：排序条件</li>
<li>highlight：高亮条件</li>
</ul>
<p>示例：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210721203657850.png" alt="image-20210721203657850" style="zoom:50%;" />

<hr>
<h2 id="4-7RestClient查询文档"><a href="#4-7RestClient查询文档" class="headerlink" title="4.7RestClient查询文档"></a>4.7RestClient查询文档</h2><blockquote>
<p>文档的查询同样适用昨天学习的 RestHighLevelClient对象，基本步骤包括：</p>
<ul>
<li>1）准备Request对象</li>
<li>2）准备请求参数</li>
<li>3）发起请求</li>
<li>4）解析响应</li>
</ul>
</blockquote>
<h3 id="①基本步骤"><a href="#①基本步骤" class="headerlink" title="①基本步骤"></a>①基本步骤</h3><h4 id="（1）发起查询请求"><a href="#（1）发起查询请求" class="headerlink" title="（1）发起查询请求"></a>（1）发起查询请求</h4><ul>
<li><p>第一步，创建<code>SearchRequest</code>对象，指定索引库名</p>
</li>
<li><p>第二步，利用<code>request.source()</code>构建DSL，DSL中可以包含查询、分页、排序、高亮等</p>
<ul>
<li><code>query()</code>：代表查询条件，利用<code>QueryBuilders.matchAllQuery()</code>构建一个match_all查询的DSL</li>
</ul>
</li>
<li><p>第三步，利用client.search()发送请求，得到响应</p>
</li>
</ul>
<p>这里关键的API有两个，一个是<code>request.source()</code>，其中包含了查询、排序、分页、高亮等所有功能：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210721215640790.png" alt="image-20210721215640790" style="zoom:50%;" />

<p>另一个是<code>QueryBuilders</code>，其中包含match、term、function_score、bool等各种查询：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210721215729236.png" alt="image-20210721215729236" style="zoom:50%;" />

<h4 id="（2）解析响应"><a href="#（2）解析响应" class="headerlink" title="（2）解析响应"></a>（2）解析响应</h4><p>响应结果的解析：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210721214221057.png" alt="image-20210721214221057" style="zoom:50%;" />



<p>elasticsearch返回的结果是一个JSON字符串，结构包含：</p>
<ul>
<li><code>hits</code>：命中的结果<ul>
<li><code>total</code>：总条数，其中的value是具体的总条数值</li>
<li><code>max_score</code>：所有结果中得分最高的文档的相关性算分</li>
<li><code>hits</code>：搜索结果的文档数组，其中的每个文档都是一个json对象<ul>
<li><code>_source</code>：文档中的原始数据，也是json对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>因此，我们解析响应结果，就是<strong>逐层解析JSON字符串</strong>，流程如下：</p>
<ul>
<li><code>SearchHits</code>：通过response.getHits()获取，就是JSON中的最外层的hits，代表命中的结果<ul>
<li><code>SearchHits#getTotalHits().value</code>：获取总条数信息</li>
<li><code>SearchHits#getHits()</code>：获取SearchHit数组，也就是文档数组<ul>
<li><code>SearchHit#getSourceAsString()</code>：获取文档结果中的_source，也就是原始的json文档数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><mark>示例：查询所有</mark></p>
<img src="/img/SpringCloudAlibaba.assets/image-20230114131415623.png" alt="image-20230114131415623" style="zoom: 50%;" />

<hr>
<h3 id="②全文检索查询-1"><a href="#②全文检索查询-1" class="headerlink" title="②全文检索查询"></a>②全文检索查询</h3><p>修改<code>request.source().query(QueryBuilders.xxxQuery())</code>中的QuerBuilders.的类型即可</p>
<img src="/img/SpringCloudAlibaba.assets/image-20230114131735908.png" alt="image-20230114131735908" style="zoom: 80%;" />

<p>单字段查询：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20230114131830407.png" alt="image-20230114131830407" style="zoom: 40%;" />

<hr>
<h3 id="③精确查询"><a href="#③精确查询" class="headerlink" title="③精确查询"></a>③精确查询</h3><p>精确查询主要是两者：</p>
<ul>
<li>term：词条精确匹配</li>
<li>range：范围查询</li>
</ul>
<p>与之前的查询相比，差异同样在查询条件，其它都一样。</p>
<p>查询条件构造的API如下：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210721220305140.png" alt="image-20210721220305140" style="zoom: 80%;" /> 

<img src="/img/SpringCloudAlibaba.assets/image-20230114133447624.png" alt="image-20230114133447624" style="zoom: 33%;" />

<img src="/img/SpringCloudAlibaba.assets/image-20230114133752454.png" alt="image-20230114133752454" style="zoom:33%;" />

<hr>
<h3 id="④布尔查询"><a href="#④布尔查询" class="headerlink" title="④布尔查询"></a>④布尔查询</h3><p>布尔查询是用must、must_not、filter等方式<strong>组合其它查询</strong>，代码示例如下：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210721220927286.png" alt="image-20210721220927286" style="zoom:50%;" />



<p>可以看到，API与其它查询的差别同样是在查询条件的构建，QueryBuilders，结果解析等其他代码完全不变。</p>
<img src="/img/SpringCloudAlibaba.assets/image-20230114133856071.png" alt="image-20230114133856071" style="zoom: 33%;" />

<hr>
<h3 id="⑤地理坐标查询"><a href="#⑤地理坐标查询" class="headerlink" title="⑤地理坐标查询"></a>⑤地理坐标查询</h3><img src="/img/SpringCloudAlibaba.assets/image-20230114144431595.png" alt="image-20230114144431595" style="zoom:33%;" />

<hr>
<h3 id="⑥添加算分函数查询"><a href="#⑥添加算分函数查询" class="headerlink" title="⑥添加算分函数查询"></a>⑥添加算分函数查询</h3><p>接下来我们就要修改查询条件了。之前是用的boolean 查询，现在要改成function_socre查询。</p>
<p>function_score查询结构如下：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210721191544750.png" alt="image-20210721191544750" style="zoom:50%;" />



<p>对应的JavaAPI如下：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210722102850818.png" alt="image-20210722102850818" style="zoom:50%;" />

<p>我们可以将之前写的boolean查询作为<strong>原始查询</strong>条件放到query中，接下来就是添加<strong>过滤条件</strong>、<strong>算分函数</strong>、<strong>加权模式</strong>了。所以原来的代码依然可以沿用。</p>
<img src="/img/SpringCloudAlibaba.assets/image-20230114145335239.png" alt="image-20230114145335239" style="zoom: 40%;" />

<hr>
<h3 id="⑦排序、分页"><a href="#⑦排序、分页" class="headerlink" title="⑦排序、分页"></a>⑦排序、分页</h3><p>搜索结果的排序和分页是与query同级的参数，因此同样是使用request.source()来设置。</p>
<p>对应的API如下：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210721221121266.png" alt="image-20210721221121266" style="zoom:50%;" />

<img src="/img/SpringCloudAlibaba.assets/image-20230114134507251.png" alt="image-20230114134507251" style="zoom: 33%;" />

<p><mark>地理坐标排序：</mark></p>
<img src="/img/SpringCloudAlibaba.assets/image-20230114144147430.png" alt="image-20230114144147430" style="zoom:50%;" />

<p><em>获得地理坐标排序后各自与中心的距离：</em></p>
<img src="/img/SpringCloudAlibaba.assets/image-20230114144841607.png" alt="image-20230114144841607" style="zoom: 67%;" />

<img src="/img/SpringCloudAlibaba.assets/image-20230114145041824.png" alt="image-20230114145041824" style="zoom:40%;" />

<hr>
<h3 id="⑧高亮"><a href="#⑧高亮" class="headerlink" title="⑧高亮"></a>⑧高亮</h3><blockquote>
<p>高亮的代码与之前代码差异较大，有两点：</p>
<ul>
<li>查询的DSL：其中除了查询条件，还需要添加高亮条件，同样是与query同级。</li>
<li>结果解析：结果除了要解析_source文档数据，还要解析高亮结果</li>
</ul>
</blockquote>
<h4 id="（1）高亮请求构建"><a href="#（1）高亮请求构建" class="headerlink" title="（1）高亮请求构建"></a>（1）高亮请求构建</h4><p>高亮请求的构建API如下：</p>
<p><img src="/img/SpringCloudAlibaba.assets/image-20210721221744883.png" alt="image-20210721221744883"></p>
<p>上述代码省略了查询条件部分，但是大家不要忘了：高亮查询必须使用全文检索查询，并且要有搜索关键字，将来才可以对关键字高亮。</p>
<img src="/img/SpringCloudAlibaba.assets/image-20230114143342507.png" alt="image-20230114143342507" style="zoom: 33%;" />



<h4 id="（2）高亮结果解析"><a href="#（2）高亮结果解析" class="headerlink" title="（2）高亮结果解析"></a>（2）高亮结果解析</h4><p>高亮的结果与查询的文档结果默认是分离的，并不在一起。</p>
<p>因此解析高亮的代码需要额外处理：</p>
<p><img src="/img/SpringCloudAlibaba.assets/image-20210721222057212.png" alt="image-20210721222057212"></p>
<p>代码解读：</p>
<ul>
<li>第一步：从结果中获取source。hit.getSourceAsString()，这部分是非高亮结果，json字符串。还需要反序列为HotelDoc对象</li>
<li>第二步：获取高亮结果。hit.getHighlightFields()，返回值是一个Map，key是高亮字段名称，值是HighlightField对象，代表高亮值</li>
<li>第三步：从map中根据高亮字段名称，获取高亮字段值对象HighlightField</li>
<li>第四步：从HighlightField中获取Fragments，并且转为字符串。这部分就是真正的高亮字符串了</li>
<li>第五步：用高亮的结果替换HotelDoc中的非高亮结果</li>
</ul>
<p>完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleResponse</span><span class="params">(SearchResponse response)</span> &#123;</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">    <span class="comment">// 4.1.获取总条数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> searchHits.getTotalHits().value;</span><br><span class="line">    System.out.println(<span class="string">&quot;共搜索到&quot;</span> + total + <span class="string">&quot;条数据&quot;</span>);</span><br><span class="line">    <span class="comment">// 4.2.文档数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="comment">// 4.3.遍历</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="comment">// 获取文档source</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> JSON.parseObject(json, HotelDoc.class);</span><br><span class="line">        <span class="comment">// 获取高亮结果</span></span><br><span class="line">        Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(highlightFields)) &#123;</span><br><span class="line">            <span class="comment">// 根据字段名获取高亮结果</span></span><br><span class="line">            <span class="type">HighlightField</span> <span class="variable">highlightField</span> <span class="operator">=</span> highlightFields.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (highlightField != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取高亮值</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> highlightField.getFragments()[<span class="number">0</span>].string();</span><br><span class="line">                <span class="comment">// 覆盖非高亮结果</span></span><br><span class="line">                hotelDoc.setName(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;hotelDoc = &quot;</span> + hotelDoc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-8数据聚合"><a href="#4-8数据聚合" class="headerlink" title="4.8数据聚合"></a>4.8数据聚合</h2><blockquote>
<p>**<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">聚合（</a><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">aggregations</a><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">）</a>**可以让我们极其方便的实现对数据的统计、分析、运算。例如：（如同sql中的聚合函数一样）</p>
<ul>
<li>什么品牌的手机最受欢迎？</li>
<li>这些手机的平均价格、最高价格、最低价格？</li>
<li>这些手机每月的销售情况如何？</li>
</ul>
<p>实现这些统计功能的比数据库的sql要方便的多，而且查询速度非常快，可以实现近实时搜索效果。</p>
</blockquote>
<h3 id="①聚合的种类"><a href="#①聚合的种类" class="headerlink" title="①聚合的种类"></a>①聚合的种类</h3><p>es中聚合常见的有三类：</p>
<ul>
<li><p><strong>桶（Bucket）</strong>聚合：用来对文档做分组</p>
<ul>
<li>TermAggregation：按照文档字段值分组，例如按照品牌值分组、按照国家分组</li>
<li>Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组</li>
</ul>
</li>
<li><p><strong>度量（Metric）</strong>聚合：用以计算一些值，比如：最大值、最小值、平均值等</p>
<ul>
<li>Avg：求平均值</li>
<li>Max：求最大值</li>
<li>Min：求最小值</li>
<li>Stats：同时求max、min、avg、sum等</li>
</ul>
</li>
<li><p><strong>管道（pipeline）</strong>聚合：其它聚合的结果为基础做聚合</p>
</li>
</ul>
<blockquote>
<p><strong>注意：</strong>参加聚合的字段必须是keyword、日期、数值、布尔类型</p>
</blockquote>
<hr>
<h3 id="②DSL实现聚合"><a href="#②DSL实现聚合" class="headerlink" title="②DSL实现聚合"></a>②DSL实现聚合</h3><p><strong>（1）Bucket聚合语法</strong></p>
<p>语法如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span>  <span class="comment">// 设置size为0，结果中不包含文档，只包含聚合结果</span></span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 定义聚合</span></span><br><span class="line">    <span class="attr">&quot;brandAgg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//给聚合起个名字</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 聚合的类型，按照品牌值聚合，所以选择term，精确</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;brand&quot;</span><span class="punctuation">,</span> <span class="comment">// 参与聚合的字段</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span> <span class="comment">// 希望获取的聚合结果数量</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>结果如图：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210723171948228.png" alt="image-20210723171948228" style="zoom:50%;" />

<p><strong>（2）聚合结果排序</strong></p>
<p>默认情况下，Bucket聚合会统计Bucket内的文档数量，记为_count，并且按照_<em>count</em>降序排序。</p>
<p>我们可以指定order属性，自定义聚合的排序方式：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;brandAgg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;brand&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;_count&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span> <span class="comment">// 按照_count升序排列，_count代表聚合结果每一条的数目</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>（3）限定聚合范围</strong></p>
<p>我们可以限定要聚合的文档范围，只要添加query条件即可，那么就会按照查询出来的数据进行聚合：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="number">200</span> <span class="comment">// 只对200元以下的文档聚合</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;brandAgg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;brand&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这次，聚合得到的品牌明显变少了：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210723172404836.png" alt="image-20210723172404836" style="zoom:50%;" />

<p><strong>（4）Metric聚合</strong></p>
<p>上节课，我们对酒店按照品牌分组，形成了一个个桶。现在我们需要对桶内的酒店做运算，获取每个品牌的用户评分的min、max、avg等值。</p>
<p>这就要用到Metric聚合了，例如stat聚合：就可以获取min、max、avg等结果。</p>
<p>语法如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;brandAgg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;brand&quot;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 是brands聚合的子聚合，也就是分组后对每组分别计算</span></span><br><span class="line">        <span class="attr">&quot;score_stats&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 聚合名称</span></span><br><span class="line">          <span class="attr">&quot;stats&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 聚合类型，这里stats可以计算min、max、avg等</span></span><br><span class="line">            <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;score&quot;</span> <span class="comment">// 聚合字段，这里是score</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<p>这次的score_stats聚合是在brandAgg的聚合内部嵌套的子聚合。因为我们需要在每个桶分别计算。</p>
<p>另外，我们还可以给聚合结果做个排序，例如按照每个桶的酒店平均分做排序：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210723172917636.png" alt="image-20210723172917636" style="zoom:50%;" />



<p><mark>总结：</mark></p>
<p><u><em>aggs代表聚合，与query同级，此时query的作用是？</em></u></p>
<ul>
<li>限定聚合的的文档范围</li>
</ul>
<p><em><u>聚合必须的三要素：</u></em></p>
<ul>
<li>聚合名称</li>
<li>聚合类型</li>
<li>聚合字段</li>
</ul>
<p><u><em>聚合可配置属性有：</em></u></p>
<ul>
<li>size：指定聚合结果数量</li>
<li>order：指定聚合结果排序方式</li>
<li>field：指定聚合字段</li>
</ul>
<hr>
<h3 id="③RestClient实现聚合"><a href="#③RestClient实现聚合" class="headerlink" title="③RestClient实现聚合"></a>③RestClient实现聚合</h3><img src="/img/SpringCloudAlibaba.assets/image-20230118100109439.png" alt="image-20230118100109439" style="zoom: 40%;" />

<hr>
<h2 id="4-9自动补全"><a href="#4-9自动补全" class="headerlink" title="4.9自动补全"></a>4.9自动补全</h2><blockquote>
<p>当用户在搜索框输入字符时，我们应该提示出与该字符有关的搜索项，如图：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210723204936367.png" alt="image-20210723204936367" style="zoom: 50%;" />

<p>这种根据用户输入的字母，提示完整词条的功能，就是自动补全了。</p>
<p><em><u>因为需要根据拼音字母来推断，因此要用到拼音分词功能。</u></em></p>
</blockquote>
<h3 id="①安装拼音分词器"><a href="#①安装拼音分词器" class="headerlink" title="①安装拼音分词器"></a>①安装拼音分词器</h3><p>安装方式与IK分词器一样，分三步：</p>
<p>​	①解压</p>
<p>​	②上传到虚拟机中，elasticsearch的plugin目录</p>
<p>​	③重启elasticsearch</p>
<p>​	④测试</p>
<p>测试用法如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /_analyze</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;如家酒店还不错&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pinyin&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210723210126506.png" alt="image-20210723210126506" style="zoom:50%;" />

<hr>
<h3 id="②自定义分词器"><a href="#②自定义分词器" class="headerlink" title="②自定义分词器"></a>②自定义分词器</h3><p>默认的拼音分词器会将每个汉字单独分为拼音，而我们希望的是<strong>每个词条形成一组拼音</strong>，需要对拼音分词器做个性化定制，形成自定义分词器。</p>
<p>elasticsearch中分词器（analyzer）的组成包含三部分：</p>
<ul>
<li>character filters：在tokenizer之前对文本进行处理。例如删除字符、替换字符</li>
<li>tokenizer：将文本按照一定的规则切割成词条（term）。例如keyword，就是不分词；还有ik_smart</li>
<li>tokenizer filter：将tokenizer输出的词条做进一步处理。例如大小写转换、同义词处理、拼音处理等</li>
</ul>
<p>文档分词时会依次由这三部分来处理文档：</p>
   <img src="/img/SpringCloudAlibaba.assets/image-20210723210427878.png" alt="image-20210723210427878" style="zoom:50%;" />

<p>声明自定义分词器的语法如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">PUT /test</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;analysis&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 自定义分词器</span></span><br><span class="line">        <span class="attr">&quot;my_analyzer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  <span class="comment">// 分词器名称</span></span><br><span class="line">          <span class="attr">&quot;tokenizer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;py&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 自定义tokenizer filter</span></span><br><span class="line">        <span class="attr">&quot;py&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 过滤器名称</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pinyin&quot;</span><span class="punctuation">,</span> <span class="comment">// 过滤器类型，这里是pinyin</span></span><br><span class="line">		  <span class="attr">&quot;keep_full_pinyin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;keep_joined_full_pinyin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;keep_original&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;limit_first_letter_length&quot;</span><span class="punctuation">:</span> <span class="number">16</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;remove_duplicated_term&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;none_chinese_pinyin_tokenize&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my_analyzer&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;search_analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span>		<span class="comment">//为避免搜索到同音字，搜索时不使用拼音分词器</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>测试：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210723211829150.png" alt="image-20210723211829150" style="zoom:50%;" />

<p><em><u>经过自定义分词器后，字段数据会被分成多个中文词条及词条的拼音缩写</u></em></p>
<hr>
<h3 id="③自动补全查询"><a href="#③自动补全查询" class="headerlink" title="③自动补全查询"></a>③自动补全查询</h3><p>elasticsearch提供了<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.6/search-suggesters.html">Completion Suggester</a>查询来实现自动补全功能。这个查询会匹配以用户输入内容开头的词条并返回。为了提高补全查询的效率，对于文档中字段的类型有一些约束：</p>
<ul>
<li><p><strong>参与补全查询的字段必须是completion类型。</strong></p>
</li>
<li><p><strong>字段的内容一般是用来补全的多个词条形成的数组。</strong></p>
</li>
</ul>
<p>比如，一个这样的索引库：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建索引库</span></span><br><span class="line">PUT test</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;completion&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后插入下面的数据：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例数据</span></span><br><span class="line">POST test/_doc</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;Sony&quot;</span><span class="punctuation">,</span> <span class="string">&quot;WH-1000XM3&quot;</span><span class="punctuation">]</span>		</span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">POST test/_doc</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;SK-II&quot;</span><span class="punctuation">,</span> <span class="string">&quot;PITERA&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">POST test/_doc</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;Nintendo&quot;</span><span class="punctuation">,</span> <span class="string">&quot;switch&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>查询的DSL语句如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动补全查询</span></span><br><span class="line">GET /test/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;suggest&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;title_suggest&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>	<span class="comment">//给这次补全查询取名</span></span><br><span class="line">      <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;s&quot;</span><span class="punctuation">,</span> <span class="comment">// 关键字</span></span><br><span class="line">      <span class="attr">&quot;completion&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>	<span class="comment">//查询字段类型是completion</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;title&quot;</span><span class="punctuation">,</span> <span class="comment">// 要补全查询的字段</span></span><br><span class="line">        <span class="attr">&quot;skip_duplicates&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 跳过重复的</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span> <span class="comment">// 获取前10条结果</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="④RestClient实现自动补全查询"><a href="#④RestClient实现自动补全查询" class="headerlink" title="④RestClient实现自动补全查询"></a>④RestClient实现自动补全查询</h3><p>首先要修改对应的分词器为自定义的分词器，且要修改字段类型为<code>completion</code></p>
<img src="/img/SpringCloudAlibaba.assets/image-20230118104515139.png" alt="image-20230118104515139" style="zoom:50%;" />

<img src="/img/SpringCloudAlibaba.assets/image-20230118104530968.png" alt="image-20230118104530968" style="zoom:50%;" />

<img src="/img/SpringCloudAlibaba.assets/image-20230118103649460.png" alt="image-20230118103649460" style="zoom:40%;" />

<hr>
<h2 id="4-10数据同步"><a href="#4-10数据同步" class="headerlink" title="4.10数据同步"></a>4.10数据同步</h2><blockquote>
<p>elasticsearch中的酒店数据来自于mysql数据库，因此mysql数据发生改变时，elasticsearch也必须跟着改变，这个就是elasticsearch与mysql之间的<strong>数据同步</strong>。</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210723214758392.png" alt="image-20210723214758392" style="zoom:50%;" />
</blockquote>
<h3 id="①数据同步方案"><a href="#①数据同步方案" class="headerlink" title="①数据同步方案"></a>①数据同步方案</h3><p>常见的数据同步方案有三种：</p>
<ul>
<li>同步调用</li>
<li>异步通知</li>
<li>监听binlog</li>
</ul>
<p><strong>（1）同步调用</strong></p>
<p>方案一：同步调用</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210723214931869.png" alt="image-20210723214931869" style="zoom: 50%;" />

<p>基本步骤如下：</p>
<ul>
<li>hotel-demo对外提供接口，用来修改elasticsearch中的数据</li>
<li>酒店管理服务在完成数据库操作后，直接调用hotel-demo提供的接口，</li>
</ul>
<p><strong>（2）异步通知</strong></p>
<p>方案二：异步通知</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210723215140735.png" alt="image-20210723215140735" style="zoom:50%;" />



<p>流程如下：</p>
<ul>
<li>hotel-admin对mysql数据库数据完成增、删、改后，发送MQ消息</li>
<li>hotel-demo监听MQ，接收到消息后完成elasticsearch数据修改</li>
</ul>
<p><strong>（3）监听binlog</strong></p>
<p>方案三：监听binlog</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210723215518541.png" alt="image-20210723215518541" style="zoom:50%;" />

<p>流程如下：</p>
<ul>
<li>给mysql开启binlog功能</li>
<li>mysql完成增、删、改操作都会记录在binlog中</li>
<li>hotel-demo基于canal监听binlog变化，实时更新elasticsearch中的内容</li>
</ul>
<p><mark>总结：</mark></p>
<p><em><u>方式一：同步调用</u></em></p>
<ul>
<li>优点：实现简单，粗暴</li>
<li>缺点：业务耦合度高</li>
</ul>
<p><em><u>方式二：异步通知</u></em></p>
<ul>
<li>优点：低耦合，实现难度一般</li>
<li>缺点：依赖mq的可靠性</li>
</ul>
<p><em><u>方式三：监听binlog</u></em></p>
<ul>
<li>优点：完全解除服务间耦合</li>
<li>缺点：开启binlog增加数据库负担、实现复杂度高</li>
</ul>
<hr>
<h3 id="②实现数据同步案例"><a href="#②实现数据同步案例" class="headerlink" title="②实现数据同步案例"></a>②实现数据同步案例</h3><p>在案例中我们使用方案二，利用学过的RabbitMQ消息队列异步地进行数据同步：</p>
<p>在酒店管理的微服务中修改数据库后发送消息到消息队列中，</p>
<p>酒店搜索服务接收消息，并完成数据同步（修改操作可以用全量修改，当做新增文档处理）</p>
<hr>
<h2 id="4-11ES集群"><a href="#4-11ES集群" class="headerlink" title="4.11ES集群"></a>4.11ES集群</h2><h3 id="①ES集群概念"><a href="#①ES集群概念" class="headerlink" title="①ES集群概念"></a>①ES集群概念</h3><blockquote>
<p>单机的elasticsearch做数据存储，必然面临两个问题：海量数据存储问题、单点故障问题。</p>
<ul>
<li>海量数据存储问题：将索引库从逻辑上拆分为N个分片（shard），存储到多个节点</li>
<li>单点故障问题：将分片数据在不同节点备份（replica ）</li>
</ul>
</blockquote>
<p><strong>（1）ES集群相关概念</strong>:</p>
<ul>
<li><p>集群（cluster）：一组拥有共同的 cluster name 的 节点。</p>
</li>
<li><p><font color="red">节点（node)</font>   ：集群中的一个 Elasticearch 实例</p>
</li>
<li><p><font color="red">分片（shard）</font>：索引可以被拆分为不同的部分进行存储，称为分片。在集群环境下，一个索引的不同分片可以拆分到不同的节点中</p>
<p>解决问题：数据量太大，单点存储量有限的问题。</p>
<img src="/img/SpringCloudAlibaba.assets/image-20200104124440086-5602723.png" alt="image-20200104124440086" style="zoom:50%;" />

<blockquote>
<p>此处，我们把数据分成3片：shard0、shard1、shard2</p>
</blockquote>
</li>
<li><p>主分片（Primary shard）：相对于副本分片的定义。</p>
</li>
<li><p>副本分片（Replica shard）每个主分片可以有一个或者多个副本，数据和主分片一样。</p>
</li>
</ul>
<p><strong>（2）ES的集群数据备份：</strong>	</p>
<p>数据备份可以保证高可用，但是每个分片备份一份，所需要的节点数量就会翻一倍，成本实在是太高了！</p>
<p>为了在高可用和成本间寻求平衡，我们可以这样做：</p>
<ul>
<li>首先对数据分片，存储到不同节点</li>
<li>然后对每个分片进行备份，放到对方节点，完成互相备份</li>
</ul>
<p>这样可以大大减少所需要的服务节点数量，如图，我们以3分片，每个分片备份一份为例：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20200104124551912.png" alt="image-20200104124551912" style="zoom:50%;" />

<p>现在，每个分片都有1个备份，存储在3个节点：</p>
<ul>
<li>node0：保存了分片0和1</li>
<li>node1：保存了分片0和2</li>
<li>node2：保存了分片1和2</li>
</ul>
<hr>
<h3 id="②搭建ES集群"><a href="#②搭建ES集群" class="headerlink" title="②搭建ES集群"></a>②搭建ES集群</h3><hr>
<h3 id="③集群脑裂问题"><a href="#③集群脑裂问题" class="headerlink" title="③集群脑裂问题"></a>③集群脑裂问题</h3><p><strong>（1）集群职责划分</strong></p>
<p>elasticsearch中集群节点有不同的职责划分：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210723223008967.png" alt="image-20210723223008967" style="zoom:50%;" />



<p><em><u>默认情况下，集群中的任何一个节点都同时具备上述四种角色。</u></em></p>
<p>但是真实的集群一定要将集群职责分离：</p>
<ul>
<li>master节点：对CPU要求高，但是内存要求第</li>
<li>data节点：对CPU和内存要求都高</li>
<li>coordinating节点：对网络带宽、CPU要求高</li>
<li>ingest不常用，一般不予考虑</li>
</ul>
<p>职责分离可以让我们根据不同节点的需求分配不同的硬件去部署。而且避免业务之间的互相干扰。</p>
<p>一个典型的es集群职责划分如图：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210723223629142.png" alt="image-20210723223629142" style="zoom:50%;" />

<p><strong>（2）集群脑裂问题</strong></p>
<p>脑裂是因为集群中的节点失联导致的。</p>
<p>例如一个集群中，主节点与其它节点失联：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210723223804995.png" alt="image-20210723223804995" style="zoom:40%;" />

<p>此时，node2和node3认为node1宕机，就会重新选主：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210723223845754.png" alt="image-20210723223845754" style="zoom:40%;" />

<p>当node3当选后，集群继续对外提供服务，node2和node3自成集群，node1自成集群，两个集群数据不同步，出现数据差异。</p>
<p>当网络恢复后，因为集群中有两个master节点，集群状态的不一致，出现脑裂的情况：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210723224000555.png" alt="image-20210723224000555" style="zoom:40%;" />



<p>解决脑裂的方案是，要求选票超过 ( eligible节点数量 + 1 ）&#x2F; 2 才能当选为主，因此eligible节点数量最好是奇数。对应配置项是discovery.zen.minimum_master_nodes，在es7.0以后，已经成为默认配置，因此一般不会发生脑裂问题</p>
<p>例如：3个节点形成的集群，选票必须超过 （3 + 1） &#x2F; 2 ，也就是2票。node3得到node2和node3的选票，当选为主。node1只有自己1票，没有当选。集群中依然只有1个主节点，没有出现脑裂。</p>
<p><mark>总结：</mark></p>
<p><em><u>master eligible节点的作用是什么？</u></em></p>
<ul>
<li>参与集群选主</li>
<li>主节点可以管理集群状态、管理分片信息、处理创建和删除索引库的请求</li>
</ul>
<p><em><u>data节点的作用是什么？</u></em></p>
<ul>
<li>数据的CRUD</li>
</ul>
<p><u><em>coordinator节点的作用是什么？</em></u></p>
<ul>
<li><p>路由请求到其它节点</p>
</li>
<li><p>合并查询到的结果，返回给用户</p>
</li>
</ul>
<hr>
<h3 id="④集群分布式存储"><a href="#④集群分布式存储" class="headerlink" title="④集群分布式存储"></a>④集群分布式存储</h3><blockquote>
<p>当新增文档时，应该保存到不同分片，保证数据均衡，那么coordinating node如何确定数据该存储到哪个分片呢？</p>
</blockquote>
<p><strong>分片存储原理：</strong></p>
<p>elasticsearch会通过hash算法来计算文档应该存储到哪个分片：</p>
<p><img src="/img/SpringCloudAlibaba.assets/image-20210723224354904.png" alt="image-20210723224354904"></p>
<p>说明：</p>
<ul>
<li>_routing默认是文档的id</li>
<li>算法与分片数量有关，因此索引库一旦创建，分片数量不能修改！</li>
</ul>
<p>新增文档的流程如下：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210723225436084.png" alt="image-20210723225436084" style="zoom:50%;" />



<p>解读：</p>
<ul>
<li>1）新增一个id&#x3D;1的文档</li>
<li>2）对id做hash运算，假如得到的是2，则应该存储到shard-2</li>
<li>3）shard-2的主分片在node3节点，将数据路由到node3</li>
<li>4）保存文档</li>
<li>5）同步给shard-2的副本replica-2，在node2节点</li>
<li>6）返回结果给coordinating-node节点</li>
</ul>
<hr>
<h3 id="⑤集群分布式查询"><a href="#⑤集群分布式查询" class="headerlink" title="⑤集群分布式查询"></a>⑤集群分布式查询</h3><p>elasticsearch的查询分成两个阶段：</p>
<ul>
<li><p>scatter phase：分散阶段，coordinating node会把请求分发到每一个分片</p>
</li>
<li><p>gather phase：聚集阶段，coordinating node汇总data node的搜索结果，并处理为最终结果集返回给用户</p>
</li>
</ul>
<img src="/img/SpringCloudAlibaba.assets/image-20210723225809848.png" alt="image-20210723225809848" style="zoom:50%;" />

<hr>
<h3 id="⑥集群故障转移"><a href="#⑥集群故障转移" class="headerlink" title="⑥集群故障转移"></a>⑥集群故障转移</h3><p>集群的master节点会监控集群中的节点状态，如果发现有节点宕机，会立即将宕机节点的分片数据迁移到其它节点，确保数据安全，这个叫做故障转移。</p>
<p>1）例如一个集群结构如图：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210723225945963.png" alt="image-20210723225945963" style="zoom:50%;" />

<p>现在，node1是主节点，其它两个节点是从节点。</p>
<p>2）突然，node1发生了故障：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210723230020574.png" alt="image-20210723230020574" style="zoom:50%;" />



<p>宕机后的第一件事，需要重新选主，例如选中了node2：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210723230055974.png" alt="image-20210723230055974" style="zoom:50%;" />



<p>node2成为主节点后，会检测集群监控状态，发现：shard-1、shard-0没有副本节点。因此需要将node1上的数据迁移到node2、node3：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210723230216642.png" alt="image-20210723230216642" style="zoom:50%;" />

<hr>
<h1 id="二、高级篇"><a href="#二、高级篇" class="headerlink" title="二、高级篇"></a>二、高级篇</h1><h1 id="5-微服务保护Sentinel"><a href="#5-微服务保护Sentinel" class="headerlink" title="5.微服务保护Sentinel"></a>5.微服务保护Sentinel</h1><h2 id="5-1初识Sentinel"><a href="#5-1初识Sentinel" class="headerlink" title="5.1初识Sentinel"></a>5.1初识Sentinel</h2><h3 id="①雪崩问题及解决方案"><a href="#①雪崩问题及解决方案" class="headerlink" title="①雪崩问题及解决方案"></a>①雪崩问题及解决方案</h3><blockquote>
<p>QPS:一秒钟的访问线程数</p>
</blockquote>
<p><strong>（1）雪崩问题</strong></p>
<p><em><u>微服务调用链路中的某个服务故障，引起整个链路中的所有微服务都不可用，这就是雪崩。</u></em></p>
<p>微服务中，服务间调用关系错综复杂，一个微服务往往依赖于多个其它微服务。如果服务提供者A发生了故障，当前的应用的部分业务因为依赖于服务A，因此也会被阻塞。此时，其它不依赖于服务A的业务似乎不受影响。但是，依赖服务A的业务请求被阻塞，用户不会得到响应，则tomcat的这个线程不会释放，于是越来越多的用户请求到来，越来越多的线程会阻塞。服务器支持的线程和并发数有限，请求一直阻塞，会导致服务器资源耗尽，从而导致所有其它服务都不可用，那么当前服务也就不可用了。那么，依赖于当前服务的其它服务随着时间的推移，最终也都会变的不可用，形成级联失败，雪崩就发生了。</p>
<img src="/img/SpringCloudAlibaba.assets/image-20230120164924593.png" alt="image-20230120164924593" style="zoom:50%;" />

<p><strong>（2）解决方案</strong></p>
<p><em><u>解决雪崩问题的常见解决方法有四种：</u></em></p>
<ul>
<li><mark>1）超时处理：</mark></li>
</ul>
<p>设定超时时间，请求超过一定时间没有响应就返回错误信息，不会无休止等待</p>
<img src="/img/SpringCloudAlibaba.assets/image-20230120165055775.png" alt="image-20230120165055775" style="zoom:50%;" />

<ul>
<li><mark>2）仓壁模式：</mark></li>
</ul>
<p>仓壁模式来源于船舱的设计：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210715172946352.png" alt="image-20210715172946352" style="zoom:50%;" />

<p>船舱都会被隔板分离为多个独立空间，当船体破损时，只会导致部分空间进入，将故障控制在一定范围内，避免整个船体都被淹没。</p>
<p>于此类似，我们可以限定每个业务能使用的线程数，避免耗尽整个tomcat的资源，因此也叫线程隔离。</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210715173215243.png" alt="image-20210715173215243" style="zoom:50%;" />

<ul>
<li><mark>3）断路器：</mark></li>
</ul>
<p>断路器模式：由<strong>断路器</strong>统计业务执行的异常比例，如果超出阈值则会<strong>熔断</strong>该业务，拦截访问该业务的一切请求。</p>
<p>断路器会统计访问某个服务的请求数量及异常比例，当发现访问服务D的请求<strong>异常比例过高</strong>时，认为服务D有导致雪崩的风险，<strong>会拦截访问服务D的一切请求，形成熔断：</strong></p>
<img src="/img/SpringCloudAlibaba.assets/image-20210715173428073.png" alt="image-20210715173428073" style="zoom:50%;" />

<ul>
<li><mark>4）限流：</mark></li>
</ul>
<p><strong>流量控制</strong>：限制业务访问的QPS，避免服务因流量的突增而故障。</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210715173555158.png" alt="image-20210715173555158" style="zoom:40%;" />



<p><mark>总结：</mark></p>
<p><em><u>什么是雪崩问题？</u></em></p>
<ul>
<li>微服务之间相互调用，因为调用链中的一个服务故障，引起整个链路都无法访问的情况。</li>
</ul>
<p><em><u>四种解决措施间的关系？</u></em></p>
<ul>
<li><p><strong>限流</strong>是对服务的保护，避免因瞬间高并发流量而导致服务故障，进而避免雪崩。是一种<strong>预防</strong>措施。</p>
</li>
<li><p><strong>超时处理、线程隔离、降级熔断</strong>是在部分服务故障时，将故障控制在一定范围，避免雪崩。是一种<strong>补救</strong>措施。</p>
</li>
</ul>
<hr>
<h3 id="②服务保护技术对比"><a href="#②服务保护技术对比" class="headerlink" title="②服务保护技术对比"></a>②服务保护技术对比</h3><p>在SpringCloud当中支持多种服务保护技术：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix">Netflix Hystrix</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel">Sentinel</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/resilience4j/resilience4j">Resilience4J</a></li>
</ul>
<p>早期比较流行的是Hystrix框架，但目前国内实用最广泛的还是阿里巴巴的Sentinel框架，这里我们做下对比：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20230120170921533.png" alt="image-20230120170921533" style="zoom: 40%;" />

<hr>
<h3 id="③Sentinel介绍与安装"><a href="#③Sentinel介绍与安装" class="headerlink" title="③Sentinel介绍与安装"></a>③Sentinel介绍与安装</h3><p><strong>（1）介绍</strong></p>
<p>Sentinel是阿里巴巴开源的一款微服务流量控制组件。官网地址：<a target="_blank" rel="noopener" href="https://sentinelguard.io/zh-cn/index.html">https://sentinelguard.io/zh-cn/index.html</a></p>
<p>Sentinel 具有以下特征:</p>
<ul>
<li><p><strong>丰富的应用场景</strong>：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</p>
</li>
<li><p><strong>完备的实时监控</strong>：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</p>
</li>
<li><p><strong>广泛的开源生态</strong>：Sentinel 提供开箱即用的与其它开源框架&#x2F;库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</p>
</li>
<li><p><strong>完善的</strong> <strong>SPI</strong> <strong>扩展点</strong>：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</p>
</li>
</ul>
<p><strong>（2）安装：</strong></p>
<p>sentinel官方提供了UI控制台，方便我们对系统做限流设置。可以在<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/releases">GitHub</a>下载。</p>
<p>其控制台是一个springboot项目，因此对下载后的jar包打开cmd执行<code>java -jar xxx.jar</code>命令就可运行项目，其默认端口号是8080，利用浏览器访问即可来到UI界面。<mark>注意刚进去是没有任何显示的，必须执行后面的微服务整合Sentinel操作！</mark></p>
<p>若要修改其他配置信息，通过命令行添加运行参数即可：<code>--xxx.xxx=xxx</code></p>
<table>
<thead>
<tr>
<th><strong>配置项</strong></th>
<th><strong>默认值</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>server.port</td>
<td>8080</td>
<td>服务端口</td>
</tr>
<tr>
<td>sentinel.dashboard.auth.username</td>
<td>sentinel</td>
<td>设置用户名（默认sentinel）</td>
</tr>
<tr>
<td>sentinel.dashboard.auth.password</td>
<td>sentinel</td>
<td>设置密码（默认sentinel）</td>
</tr>
</tbody></table>
<hr>
<h3 id="④微服务整合Sentinel"><a href="#④微服务整合Sentinel" class="headerlink" title="④微服务整合Sentinel"></a>④微服务整合Sentinel</h3><p>我们在order-service中整合sentinel，并连接sentinel的控制台，步骤如下：</p>
<p><strong>（1）引入sentinel依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--sentinel--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>（2）配置控制台</strong></p>
<p>修改application.yaml文件，添加下面内容：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8088</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span> </span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span></span><br></pre></td></tr></table></figure>



<p><strong>（3）访问order-service的任意端点</strong></p>
<p>打开浏览器，访问该服务的任意接口，这样才能触发sentinel的监控。</p>
<p>然后再访问sentinel的控制台，查看效果：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210715191241799.png" alt="image-20210715191241799" style="zoom: 33%;" />

<hr>
<h2 id="5-2流量控制"><a href="#5-2流量控制" class="headerlink" title="5.2流量控制"></a>5.2流量控制</h2><blockquote>
<p>雪崩问题虽然有四种方案，但是限流是避免服务因突发的流量而发生故障，是对微服务雪崩问题的预防。我们先学习这种模式。</p>
</blockquote>
<h3 id="①簇点链路"><a href="#①簇点链路" class="headerlink" title="①簇点链路"></a>①簇点链路</h3><p>当请求进入微服务时，首先会访问DispatcherServlet，然后进入Controller、Service、Mapper，这样的一个调用链就叫做<strong>簇点链路</strong>。簇点链路中被监控的每一个接口就是一个<strong>资源</strong>。</p>
<p>默认情况下sentinel会监控SpringMVC的每一个端点（Endpoint，也就是controller中的方法），因此SpringMVC的每一个端点（Endpoint）就是调用链路中的一个资源。</p>
<p>例如，我们刚才访问的order-service中的OrderController中的端点：&#x2F;order&#x2F;{orderId}</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210715191757319.png" alt="image-20210715191757319" style="zoom:50%;" />



<p>流控、熔断等都是针对簇点链路中的资源来设置的，因此我们可以点击对应资源后面的按钮来设置规则：</p>
<ul>
<li>流控：流量控制</li>
<li>降级：降级熔断</li>
<li>热点：热点参数限流，是限流的一种</li>
<li>授权：请求的权限控制</li>
</ul>
<hr>
<h3 id="②流控规则"><a href="#②流控规则" class="headerlink" title="②流控规则"></a>②流控规则</h3><p>点击资源&#x2F;order&#x2F;{orderId}后面的流控按钮，就可以弹出表单。</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210715191757319-16746177857553.png" alt="image-20210715191757319" style="zoom:50%;" />

<p>表单中可以填写限流规则，如下：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210715192010657.png" alt="image-20210715192010657" style="zoom:50%;" />

<p>其含义是限制 &#x2F;order&#x2F;{orderId}这个资源的单机QPS为1，即每秒只允许1次请求，超出的请求会被拦截并报错。</p>
<hr>
<h3 id="③流控模式"><a href="#③流控模式" class="headerlink" title="③流控模式"></a>③流控模式</h3><p>在添加限流规则时，点击高级选项，可以选择三种<strong>流控模式</strong>：</p>
<ul>
<li><strong>直接</strong>：统计当前资源的请求，触发阈值时对当前资源直接限流，也是默认的模式</li>
<li><strong>关联</strong>：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流</li>
<li><strong>链路</strong>：统计从指定链路访问到本资源的请求，触发阈值时，对指定链路限流</li>
</ul>
<img src="/img/SpringCloudAlibaba.assets/image-20210715201827886.png" alt="image-20210715201827886" style="zoom:50%;" />



<p><mark>②中的测试的就是直接模式。</mark></p>
<h4 id="（1）关联模式"><a href="#（1）关联模式" class="headerlink" title="（1）关联模式"></a>（1）关联模式</h4><p><strong>关联模式</strong>：统计与当前资源相关的另一个资源，触发（QPS或线程数）阈值时，对当前资源限流</p>
<p><strong>配置规则</strong>：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210715202540786.png" alt="image-20210715202540786" style="zoom:50%;" />

<p><strong>语法说明</strong>：当&#x2F;write资源访问量触发阈值时，就会对&#x2F;read资源限流，避免影响&#x2F;write资源。</p>
<p><strong>使用场景</strong>：比如用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁，产生竞争。业务需求是优先支付和更新订单的业务，因此当修改订单业务触发阈值时，需要对查询订单业务限流。</p>
<p><strong>需求说明</strong>：</p>
<ul>
<li><p>在OrderController新建两个端点：&#x2F;order&#x2F;query和&#x2F;order&#x2F;update，无需实现业务</p>
</li>
<li><p>配置流控规则，当&#x2F;order&#x2F; update资源被访问的QPS超过5时，对&#x2F;order&#x2F;query请求限流</p>
</li>
</ul>
<p><strong>1）定义&#x2F;order&#x2F;query端点，模拟订单查询</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/query&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">queryOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;查询订单成功&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2）定义&#x2F;order&#x2F;update端点，模拟订单更新</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/update&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">updateOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;更新订单成功&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启服务，查看sentinel控制台的簇点链路：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716101805951.png" alt="image-20210716101805951" style="zoom:50%;" />



<p><strong>3）配置流控规则</strong></p>
<p>对哪个端点限流，就点击哪个端点后面的按钮。我们是对订单查询&#x2F;order&#x2F;query限流，因此点击它后面的按钮：</p>
<p><img src="/img/SpringCloudAlibaba.assets/image-20210716101934499.png" alt="image-20210716101934499"></p>
<p>在表单中填写流控规则：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716102103814.png" alt="image-20210716102103814" style="zoom:50%;" />



<p><strong>4）Jmeter压测</strong></p>
<p>选择《流控模式-关联》：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716102416266.png" alt="image-20210716102416266" style="zoom:50%;" />

<p>可以看到1000个用户，100秒，因此QPS为10，超过了我们设定的阈值：5</p>
<p>查看http请求：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716102532554.png" alt="image-20210716102532554" style="zoom:50%;" />

<p>请求的目标是&#x2F;order&#x2F;update，这样这个断点就会触发阈值。</p>
<p>但限流的目标是&#x2F;order&#x2F;query，我们在浏览器访问，可以发现：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716102636030.png" alt="image-20210716102636030" style="zoom:50%;" />

<p>确实被限流了。</p>
<p><mark>总结：</mark></p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716103143002.png" alt="image-20210716103143002" style="zoom:50%;" />

<hr>
<h4 id="（2）链路模式"><a href="#（2）链路模式" class="headerlink" title="（2）链路模式"></a>（2）链路模式</h4><p><strong>链路模式</strong>：只针对从指定链路访问到本资源的请求做统计，判断是否超过阈值。</p>
<p><strong>配置示例</strong>：</p>
<p>例如有两条请求链路：</p>
<ul>
<li><p>&#x2F;test1 –&gt; &#x2F;common</p>
</li>
<li><p>&#x2F;test2 –&gt; &#x2F;common</p>
</li>
</ul>
<p>如果只希望统计从&#x2F;test2进入到&#x2F;common的请求，则可以这样配置：</p>
<p><img src="/img/SpringCloudAlibaba.assets/image-20210716103536346.png" alt="image-20210716103536346"></p>
<p><strong>实战案例</strong></p>
<p>需求：有查询订单和创建订单业务，两者都需要查询商品。针对从查询订单进入到查询商品的请求统计，并设置限流。</p>
<p>步骤：</p>
<ol>
<li><p>在OrderService中添加一个queryGoods方法，不用实现业务</p>
</li>
<li><p>在OrderController中，改造&#x2F;order&#x2F;query端点，调用OrderService中的queryGoods方法</p>
</li>
<li><p>在OrderController中添加一个&#x2F;order&#x2F;save的端点，调用OrderService的queryGoods方法</p>
</li>
<li><p>给queryGoods设置限流规则，从&#x2F;order&#x2F;query进入queryGoods的方法限制QPS必须小于2</p>
</li>
</ol>
<p>实现：</p>
<p><strong>1）添加查询商品方法</strong></p>
<p>在order-service服务中，给OrderService类添加一个queryGoods方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryGoods</span><span class="params">()</span>&#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;查询商品&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>2）查询订单时，查询商品</strong></p>
<p>在order-service的OrderController中，修改&#x2F;order&#x2F;query端点的业务逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/query&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">queryOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 查询商品</span></span><br><span class="line">    orderService.queryGoods();</span><br><span class="line">    <span class="comment">// 查询订单</span></span><br><span class="line">    System.out.println(<span class="string">&quot;查询订单&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;查询订单成功&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>3）新增订单，查询商品</strong></p>
<p>在order-service的OrderController中，修改&#x2F;order&#x2F;save端点，模拟新增订单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">saveOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 查询商品</span></span><br><span class="line">    orderService.queryGoods();</span><br><span class="line">    <span class="comment">// 查询订单</span></span><br><span class="line">    System.err.println(<span class="string">&quot;新增订单&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;新增订单成功&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>4）给查询商品添加资源标记</strong></p>
<p><em><u>默认情况下，Service中的方法是不被Sentinel监控的，需要我们自己通过<code>@SentinelResource</code>注解来标记要监控的方法。</u></em></p>
<p>给OrderService的queryGoods方法添加@SentinelResource注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SentinelResource(&quot;goods&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryGoods</span><span class="params">()</span>&#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;查询商品&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>链路模式中，是对不同来源的两个链路做监控。但是sentinel默认会给进入SpringMVC的所有请求设置同一个root资源，会导致链路模式失效。</p>
<p>我们需要关闭这种对SpringMVC的资源聚合，修改order-service服务的application.yml文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">web-context-unify:</span> <span class="literal">false</span> <span class="comment"># 关闭context整合</span></span><br></pre></td></tr></table></figure>

<p>重启服务，访问&#x2F;order&#x2F;query和&#x2F;order&#x2F;save，可以查看到sentinel的簇点链路规则中，出现了新的资源：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716105227163.png" alt="image-20210716105227163" style="zoom:50%;" />



<p><strong>5）添加流控规则</strong></p>
<p>点击goods资源后面的流控按钮，在弹出的表单中填写下面信息：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716105408723.png" alt="image-20210716105408723" style="zoom:50%;" />



<p>只统计从&#x2F;order&#x2F;query进入&#x2F;goods的资源，QPS阈值为2，超出则被限流。</p>
<p><strong>6）Jmeter测试</strong></p>
<p>选择《流控模式-链路》：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716105612312.png" alt="image-20210716105612312" style="zoom:50%;" />

<p>可以看到这里200个用户，50秒内发完，QPS为4，超过了我们设定的阈值2</p>
<p>一个http请求是访问&#x2F;order&#x2F;save：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716105812789.png" alt="image-20210716105812789" style="zoom:50%;" />

<p>运行的结果：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716110027064.png" alt="image-20210716110027064" style="zoom:50%;" />

<p>完全不受影响。</p>
<p>另一个是访问&#x2F;order&#x2F;query：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716105855951.png" alt="image-20210716105855951" style="zoom:50%;" />

<p>运行结果：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716105956401.png" alt="image-20210716105956401" style="zoom:50%;" />

<p>每次只有2个通过。</p>
<p><mark>总结：</mark></p>
<p><em><u>流控模式有哪些？</u></em></p>
<ul>
<li><p>直接：对当前资源限流</p>
</li>
<li><p>关联：高优先级资源触发阈值，对低优先级资源限流。</p>
</li>
<li><p>链路：阈值统计时，只统计从指定资源进入当前资源的请求，是对请求来源的限流</p>
</li>
</ul>
<hr>
<h3 id="④流控效果"><a href="#④流控效果" class="headerlink" title="④流控效果"></a>④流控效果</h3><p>在流控的高级选项中，还有一个流控效果选项：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716110225104.png" alt="image-20210716110225104" style="zoom:50%;" />

<p>流控效果是指请求达到流控阈值时应该采取的措施，包括三种：</p>
<ul>
<li><p><strong>快速失败</strong>：达到阈值后，新的请求会被立即拒绝并抛出FlowException异常。<strong>是默认的处理方式。</strong></p>
</li>
<li><p><strong>warm up</strong>：预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化，从一个较小值逐渐增加到最大阈值。</p>
</li>
<li><p><strong>排队等待</strong>：让所有的请求按照先后次序排队执行，两个请求的间隔不能小于指定时长</p>
</li>
</ul>
<h4 id="（1）Warm-Up"><a href="#（1）Warm-Up" class="headerlink" title="（1）Warm Up"></a>（1）Warm Up</h4><blockquote>
<p>阈值一般是一个微服务能承担的最大QPS，但是一个服务刚刚启动时，一切资源尚未初始化（<strong>冷启动</strong>），如果直接将QPS跑到最大值，可能导致服务瞬间宕机。</p>
</blockquote>
<p>warm up也叫<strong>预热模式</strong>，是应对服务冷启动的一种方案。请求阈值初始值是 maxThreshold &#x2F; coldFactor，持续指定时长后，逐渐提高到maxThreshold值。而coldFactor的默认值是3.</p>
<p>例如，我设置QPS的maxThreshold为10，预热时间为5秒，那么初始阈值就是 10 &#x2F; 3 ，也就是3，然后在5秒后逐渐增长到10.</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716110629796.png" alt="image-20210716110629796" style="zoom:50%;" />



<p><strong>案例</strong></p>
<p>需求：给&#x2F;order&#x2F;{orderId}这个资源设置限流，最大QPS为10，利用warm up效果，预热时长为5秒</p>
<p><strong>1）配置流控规则：</strong></p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716111012387.png" alt="image-20210716111012387" style="zoom:50%;" />



<p><strong>2）Jmeter测试</strong></p>
<p>选择《流控效果，warm up》：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716111136699.png" alt="image-20210716111136699" style="zoom:50%;" />

<p>QPS为10.</p>
<p>刚刚启动时，大部分请求失败，成功的只有3个，说明QPS被限定在3：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716111303701.png" alt="image-20210716111303701" style="zoom:50%;" />

<p>随着时间推移，成功比例越来越高：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716111404717.png" alt="image-20210716111404717" style="zoom:50%;" />



<p>到Sentinel控制台查看实时监控：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716111526480.png" alt="image-20210716111526480" style="zoom:50%;" />

<p>一段时间后：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716111658541.png" alt="image-20210716111658541" style="zoom:50%;" />

<hr>
<h4 id="（2）排队等待"><a href="#（2）排队等待" class="headerlink" title="（2）排队等待"></a>（2）排队等待</h4><blockquote>
<p>当请求超过QPS阈值时，快速失败和warm up 会拒绝新的请求并抛出异常。</p>
</blockquote>
<p>而排队等待则是让所有请求进入一个队列中，然后按照阈值允许的时间间隔依次执行。后来的请求必须等待前面执行完成，如果请求预期的等待时间超出最大时长，则会被拒绝。</p>
<p><strong>工作原理</strong></p>
<p>例如：QPS &#x3D; 5，意味着每200ms处理一个队列中的请求；timeout &#x3D; 2000，意味着<strong>预期等待时长</strong>超过2000ms的请求会被拒绝并抛出异常。</p>
<p>那什么叫做预期等待时长呢？</p>
<p>比如现在一下子来了12 个请求，因为每200ms执行一个请求，那么：</p>
<ul>
<li>第6个请求的<strong>预期等待时长</strong> &#x3D;  200 * （6 - 1） &#x3D; 1000ms</li>
<li>第12个请求的预期等待时长 &#x3D; 200 * （12-1） &#x3D; 2200ms</li>
</ul>
<p>现在，第1秒同时接收到10个请求，但第2秒只有1个请求，此时QPS的曲线这样的：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716113147176.png" alt="image-20210716113147176" style="zoom:50%;" />

<p>如果使用队列模式做流控，所有进入的请求都要排队，以固定的200ms的间隔执行，QPS会变的很平滑：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716113426524.png" alt="image-20210716113426524" style="zoom:50%;" />



<p>平滑的QPS曲线，对于服务器来说是更友好的。</p>
<p><strong>案例</strong></p>
<p>需求：给&#x2F;order&#x2F;{orderId}这个资源设置限流，最大QPS为10，利用排队的流控效果，超时时长设置为5s</p>
<p><strong>1）添加流控规则</strong></p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716114048918.png" alt="image-20210716114048918" style="zoom:50%;" />



<p><strong>2）Jmeter测试</strong></p>
<p>选择《流控效果，队列》：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716114243558.png" alt="image-20210716114243558" style="zoom:50%;" />

<p>QPS为15，已经超过了我们设定的10。</p>
<p>如果是之前的 快速失败、warmup模式，超出的请求应该会直接报错。</p>
<p>但是我们看看队列模式的运行结果：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716114429361.png" alt="image-20210716114429361" style="zoom:50%;" />

<p>全部都通过了。</p>
<p>再去sentinel查看实时监控的QPS曲线：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716114522935.png" alt="image-20210716114522935" style="zoom:50%;" />

<p>QPS非常平滑，一致保持在10，但是超出的请求没有被拒绝，而是放入队列。因此<strong>响应时间</strong>（等待时间）会越来越长。</p>
<p>当队列满了以后，才会有部分请求失败：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716114651137.png" alt="image-20210716114651137" style="zoom:50%;" />



<p><mark>总结：</mark></p>
<p>流控效果有哪些？</p>
<ul>
<li><p>快速失败：QPS超过阈值时，拒绝新的请求</p>
</li>
<li><p>warm up： QPS超过阈值时，拒绝新的请求；QPS阈值是逐渐提升的，可以避免冷启动时高并发导致服务宕机。</p>
</li>
<li><p>排队等待：请求会进入队列，按照阈值允许的时间间隔依次执行请求；如果请求预期等待时长大于超时时间，直接拒绝</p>
</li>
</ul>
<hr>
<h3 id="⑤热点参数限流"><a href="#⑤热点参数限流" class="headerlink" title="⑤热点参数限流"></a>⑤热点参数限流</h3><blockquote>
<p>之前的限流是统计访问某个资源的所有请求，判断是否超过QPS阈值。</p>
<p>而热点参数限流是<strong>分别统计参数值相同的请求</strong>，判断是否超过QPS阈值。</p>
</blockquote>
<h4 id="（1）全局参数限流"><a href="#（1）全局参数限流" class="headerlink" title="（1）全局参数限流"></a>（1）全局参数限流</h4><p>例如，一个根据id查询商品的接口：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716115014663.png" alt="image-20210716115014663" style="zoom:50%;" />

<p>访问&#x2F;goods&#x2F;{id}的请求中，id参数值会有变化，热点参数限流会根据参数值分别统计QPS，统计结果：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716115131463.png" alt="image-20210716115131463" style="zoom:50%;" />

<p>当id&#x3D;1的请求触发阈值被限流时，id值不为1的请求不受影响。</p>
<p>配置示例：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716115232426.png" alt="image-20210716115232426" style="zoom:50%;" />

<p>代表的含义是：对hot这个资源的0号参数（第一个参数）做统计，每1秒<strong>相同参数值</strong>的请求数不能超过5</p>
<hr>
<h4 id="（2）热点参数限流"><a href="#（2）热点参数限流" class="headerlink" title="（2）热点参数限流"></a>（2）热点参数限流</h4><p>刚才的配置中，对查询商品这个接口的所有商品一视同仁，QPS都限定为5.</p>
<p>而在实际开发中，可能部分商品是热点商品，例如秒杀商品，我们希望这部分商品的QPS限制与其它商品不一样，高一些。那就需要配置热点参数限流的高级选项了：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716115717523.png" alt="image-20210716115717523" style="zoom:50%;" />

<p>结合上一个配置，这里的含义是对0号的long类型参数限流，每1秒相同参数的QPS不能超过5，有两个例外：</p>
<ul>
<li><p>如果参数值是100，则每1秒允许的QPS为10</p>
</li>
<li><p>如果参数值是101，则每1秒允许的QPS为15</p>
</li>
</ul>
<p><mark>案例：</mark></p>
<ul>
<li><p>默认的热点参数规则是每1秒请求量不超过2</p>
</li>
<li><p>给102这个参数设置例外：每1秒请求量不超过4</p>
</li>
<li><p>给103这个参数设置例外：每1秒请求量不超过10</p>
</li>
</ul>
<p><strong>注意事项</strong>：热点参数限流对默认的SpringMVC资源无效，需要利用@SentinelResource注解标记资源</p>
<p><strong>1）标记资源</strong></p>
<p>给order-service中的OrderController中的&#x2F;order&#x2F;{orderId}资源添加注解：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716120033572.png" alt="image-20210716120033572" style="zoom:50%;" />



<p><strong>2）热点参数限流规则</strong></p>
<p>访问该接口，可以看到我们标记的hot资源出现了：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716120208509.png" alt="image-20210716120208509" style="zoom:50%;" />

<p>这里不要点击hot后面的按钮，页面有BUG</p>
<p>点击左侧菜单中<strong>热点规则</strong>菜单：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716120319009.png" alt="image-20210716120319009" style="zoom: 33%;" />

<p>点击新增，填写表单：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716120536714.png" alt="image-20210716120536714" style="zoom:50%;" />



<p><strong>3）Jmeter测试</strong></p>
<p>选择《热点参数限流 QPS1》：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716120754527.png" alt="image-20210716120754527" style="zoom: 50%;" />

<p>这里发起请求的QPS为5.</p>
<p>包含3个http请求：</p>
<p>普通参数，QPS阈值为2</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716120840501.png" alt="image-20210716120840501" style="zoom:50%;" />

<p>运行结果：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716121105567.png" alt="image-20210716121105567" style="zoom:50%;" />



<p>例外项，QPS阈值为4</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716120900365.png" alt="image-20210716120900365" style="zoom:50%;" />

<p>运行结果：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716121201630.png" alt="image-20210716121201630" style="zoom:50%;" />



<p>例外项，QPS阈值为10</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716120919131.png" alt="image-20210716120919131" style="zoom:50%;" />

<p>运行结果：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716121220305.png" alt="image-20210716121220305" style="zoom:50%;" />

<hr>
<h2 id="5-3隔离和降级"><a href="#5-3隔离和降级" class="headerlink" title="5.3隔离和降级"></a>5.3隔离和降级</h2><blockquote>
<p>限流是一种预防措施，虽然限流可以尽量避免因高并发而引起的服务故障，但服务还会因为其它原因而故障。</p>
<p>而要将这些故障控制在一定范围，避免雪崩，就要靠<strong>线程隔离</strong>（舱壁模式）和<strong>熔断降级</strong>手段了。</p>
</blockquote>
<p><strong>线程隔离</strong>之前讲到过：调用者在调用服务提供者时，给每个调用的请求分配独立线程池，出现故障时，最多消耗这个线程池内资源，避免把调用者的所有资源耗尽。</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210715173215243-167462050308053.png" alt="image-20210715173215243" style="zoom:50%;" />

<p><strong>熔断降级</strong>：是在调用方这边加入断路器，统计对服务提供者的调用，如果调用的失败比例过高，则熔断该业务，不允许访问该服务的提供者了。</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210715173428073-167462050308054.png" alt="image-20210715173428073" style="zoom:50%;" />

<p>可以看到，不管是线程隔离还是熔断降级，都是对<strong>客户端</strong>（调用方）的保护。需要在<strong>调用方</strong> 发起远程调用时做线程隔离、或者服务熔断。</p>
<p>而我们的微服务远程调用都是基于Feign来完成的，因此我们需要将Feign与Sentinel整合，在Feign里面实现线程隔离和服务熔断。</p>
<h3 id="①FeignClient整合Sentinel"><a href="#①FeignClient整合Sentinel" class="headerlink" title="①FeignClient整合Sentinel"></a>①FeignClient整合Sentinel</h3><blockquote>
<p>SpringCloud中，微服务调用远程调用都是通过Feign来实现的，因此做客户端保护必须整合Feign和Sentinel。</p>
</blockquote>
<p><strong>（1）修改配置文件，开启sentinel功能</strong></p>
<p>修改OrderService的application.yml文件，开启Feign的Sentinel功能：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启feign对sentinel的支持</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）编写失败降级业务逻辑</strong></p>
<p><em><u>业务失败后，不能直接报错，而应该返回用户一个友好提示或者默认结果，这个就是失败降级逻辑。</u></em></p>
<p>给FeignClient编写失败后的降级逻辑</p>
<p>①方式一：FallbackClass，无法对远程调用的异常做处理</p>
<p>②方式二：FallbackFactory，可以对远程调用的异常做处理，我们选择这种</p>
<p>这里我们演示方式二的失败降级处理。</p>
<p><strong>步骤一</strong>：在feing-api项目中定义类，实现FallbackFactory：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716122403502.png" alt="image-20210716122403502" style="zoom:50%;" />

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserClientFallbackFactory</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;UserClient&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserClient <span class="title function_">create</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserClient</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;查询用户异常&quot;</span>, throwable);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();			<span class="comment">//返回一个空对象</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>步骤二</strong>：在feing-api项目中的DefaultFeignConfiguration类中将UserClientFallbackFactory注册为一个Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> UserClientFallbackFactory <span class="title function_">userClientFallbackFactory</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserClientFallbackFactory</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤三</strong>：在feing-api项目中的UserClient接口中使用UserClientFallbackFactory：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;userservice&quot;, fallbackFactory = UserClientFallbackFactory.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>重启后，访问一次订单查询业务，然后查看sentinel控制台，可以看到新的簇点链路：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716123705780.png" alt="image-20210716123705780" style="zoom:50%;" />



<p><mark>总结：</mark></p>
<p><em><u>Sentinel支持的雪崩解决方案：</u></em></p>
<ul>
<li>线程隔离（仓壁模式）</li>
<li>降级熔断</li>
</ul>
<p><em><u>Feign整合Sentinel的步骤：</u></em></p>
<ul>
<li>在application.yml中配置：feign.sentienl.enable&#x3D;true</li>
<li>给FeignClient编写FallbackFactory并注册为Bean</li>
<li>将FallbackFactory配置到FeignClient</li>
</ul>
<hr>
<h3 id="②线程隔离（仓壁模式）"><a href="#②线程隔离（仓壁模式）" class="headerlink" title="②线程隔离（仓壁模式）"></a>②线程隔离（仓壁模式）</h3><h4 id="（1）线程隔离的两种方式："><a href="#（1）线程隔离的两种方式：" class="headerlink" title="（1）线程隔离的两种方式："></a>（1）线程隔离的两种方式：</h4><p>线程隔离有两种方式实现：</p>
<ul>
<li><p>线程池隔离</p>
</li>
<li><p>信号量隔离（Sentinel默认采用）</p>
</li>
</ul>
<p>如图：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716123036937.png" alt="image-20210716123036937" style="zoom:50%;" />



<p><strong>线程池隔离</strong>：给每个服务调用业务分配一个线程池，利用线程池本身实现隔离效果</p>
<p><strong>信号量隔离</strong>：不创建线程池，而是计数器模式，记录业务使用的线程数量，达到信号量上限时，禁止新的请求。</p>
<p>两者的优缺点：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716123240518.png" alt="image-20210716123240518" style="zoom: 40%;" />



<hr>
<h4 id="（2）Sentinel实现线程隔离"><a href="#（2）Sentinel实现线程隔离" class="headerlink" title="（2）Sentinel实现线程隔离"></a>（2）Sentinel实现线程隔离</h4><p><strong>用法说明</strong>：</p>
<p>在添加限流规则时，可以选择两种阈值类型：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716123411217.png" alt="image-20210716123411217" style="zoom:50%;" />

<ul>
<li><p>QPS：就是每秒的请求数，在快速入门中已经演示过</p>
</li>
<li><p>线程数：是该资源能使用用的tomcat线程数的最大值。也就是通过限制线程数量，实现<strong>线程隔离</strong>（舱壁模式）。</p>
</li>
</ul>
<p><a href="%E7%BB%99/order/%7BorderId%7D%E8%BF%99%E4%B8%AA%E8%B5%84%E6%BA%90%E6%B7%BB%E5%8A%A0%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81%EF%BC%8C%E8%A7%84%E5%88%99%E5%A6%82%E4%B8%8B%EF%BC%9A">^案例需求</a>: 给 order-service服务中的UserClient的查询用户接口设置流控规则，线程数不能超过 2。然后利用jemeter测试。</p>
<p><strong>1）配置隔离规则</strong></p>
<p>选择feign接口后面的流控按钮：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716123831992.png" alt="image-20210716123831992" style="zoom:50%;" />

<p>填写表单：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716123936844.png" alt="image-20210716123936844" style="zoom:50%;" />



<p><strong>2）Jmeter测试</strong></p>
<p>选择《阈值类型-线程数&lt;2》：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716124229894.png" alt="image-20210716124229894" style="zoom:50%;" />

<p>一次发生10个请求，有较大概率并发线程数超过2，而超出的请求会走之前定义的失败降级逻辑。</p>
<p>查看运行结果：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716124147820.png" alt="image-20210716124147820" style="zoom:50%;" />

<p>发现虽然结果都是通过了，不过部分请求得到的响应是降级返回的null信息。</p>
<p><mark>总结：</mark></p>
<p><em><u>线程隔离的两种手段是？</u></em></p>
<ul>
<li><p>信号量隔离</p>
</li>
<li><p>线程池隔离</p>
</li>
</ul>
<p><em><u>信号量隔离的特点是？</u></em></p>
<ul>
<li>基于计数器模式，简单，开销小</li>
</ul>
<p><em><u>线程池隔离的特点是？</u></em></p>
<ul>
<li>基于线程池模式，有额外开销，但隔离控制更强</li>
</ul>
<hr>
<h3 id="③熔断降级"><a href="#③熔断降级" class="headerlink" title="③熔断降级"></a>③熔断降级</h3><p>熔断降级是解决雪崩问题的重要手段。其思路是由<strong>断路器</strong>统计服务调用的异常比例、慢请求比例，如果超出阈值则会<strong>熔断</strong>该服务。即拦截访问该服务的一切请求；而当服务恢复时，断路器会放行访问该服务的请求。</p>
<p>断路器控制熔断和放行是通过状态机来完成的：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716130958518.png" alt="image-20210716130958518" style="zoom:50%;" />

<p>状态机包括三个状态：</p>
<ul>
<li>closed：关闭状态，断路器放行所有请求，并开始统计异常比例、慢请求比例。超过阈值则切换到open状态</li>
<li>open：打开状态，服务调用被<strong>熔断</strong>，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。Open状态5秒后会进入half-open状态</li>
<li>half-open：半开状态，放行一次请求，根据执行结果来判断接下来的操作。<ul>
<li>请求成功：则切换到closed状态</li>
<li>请求失败：则切换到open状态</li>
</ul>
</li>
</ul>
<p><u><em>断路器熔断策略有三种：慢调用、异常比例、异常数</em></u></p>
<h4 id="（1）慢调用"><a href="#（1）慢调用" class="headerlink" title="（1）慢调用"></a>（1）慢调用</h4><blockquote>
<p><strong>慢调用</strong>：业务的响应时长（RT）大于指定时长的请求认定为慢调用请求。在指定时间内，如果请求数量超过设定的最小数量，慢调用比例大于设定的阈值，则触发熔断。</p>
</blockquote>
<p>例如：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20230125142108736.png" alt="image-20230125142108736" style="zoom:50%;" />

<img src="/img/SpringCloudAlibaba.assets/image-20210716145934347.png" alt="image-20210716145934347" style="zoom:50%;" />

<p>解读：RT超过500ms的调用是慢调用，统计最近10000ms内的请求，如果请求量超过10次，并且慢调用比例不低于0.5，则触发熔断，熔断时长为5秒。然后进入half-open状态，放行一次请求做测试。</p>
<h4 id="（2）异常比例、异常数"><a href="#（2）异常比例、异常数" class="headerlink" title="（2）异常比例、异常数"></a>（2）异常比例、异常数</h4><blockquote>
<p><strong>异常比例或异常数</strong>：统计指定时间内的调用，如果调用次数超过指定请求数，并且出现异常的比例达到设定的比例阈值（或超过指定异常数），则触发熔断。</p>
</blockquote>
<p>例如，一个异常比例设置：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20230125142119690.png" alt="image-20230125142119690" style="zoom:50%;" />

<img src="/img/SpringCloudAlibaba.assets/image-20210716131430682.png" alt="image-20210716131430682" style="zoom:50%;" />

<p>解读：统计最近1000ms内的请求，如果请求量超过10次，并且异常比例不低于0.4，则触发熔断。</p>
<p>一个异常数设置：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716131522912.png" alt="image-20210716131522912" style="zoom:50%;" />

<p>解读：统计最近1000ms内的请求，如果请求量超过10次，并且异常比例不低于2次，则触发熔断。</p>
<hr>
<h2 id="5-4授权规则"><a href="#5-4授权规则" class="headerlink" title="5.4授权规则"></a>5.4授权规则</h2><blockquote>
<p>授权规则可以对请求方来源做判断和控制。</p>
</blockquote>
<h3 id="①授权规则"><a href="#①授权规则" class="headerlink" title="①授权规则"></a>①授权规则</h3><h4 id="（1）基本规则"><a href="#（1）基本规则" class="headerlink" title="（1）基本规则"></a>（1）基本规则</h4><p><em><u>授权规则可以对调用方的来源做控制，有白名单和黑名单两种方式。</u></em></p>
<ul>
<li><p>白名单：来源（origin）在白名单内的调用者允许访问</p>
</li>
<li><p>黑名单：来源（origin）在黑名单内的调用者不允许访问</p>
</li>
</ul>
<p>点击左侧菜单的授权，可以看到授权规则：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716152010750.png" alt="image-20210716152010750" style="zoom:50%;" />

<ul>
<li><p>资源名：就是受保护的资源，例如&#x2F;order&#x2F;{orderId}</p>
</li>
<li><p>流控应用：是来源者的名单，</p>
<ul>
<li>如果是勾选白名单，则名单中的来源被许可访问。</li>
<li>如果是勾选黑名单，则名单中的来源被禁止访问。</li>
</ul>
</li>
</ul>
<p>比如：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716152349191.png" alt="image-20210716152349191" style="zoom:50%;" />

<p>我们允许请求从gateway到order-service，不允许浏览器访问order-service，那么白名单中就要填写<strong>网关的来源名称（origin）</strong>。</p>
<h4 id="（2）如何获取origin"><a href="#（2）如何获取origin" class="headerlink" title="（2）如何获取origin"></a>（2）如何获取origin</h4><p>Sentinel是通过RequestOriginParser这个接口的parseOrigin来获取请求的来源的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RequestOriginParser</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从请求request对象中获取origin，获取方式自定义</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">parseOrigin</span><span class="params">(HttpServletRequest request)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的作用就是从request对象中，获取请求者的origin值并返回。</p>
<p>默认情况下，sentinel不管请求者从哪里来，返回值永远是default，也就是说一切请求的来源都被认为是一样的值default。</p>
<p>因此，我们需要自定义这个接口的实现，让<strong>不同的请求，返回不同的origin</strong>。</p>
<p><mark>这里我们用请求头中添加一个origin的请求头信息来确定不同的origin</mark></p>
<p>例如order-service服务中，我们定义一个RequestOriginParser的实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeaderOriginParser</span> <span class="keyword">implements</span> <span class="title class_">RequestOriginParser</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">parseOrigin</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求头</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">origin</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;origin&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.非空判断</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(origin)) &#123;</span><br><span class="line">            origin = <span class="string">&quot;blank&quot;</span>;		<span class="comment">//因为是白名单，所以当为空时这个origin的值随便设置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> origin;			<span class="comment">//返回origin，也就是流控应用的名称</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们会尝试从请求的请求头中获取origin值。</p>
<h4 id="（3）给网关添加请求头"><a href="#（3）给网关添加请求头" class="headerlink" title="（3）给网关添加请求头"></a>（3）给网关添加请求头</h4><p>既然获取请求origin的方式是从reques-header中获取origin值，我们必须让<strong>所有从gateway路由到微服务的请求都带上origin头</strong>。</p>
<p>这个需要利用之前学习的一个GatewayFilter来实现，AddRequestHeaderGatewayFilter。</p>
<p>修改gateway服务中的application.yml，添加一个defaultFilter：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=origin,gateway</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">       <span class="comment"># ...略</span></span><br></pre></td></tr></table></figure>

<p>这样，从gateway路由的所有请求都会带上origin头，值为gateway。而从其它地方到达微服务的请求则没有这个头。</p>
<h4 id="（4）配置授权规则"><a href="#（4）配置授权规则" class="headerlink" title="（4）配置授权规则"></a>（4）配置授权规则</h4><p>接下来，我们添加一个授权规则，放行origin值为gateway的请求。</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716153250134.png" alt="image-20210716153250134" style="zoom:50%;" />

<p>配置如下：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716153301069.png" alt="image-20210716153301069" style="zoom:50%;" />

<p>现在，我们直接跳过网关，访问order-service服务：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716153348396.png" alt="image-20210716153348396" style="zoom:50%;" />

<p>通过网关访问：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716153434095.png" alt="image-20210716153434095" style="zoom:50%;" />

<hr>
<h3 id="②自定义异常结果"><a href="#②自定义异常结果" class="headerlink" title="②自定义异常结果"></a>②自定义异常结果</h3><blockquote>
<p>默认情况下，发生限流、降级、授权拦截时，都会抛出异常到调用方。异常结果都是flow limmiting（限流）。这样不够友好，无法得知是限流还是降级还是授权拦截。</p>
</blockquote>
<h4 id="（1）异常类型"><a href="#（1）异常类型" class="headerlink" title="（1）异常类型"></a>（1）异常类型</h4><p>而如果要自定义异常时的返回结果，需要实现BlockExceptionHandler接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BlockExceptionHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理请求被限流、降级、授权拦截时抛出的异常：BlockException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, BlockException e)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法有三个参数：</p>
<ul>
<li>HttpServletRequest request：request对象</li>
<li>HttpServletResponse response：response对象</li>
<li>BlockException e：被sentinel拦截时抛出的异常</li>
</ul>
<p>这里的BlockException包含多个不同的子类：</p>
<table>
<thead>
<tr>
<th><strong>异常</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>FlowException</td>
<td>限流异常</td>
</tr>
<tr>
<td>ParamFlowException</td>
<td>热点参数限流的异常</td>
</tr>
<tr>
<td>DegradeException</td>
<td>降级异常</td>
</tr>
<tr>
<td>AuthorityException</td>
<td>授权规则异常</td>
</tr>
<tr>
<td>SystemBlockException</td>
<td>系统规则异常</td>
</tr>
</tbody></table>
<h4 id="（2）自定义异常处理"><a href="#（2）自定义异常处理" class="headerlink" title="（2）自定义异常处理"></a>（2）自定义异常处理</h4><p>下面，我们就在order-service定义一个自定义异常处理类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SentinelExceptionHandler</span> <span class="keyword">implements</span> <span class="title class_">BlockExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, BlockException e)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;未知异常&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">429</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> FlowException) &#123;</span><br><span class="line">            msg = <span class="string">&quot;请求被限流了&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ParamFlowException) &#123;</span><br><span class="line">            msg = <span class="string">&quot;请求被热点参数限流&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> DegradeException) &#123;</span><br><span class="line">            msg = <span class="string">&quot;请求被降级了&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> AuthorityException) &#123;</span><br><span class="line">            msg = <span class="string">&quot;没有权限访问&quot;</span>;</span><br><span class="line">            status = <span class="number">401</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        response.setStatus(status);</span><br><span class="line">        response.getWriter().println(<span class="string">&quot;&#123;\&quot;msg\&quot;: &quot;</span> + msg + <span class="string">&quot;, \&quot;status\&quot;: &quot;</span> + status + <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>重启测试，在不同场景下，会返回不同的异常消息.</p>
<p>限流：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716153938887.png" alt="image-20210716153938887" style="zoom:50%;" />

<p>授权拦截时：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716154012736.png" alt="image-20210716154012736" style="zoom:50%;" />

<hr>
<h2 id="5-5规则持久化"><a href="#5-5规则持久化" class="headerlink" title="5.5规则持久化"></a>5.5规则持久化</h2><blockquote>
<p>现在，我们在sentinel控制台设置的所有规则都是内存存储，<strong>重启服务器后所有规则都会丢失</strong>。在生产环境下，我们必须确保这些规则的持久化，避免丢失。</p>
</blockquote>
<h3 id="①规则管理模式"><a href="#①规则管理模式" class="headerlink" title="①规则管理模式"></a>①规则管理模式</h3><p>规则是否能持久化，取决于规则管理模式，sentinel支持三种规则管理模式：</p>
<ul>
<li>原始模式：Sentinel的默认模式，将规则保存在内存，重启服务会丢失。</li>
<li>pull模式</li>
<li>push模式</li>
</ul>
<p><strong>（1）pull模式</strong></p>
<p>pull模式：控制台将配置的规则推送到Sentinel客户端，而客户端会将配置规则保存在本地文件或数据库中。以后会定时去本地文件或数据库中查询，更新本地规则。</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716154155238.png" alt="image-20210716154155238" style="zoom:50%;" />

<p><strong>（2）push模式</strong></p>
<p>push模式：控制台将配置规则推送到远程配置中心，例如Nacos。Sentinel客户端监听Nacos，获取配置变更的推送消息，完成本地配置更新。</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210716154215456.png" alt="image-20210716154215456" style="zoom:50%;" />

<h3 id="②实现push模式"><a href="#②实现push模式" class="headerlink" title="②实现push模式"></a>②实现push模式</h3><p>详见老师给的sentinel规则持久化.md笔记</p>
<hr>
<h1 id="6-分布式事务Seata"><a href="#6-分布式事务Seata" class="headerlink" title="6.分布式事务Seata"></a>6.分布式事务Seata</h1><h2 id="6-1分布式事务问题"><a href="#6-1分布式事务问题" class="headerlink" title="6.1分布式事务问题"></a>6.1分布式事务问题</h2><h3 id="①本地事务"><a href="#①本地事务" class="headerlink" title="①本地事务"></a>①本地事务</h3><p>本地事务，也就是传统的<strong>单机事务</strong>。在传统数据库事务中，必须要满足四个原则：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724165045186.png" alt="image-20210724165045186" style="zoom:50%;" />

<h3 id="②分布式事务"><a href="#②分布式事务" class="headerlink" title="②分布式事务"></a>②分布式事务</h3><p><strong>分布式事务</strong>，就是指不是在单个服务或单个数据库架构下，产生的事务，例如：</p>
<ul>
<li><p>跨数据源的分布式事务</p>
</li>
<li><p>跨服务的分布式事务</p>
</li>
<li><p>综合情况</p>
</li>
</ul>
<p>在数据库水平拆分、服务垂直拆分之后，一个业务操作通常要跨多个数据库、服务才能完成。例如电商行业中比较常见的下单付款案例，包括下面几个行为：</p>
<ul>
<li>创建新订单</li>
<li>扣减商品库存</li>
<li>从用户账户余额扣除金额</li>
</ul>
<p>完成上面的操作需要访问三个不同的微服务和三个不同的数据库。</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724165338958.png" alt="image-20210724165338958" style="zoom:50%;" />



<p>订单的创建、库存的扣减、账户扣款在每一个服务和数据库内是一个本地事务，可以保证ACID原则。</p>
<p>但是当我们把三件事情看做一个”业务”，要满足保证“业务”的原子性，要么所有操作全部成功，要么全部失败，不允许出现部分成功部分失败的现象，这就是<strong>分布式系统下的事务</strong>了。</p>
<p>此时ACID难以满足，这是分布式事务要解决的问题</p>
<hr>
<h2 id="6-2理论基础"><a href="#6-2理论基础" class="headerlink" title="6.2理论基础"></a>6.2理论基础</h2><blockquote>
<p>解决分布式事务问题，需要一些分布式系统的基础知识作为理论指导。</p>
</blockquote>
<h3 id="①CAP定理"><a href="#①CAP定理" class="headerlink" title="①CAP定理"></a>①CAP定理</h3><p>1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标。</p>
<blockquote>
<ul>
<li>Consistency（一致性）</li>
<li>Availability（可用性）</li>
<li>Partition tolerance （分区容错性）</li>
</ul>
</blockquote>
<img src="/img/SpringCloudAlibaba.assets/image-20210724170517944.png" alt="image-20210724170517944" style="zoom:50%;" />

<p>它们的第一个字母分别是 C、A、P。</p>
<p>Eric Brewer 说，<strong>这三个指标不可能同时做到</strong>。这个结论就叫做 CAP 定理。</p>
<p><strong>（1）一致性</strong></p>
<p>Consistency（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致。</p>
<p>比如现在包含两个节点，其中的初始数据是一致的：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724170704694.png" alt="image-20210724170704694" style="zoom: 40%;" />

<p>当我们修改其中一个节点的数据时，两者的数据产生了差异：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724170735847.png" alt="image-20210724170735847" style="zoom:40%;" />

<p>要想保住一致性，就必须实现node01 到 node02的数据 同步：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724170834855.png" alt="image-20210724170834855" style="zoom:40%;" />



<p><strong>（2）可用性</strong></p>
<p>Availability （可用性）：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝。</p>
<p>如图，有三个节点的集群，访问任何一个都可以及时得到响应：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724170932072.png" alt="image-20210724170932072" style="zoom:40%;" />

<p>当有部分节点因为网络故障或其它原因无法访问时，代表节点不可用：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724171007516.png" alt="image-20210724171007516" style="zoom:40%;" />



<p><strong>（3）分区容错</strong></p>
<p><strong>Partition（分区）</strong>：因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724171041210.png" alt="image-20210724171041210" style="zoom:40%;" />



<p><strong>Tolerance（容错）</strong>：在集群出现分区时，整个系统也要持续对外提供服务</p>
<p><mark>产生问题：</mark></p>
<p>在分布式系统中，系统间的网络不能100%保证健康，一定会有故障的时候，而服务有必须对外保证服务。因此Partition Tolerance不可避免。</p>
<p>当节点接收到新的数据变更时，就会出现问题了：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724171546472.png" alt="image-20210724171546472" style="zoom:50%;" />

<p>如果此时要保证<strong>一致性</strong>，就必须等待网络恢复，完成数据同步后，整个集群才对外提供服务，服务处于阻塞状态，不可用。</p>
<p>如果此时要保证<strong>可用性</strong>，就不能等待网络恢复，那node01、node02与node03之间就会出现数据不一致。</p>
<p><em><u>也就是说，在P一定会出现的情况下，A和C之间只能实现一个。</u></em></p>
<hr>
<h3 id="②BASE理论"><a href="#②BASE理论" class="headerlink" title="②BASE理论"></a>②BASE理论</h3><p>BASE理论是对CAP的一种解决思路，包含三个思想：</p>
<ul>
<li><strong>Basically Available</strong> <strong>（基本可用）</strong>：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。</li>
<li><strong>Soft State（软状态）：</strong>在一定时间内，允许出现中间状态，比如临时的不一致状态。</li>
<li><strong>Eventually Consistent（最终一致性）</strong>：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。</li>
</ul>
<h3 id="③解决分布式事务问题的思路"><a href="#③解决分布式事务问题的思路" class="headerlink" title="③解决分布式事务问题的思路"></a>③解决分布式事务问题的思路</h3><p>分布式事务最大的问题是各个子事务的一致性问题，因此可以借鉴CAP定理和BASE理论，有两种解决思路：</p>
<ul>
<li><p>AP模式：各子事务分别执行和提交，允许出现结果不一致，然后采用弥补措施恢复数据即可，实现最终一致。</p>
</li>
<li><p>CP模式：各个子事务执行后互相等待，同时提交，同时回滚，达成强一致。但事务等待过程中，处于弱可用状态。</p>
</li>
</ul>
<p>但不管是哪一种模式，都需要在子系统事务之间互相通讯，协调事务状态，也就是需要一个**事务协调者(TC)**：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724172123567.png" alt="image-20210724172123567" style="zoom:50%;" />



<p>这里的子系统事务，称为<strong>分支事务</strong>；有关联的各个分支事务在一起称为<strong>全局事务</strong>。</p>
<hr>
<h2 id="6-3初识Seata"><a href="#6-3初识Seata" class="headerlink" title="6.3初识Seata"></a>6.3初识Seata</h2><blockquote>
<p>Seata是 2019 年 1 月份蚂蚁金服和阿里巴巴共同开源的分布式事务解决方案。致力于提供高性能和简单易用的分布式事务服务，为用户打造一站式的分布式解决方案。</p>
<p>官网地址：<a target="_blank" rel="noopener" href="http://seata.io/%EF%BC%8C%E5%85%B6%E4%B8%AD%E7%9A%84%E6%96%87%E6%A1%A3%E3%80%81%E6%92%AD%E5%AE%A2%E4%B8%AD%E6%8F%90%E4%BE%9B%E4%BA%86%E5%A4%A7%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E3%80%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%82">http://seata.io/，其中的文档、播客中提供了大量的使用说明、源码分析。</a></p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724172225817.png" alt="image-20210724172225817" style="zoom:33%;" />
</blockquote>
<h3 id="①Seata架构"><a href="#①Seata架构" class="headerlink" title="①Seata架构"></a>①Seata架构</h3><p>Seata事务管理中有三个重要的角色：</p>
<ul>
<li><p><strong>TC (Transaction Coordinator) -</strong> <strong>事务协调者：</strong>维护全局和分支事务的状态，协调全局事务提交或回滚。</p>
</li>
<li><p><strong>TM (Transaction Manager) -</strong> <strong>事务管理器：</strong>定义全局事务的范围、开始全局事务、提交或回滚全局事务。</p>
</li>
<li><p><strong>RM (Resource Manager) -</strong> <strong>资源管理器：</strong>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p>
</li>
</ul>
<p>整体的架构如图：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724172326452.png" alt="image-20210724172326452" style="zoom:50%;" />

<p>Seata基于上述架构提供了四种不同的分布式事务解决方案：</p>
<ul>
<li><strong>XA模式</strong>：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入</li>
<li><strong>TCC模式</strong>：最终一致的分阶段事务模式，有业务侵入</li>
<li><strong>AT模式</strong>：最终一致的分阶段事务模式，无业务侵入，也是Seata的默认模式</li>
<li><strong>SAGA模式</strong>：长事务模式，有业务侵入</li>
</ul>
<p>无论哪种方案，都离不开TC，也就是事务的协调者。</p>
<hr>
<h3 id="②部署TC服务"><a href="#②部署TC服务" class="headerlink" title="②部署TC服务"></a>②部署TC服务</h3><p>参考课前资料提供的文档《 seata的部署和集成.md 》：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724172549013.png" alt="image-20210724172549013" style="zoom: 67%;" />

<hr>
<h3 id="③微服务集成Seata"><a href="#③微服务集成Seata" class="headerlink" title="③微服务集成Seata"></a>③微服务集成Seata</h3><blockquote>
<p>我们以order-service为例来演示</p>
</blockquote>
<p><strong>（1）引入依赖</strong></p>
<p>首先，在order-service中引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--seata--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--版本较低，1.3.0，因此排除--&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--seata starter 采用1.4.2版本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;seata.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>（2）配置TC地址</strong></p>
<p>在order-service中的application.yml中，配置TC服务信息，通过注册中心nacos，结合服务名称获取TC地址：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">registry:</span> <span class="comment"># TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span> <span class="comment"># 注册中心类型 nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">&quot;&quot;</span> <span class="comment"># namespace，默认为空</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span> <span class="comment"># 分组，默认是DEFAULT_GROUP</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-tc-server</span> <span class="comment"># seata服务名称</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">seata-demo</span> <span class="comment"># 事务组名称</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">vgroup-mapping:</span> <span class="comment"># 事务组与cluster的映射关系</span></span><br><span class="line">      <span class="attr">seata-demo:</span> <span class="string">SH</span></span><br></pre></td></tr></table></figure>



<p>微服务如何根据这些配置寻找TC的地址呢？</p>
<p>我们知道注册到Nacos中的微服务，确定一个具体实例需要四个信息：</p>
<ul>
<li>namespace：命名空间</li>
<li>group：分组</li>
<li>application：服务名</li>
<li>cluster：集群名</li>
</ul>
<p>以上四个信息，在刚才的yaml文件中都能找到：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724173654258.png" alt="image-20210724173654258" style="zoom:50%;" />

<p>namespace为空，就是默认的public</p>
<p>结合起来，TC服务的信息就是：public@DEFAULT_GROUP@seata-tc-server@SH，这样就能确定TC服务集群了。然后就可以去Nacos拉取对应的实例信息了。</p>
<hr>
<h2 id="6-4Seata四种事务模式"><a href="#6-4Seata四种事务模式" class="headerlink" title="6.4Seata四种事务模式"></a>6.4Seata四种事务模式</h2><h3 id="①XA模式"><a href="#①XA模式" class="headerlink" title="①XA模式"></a>①XA模式</h3><blockquote>
<p>XA 规范 是 X&#x2F;Open 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准，XA 规范 描述了全局的TM与局部的RM之间的接口，几乎所有主流的数据库都对 XA 规范 提供了支持。</p>
</blockquote>
<h4 id="（1）两阶段提交"><a href="#（1）两阶段提交" class="headerlink" title="（1）两阶段提交"></a>（1）两阶段提交</h4><p>XA是规范，目前主流数据库都实现了这种规范，实现的原理都是基于两阶段提交。</p>
<p>正常情况：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724174102768.png" alt="image-20210724174102768" style="zoom:50%;" />

<p>异常情况：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724174234987.png" alt="image-20210724174234987" style="zoom:50%;" />



<p>一阶段：</p>
<ul>
<li>事务协调者通知每个事物参与者执行本地事务</li>
<li>本地事务执行完成后报告事务执行状态给事务协调者，此时事务不提交，继续持有数据库锁</li>
</ul>
<p>二阶段：</p>
<ul>
<li>事务协调者基于一阶段的报告来判断下一步操作<ul>
<li>如果一阶段都成功，则通知所有事务参与者，提交事务</li>
<li>如果一阶段任意一个参与者失败，则通知所有事务参与者回滚事务</li>
</ul>
</li>
</ul>
<h4 id="（2）Seata的XA模型"><a href="#（2）Seata的XA模型" class="headerlink" title="（2）Seata的XA模型"></a>（2）Seata的XA模型</h4><p>Seata对原始的XA模式做了简单的封装和改造，以适应自己的事务模型，基本架构如图：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724174424070.png" alt="image-20210724174424070" style="zoom:50%;" />

<p>RM一阶段的工作：</p>
<p>​	① 注册分支事务到TC</p>
<p>​	② 执行分支业务sql但<strong>不提交</strong></p>
<p>​	③ 报告执行状态到TC</p>
<p>TC二阶段的工作：</p>
<ul>
<li><p>TC检测各分支事务执行状态</p>
<p>a.如果都成功，通知所有RM提交事务</p>
<p>b.如果有失败，通知所有RM回滚事务</p>
</li>
</ul>
<p>RM二阶段的工作：</p>
<ul>
<li>接收TC指令，提交或回滚事务</li>
</ul>
<h4 id="（3）优缺点"><a href="#（3）优缺点" class="headerlink" title="（3）优缺点"></a>（3）优缺点</h4><p><u><em>XA模式的优点是什么？</em></u></p>
<ul>
<li>事务的强一致性，满足ACID原则。</li>
<li>常用数据库都支持，实现简单，并且没有代码侵入</li>
</ul>
<p><em><u>XA模式的缺点是什么？</u></em></p>
<ul>
<li>因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差</li>
<li>依赖关系型数据库实现事务</li>
</ul>
<h4 id="（4）实现XA模式"><a href="#（4）实现XA模式" class="headerlink" title="（4）实现XA模式"></a>（4）实现XA模式</h4><p>Seata的starter已经完成了XA模式的自动装配，实现非常简单，步骤如下：</p>
<p><strong>1）修改application.yml文件（每个参与事务的微服务），开启XA模式：</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">data-source-proxy-mode:</span> <span class="string">XA</span></span><br></pre></td></tr></table></figure>



<p><strong>2）给发起全局事务的入口方法添加@GlobalTransactional注解（用了feigh远程调用的方法）:</strong></p>
<p>本例中是OrderServiceImpl中的create方法.</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724174859556.png" alt="image-20210724174859556" style="zoom:50%;" />



<p><strong>3）重启服务并测试</strong></p>
<p>重启order-service，再次测试，发现无论怎样，三个微服务都能成功回滚。</p>
<hr>
<h3 id="②AT模式"><a href="#②AT模式" class="headerlink" title="②AT模式"></a>②AT模式</h3><blockquote>
<p>AT模式同样是分阶段提交的事务模型，不过缺弥补了XA模型中资源锁定周期过长的缺陷。</p>
</blockquote>
<h4 id="（1）Seata的AT模型"><a href="#（1）Seata的AT模型" class="headerlink" title="（1）Seata的AT模型"></a>（1）Seata的AT模型</h4><p>基本流程图：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724175327511.png" alt="image-20210724175327511" style="zoom:50%;" />

<p>阶段一RM的工作：</p>
<ul>
<li>注册分支事务</li>
<li>记录undo-log（数据快照）</li>
<li>执行业务sql并提交</li>
<li>报告事务状态</li>
</ul>
<p>阶段二提交时RM的工作：</p>
<ul>
<li>删除undo-log即可</li>
</ul>
<p>阶段二回滚时RM的工作：</p>
<ul>
<li>根据undo-log恢复数据到更新前</li>
</ul>
<h4 id="（2）流程示例"><a href="#（2）流程示例" class="headerlink" title="（2）流程示例"></a>（2）流程示例</h4><p>我们用一个真实的业务来梳理下AT模式的原理。</p>
<p>比如，现在又一个数据库表，记录用户余额：</p>
<table>
<thead>
<tr>
<th><strong>id</strong></th>
<th><strong>money</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>100</td>
</tr>
</tbody></table>
<p>其中一个分支业务要执行的SQL为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> tb_account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">10</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>AT模式下，当前分支事务执行流程如下：</p>
<p>一阶段：</p>
<p>1）TM发起并注册全局事务到TC</p>
<p>2）TM调用分支事务</p>
<p>3）分支事务准备执行业务SQL</p>
<p>4）RM拦截业务SQL，根据where条件查询原始数据，形成快照。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;money&quot;</span><span class="punctuation">:</span> <span class="number">100</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>5）RM执行业务SQL，提交本地事务，释放数据库锁。此时 <code>money = 90</code></p>
<p>6）RM报告本地事务状态给TC</p>
<p>二阶段：</p>
<p>1）TM通知TC事务结束</p>
<p>2）TC检查分支事务状态</p>
<p>​	 a）如果都成功，则立即删除快照</p>
<p>​	 b）如果有分支事务失败，需要回滚。读取快照数据（<code>&#123;&quot;id&quot;: 1, &quot;money&quot;: 100&#125;</code>），将快照恢复到数据库。此时数据库再次恢复为100</p>
<p>流程图：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724180722921.png" alt="image-20210724180722921" style="zoom:50%;" />



<h4 id="（3）AT与XA的区别"><a href="#（3）AT与XA的区别" class="headerlink" title="（3）AT与XA的区别"></a>（3）AT与XA的区别</h4><p><em><u>简述AT模式与XA模式最大的区别是什么？</u></em></p>
<ul>
<li>XA模式一阶段不提交事务，锁定资源；AT模式一阶段直接提交，不锁定资源。</li>
<li>XA模式依赖数据库机制实现回滚；AT模式利用数据快照实现数据回滚。</li>
<li>XA模式强一致；AT模式最终一致</li>
</ul>
<h4 id="（4）AT模式的脏写问题"><a href="#（4）AT模式的脏写问题" class="headerlink" title="（4）AT模式的脏写问题"></a>（4）AT模式的脏写问题</h4><p>在多线程并发访问AT模式的分布式事务时，有可能出现脏写问题，如图：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724181541234.png" alt="image-20210724181541234" style="zoom:50%;" />



<p><strong>seata利用全局锁解决了脏写问题</strong>。在释放DB锁之前，先拿到全局锁。避免同一时刻有另外一个事务来操作当前数据。</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724181843029.png" alt="image-20210724181843029" style="zoom:50%;" />



<h4 id="（5）AT模式优缺点"><a href="#（5）AT模式优缺点" class="headerlink" title="（5）AT模式优缺点"></a>（5）AT模式优缺点</h4><p><em><u>AT模式的优点：</u></em></p>
<ul>
<li>一阶段完成直接提交事务，释放数据库资源，性能比较好</li>
<li>利用全局锁实现读写隔离</li>
<li>没有代码侵入，框架自动完成回滚和提交</li>
</ul>
<p><em><u>AT模式的缺点：</u></em></p>
<ul>
<li>两阶段之间属于软状态，属于最终一致</li>
<li>框架的快照功能会影响性能，但比XA模式要好很多</li>
</ul>
<h4 id="（6）实现AT模式"><a href="#（6）实现AT模式" class="headerlink" title="（6）实现AT模式"></a>（6）实现AT模式</h4><p>AT模式中的快照生成、回滚等动作都是由框架自动完成，没有任何代码侵入，因此实现非常简单。</p>
<p>只不过，AT模式需要一个表来记录全局锁、另一张表来记录数据快照undo_log。</p>
<p><strong>1）导入数据库表，记录全局锁</strong></p>
<p>导入课前资料提供的Sql文件：seata-at.sql，其中lock_table（全局锁）导入到TC服务关联的数据库，undo_log（数据快照）表导入到微服务关联的数据库：</p>
<p><img src="/img/SpringCloudAlibaba.assets/image-20210724182217272.png" alt="image-20210724182217272"></p>
<p><strong>2）修改application.yml文件，将事务模式修改为AT模式即可：</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">data-source-proxy-mode:</span> <span class="string">AT</span> <span class="comment"># 默认就是AT</span></span><br></pre></td></tr></table></figure>



<p><strong>3）重启服务并测试</strong></p>
<hr>
<h3 id="③TCC模式"><a href="#③TCC模式" class="headerlink" title="③TCC模式"></a>③TCC模式</h3><blockquote>
<p>TCC模式与AT模式非常相似，每阶段都是独立事务，不同的是TCC通过人工编码来实现数据恢复。需要实现三个方法：</p>
<ul>
<li><p>Try：资源的检测和预留； </p>
</li>
<li><p>Confirm：完成资源操作业务；要求 Try 成功 Confirm 一定要能成功。</p>
</li>
<li><p>Cancel：预留资源释放，可以理解为try的反向操作。</p>
</li>
</ul>
</blockquote>
<h4 id="（1）流程分析（几个阶段）"><a href="#（1）流程分析（几个阶段）" class="headerlink" title="（1）流程分析（几个阶段）"></a>（1）流程分析（几个阶段）</h4><p><mark>数据库表中增加一个字段做资源预留，方便做数据回滚</mark></p>
<p>举例，一个扣减用户余额的业务。假设账户A原来余额是100，需要余额扣减30元。</p>
<ul>
<li><strong>阶段一（ Try ）</strong>：检查余额是否充足，如果充足则冻结金额增加30元，可用余额扣除30</li>
</ul>
<p>初识余额：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724182424907.png" alt="image-20210724182424907" style="zoom:50%;" />

<p>余额充足，可以冻结：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724182457951.png" alt="image-20210724182457951" style="zoom:50%;" />



<p>此时，总金额 &#x3D; 冻结金额 + 可用金额，数量依然是100不变。事务直接提交无需等待其它事务。</p>
<ul>
<li>**阶段二（Confirm)**：假如要提交（Confirm），则冻结金额扣减30</li>
</ul>
<p>确认可以提交，不过之前可用金额已经扣减过了，这里只要清除冻结金额就好了：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724182706011.png" alt="image-20210724182706011" style="zoom:50%;" />



<p>此时，总金额 &#x3D; 冻结金额 + 可用金额 &#x3D; 0 + 70  &#x3D; 70元</p>
<ul>
<li>**阶段二(Canncel)**：如果要回滚（Cancel），则冻结金额扣减30，可用余额增加30</li>
</ul>
<p>需要回滚，那么就要释放冻结金额，恢复可用金额：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724182810734.png" alt="image-20210724182810734" style="zoom:50%;" />



<h4 id="（2）Seata的TCC模型"><a href="#（2）Seata的TCC模型" class="headerlink" title="（2）Seata的TCC模型"></a>（2）Seata的TCC模型</h4><p>Seata中的TCC模型依然延续之前的事务架构，如图：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724182937713.png" alt="image-20210724182937713" style="zoom:50%;" />



<h4 id="（3）TCC模式优缺点"><a href="#（3）TCC模式优缺点" class="headerlink" title="（3）TCC模式优缺点"></a>（3）TCC模式优缺点</h4><p><em><u>TCC模式的每个阶段是做什么的？</u></em></p>
<ul>
<li>Try：资源检查和预留</li>
<li>Confirm：业务执行和提交</li>
<li>Cancel：预留资源的释放</li>
</ul>
<p><em><u>TCC的优点是什么？</u></em></p>
<ul>
<li>一阶段完成直接提交事务，释放数据库资源，性能好</li>
<li>相比AT模型，无需生成快照，无需使用全局锁，性能最强</li>
<li>不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库</li>
</ul>
<p><em><u>TCC的缺点是什么？</u></em></p>
<ul>
<li>有代码侵入，需要人为编写try、Confirm和Cancel接口，太麻烦</li>
<li>软状态，事务是最终一致</li>
<li>需要考虑Confirm和Cancel的失败情况，做好幂等处理</li>
</ul>
<h4 id="（4）事务悬挂和空回滚问题"><a href="#（4）事务悬挂和空回滚问题" class="headerlink" title="（4）事务悬挂和空回滚问题"></a>（4）事务悬挂和空回滚问题</h4><p><strong>1）空回滚</strong></p>
<p>当某分支事务的try阶段<strong>阻塞</strong>时，可能导致全局事务超时而触发二阶段的cancel操作。在未执行try操作时先执行了cancel操作，这时cancel不能做回滚，就是<strong>空回滚</strong>。</p>
<p>如图：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724183426891.png" alt="image-20210724183426891" style="zoom:50%;" />

<p>执行cancel操作时，应当判断try是否已经执行，如果尚未执行，则应该空回滚。</p>
<p><strong>2）业务悬挂</strong></p>
<p>对于已经空回滚的业务，之前被阻塞的try操作恢复，继续执行try，就永远不可能confirm或cancel ，事务一直处于中间状态，这就是<strong>业务悬挂</strong>。</p>
<p>执行try操作时，应当判断cancel是否已经执行过了，如果已经执行，应当阻止空回滚后的try操作，避免悬挂</p>
<h4 id="（5）实现TCC模式"><a href="#（5）实现TCC模式" class="headerlink" title="（5）实现TCC模式"></a>（5）实现TCC模式</h4><blockquote>
<p>解决空回滚和业务悬挂问题，必须要记录当前事务状态，是在try、还是cancel？</p>
</blockquote>
<p><mark>1）思路分析</mark></p>
<p>这里我们定义一张表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `account_freeze_tbl` (</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `user_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">  `freeze_money` <span class="type">int</span>(<span class="number">11</span>) unsigned <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;冻结金额&#x27;</span>,</span><br><span class="line">  `state` <span class="type">int</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;事务状态，0:try，1:confirm，2:cancel&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`xid`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span>COMPACT;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>xid：是全局事务id</li>
<li>freeze_money：用来记录用户冻结金额</li>
<li>state：用来记录事务状态</li>
</ul>
<img src="/img/SpringCloudAlibaba.assets/image-20230120155208093.png" alt="image-20230120155208093" style="zoom: 33%;" />

<p>那此时，我们的业务开怎么做呢？</p>
<ul>
<li>Try业务：<ul>
<li>记录冻结金额和事务状态到account_freeze表</li>
<li>扣减account表可用金额</li>
</ul>
</li>
<li>Confirm业务<ul>
<li>根据xid删除account_freeze表的冻结记录</li>
</ul>
</li>
<li>Cancel业务<ul>
<li>修改account_freeze表，冻结金额为0，state为2</li>
<li>修改account表，恢复可用金额</li>
</ul>
</li>
<li>如何判断是否空回滚？<ul>
<li>cancel业务中，根据xid查询account_freeze，如果为null则说明try还没做，需要空回滚</li>
</ul>
</li>
<li>如何避免业务悬挂？<ul>
<li>try业务中，根据xid查询account_freeze ，如果已经存在则证明Cancel已经执行，拒绝执行try业务</li>
</ul>
</li>
</ul>
<p>接下来，我们改造account-service，利用TCC实现余额扣减功能。</p>
<p><mark>2）声明TCC接口</mark></p>
<p>TCC的Try、Confirm、Cancel方法都需要在接口中基于注解来声明，</p>
<p>我们在account-service项目中的<code>cn.itcast.account.service</code>包中新建一个接口，声明TCC三个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@LocalTCC</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountTCCService</span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	1.Try逻辑，@TwoPhaseBusinessAction中的name属性要与当前方法名一致，用于指定Try逻辑对应的方法。commitMethod属性和rollbackMethod属性分别指定confirm阶段和cancel阶段的方法名</span></span><br><span class="line"><span class="comment">	2.@BusinessActionContextParameter后声明的属性会放到后面两个方法的BusinessActionContext ctx形参中</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="meta">@TwoPhaseBusinessAction(name = &quot;deduct&quot;, commitMethod = &quot;confirm&quot;, rollbackMethod = &quot;cancel&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deduct</span><span class="params">(<span class="meta">@BusinessActionContextParameter(paramName = &quot;userId&quot;)</span> String userId,</span></span><br><span class="line"><span class="params">                <span class="meta">@BusinessActionContextParameter(paramName = &quot;money&quot;)</span><span class="type">int</span> money)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二阶段confirm确认方法、可以另命名，但要保证与注解中commitMethod属性一致 </span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">confirm</span><span class="params">(BusinessActionContext ctx)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二阶段回滚方法，要保证与注解中rollbackMethod属性一致</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(BusinessActionContext ctx)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><mark>3）编写实现类</mark></p>
<p>在account-service服务中的<code>cn.itcast.account.service.impl</code>包下新建一个类，实现TCC业务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountTCCServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountTCCService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountFreezeMapper freezeMapper;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deduct</span><span class="params">(String userId, <span class="type">int</span> money)</span> &#123;</span><br><span class="line">        <span class="comment">// 0.获取事务id</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">xid</span> <span class="operator">=</span> RootContext.getXID();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.应对try执行时业务阻塞的情况:</span></span><br><span class="line"><span class="comment">        判断freeze中是否有冻结记录，如果有，则一定是CANCEL执行过，则此业务不再执行</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">AccountFreeze</span> <span class="variable">oldFreeze</span> <span class="operator">=</span> freezeMapper.selectById(xid);</span><br><span class="line">        <span class="keyword">if</span> (oldFreeze != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//CANCEL执行过，则拒绝业务</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.扣减可用余额</span></span><br><span class="line">        accountMapper.deduct(userId, money);</span><br><span class="line">        <span class="comment">// 3.记录冻结金额，事务状态</span></span><br><span class="line">        <span class="type">AccountFreeze</span> <span class="variable">freeze</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccountFreeze</span>();</span><br><span class="line">        freeze.setUserId(userId);</span><br><span class="line">        freeze.setFreezeMoney(money);</span><br><span class="line">        freeze.setState(AccountFreeze.State.TRY);</span><br><span class="line">        freeze.setXid(xid);</span><br><span class="line">        freezeMapper.insert(freeze);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">confirm</span><span class="params">(BusinessActionContext ctx)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取事务id</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">xid</span> <span class="operator">=</span> ctx.getXid();</span><br><span class="line">        <span class="comment">// 2.根据id删除冻结记录</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> freezeMapper.deleteById(xid);</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(BusinessActionContext ctx)</span> &#123;</span><br><span class="line">        <span class="comment">// 0.查询冻结记录</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">xid</span> <span class="operator">=</span> ctx.getXid();</span><br><span class="line">        <span class="type">AccountFreeze</span> <span class="variable">freeze</span> <span class="operator">=</span> freezeMapper.selectById(xid);</span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> ctx.getActionContext(<span class="string">&quot;userId&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.空回滚判断，判断freeze是否为null，为null证明try没执行，需要空回滚</span></span><br><span class="line">        <span class="keyword">if</span>(freeze == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//空回滚，设置一条freezeMoney为空的数据</span></span><br><span class="line">            freeze = <span class="keyword">new</span> <span class="title class_">AccountFreeze</span>();</span><br><span class="line">            freeze.setUserId(userId);</span><br><span class="line">            freeze.setFreezeMoney(<span class="number">0</span>);</span><br><span class="line">            freeze.setState(AccountFreeze.State.CANCEL);</span><br><span class="line">            freeze.setXid(xid);</span><br><span class="line">            freezeMapper.insert(freeze);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.幂等判断：若已经执行过一次CANCEL（通过state判断）,则无需再重复处理</span></span><br><span class="line">        <span class="keyword">if</span> (freeze.getState() == AccountFreeze.State.CANCEL)&#123;</span><br><span class="line">            <span class="comment">//已经处理过一次CANCEL，则无需重复处理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.恢复可用余额</span></span><br><span class="line">        accountMapper.refund(freeze.getUserId(), freeze.getFreezeMoney());</span><br><span class="line">        <span class="comment">// 4.将冻结金额清零，状态改为CANCEL</span></span><br><span class="line">        freeze.setFreezeMoney(<span class="number">0</span>);</span><br><span class="line">        freeze.setState(AccountFreeze.State.CANCEL);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> freezeMapper.updateById(freeze);</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="④SAGA模式"><a href="#④SAGA模式" class="headerlink" title="④SAGA模式"></a>④SAGA模式</h3><p>Saga 模式是 Seata 即将开源的长事务解决方案，将由蚂蚁金服主要贡献。</p>
<p>其理论基础是Hector &amp; Kenneth  在1987年发表的论文<a target="_blank" rel="noopener" href="https://microservices.io/patterns/data/saga.html">Sagas</a>。</p>
<p>Seata官网对于Saga的指南：<a target="_blank" rel="noopener" href="https://seata.io/zh-cn/docs/user/saga.html">https://seata.io/zh-cn/docs/user/saga.html</a></p>
<h4 id="（1）原理"><a href="#（1）原理" class="headerlink" title="（1）原理"></a>（1）原理</h4><p>在 Saga 模式下，分布式事务内有多个参与者，每一个参与者都是一个冲正补偿服务，需要用户根据业务场景实现其正向操作和逆向回滚操作。</p>
<p>分布式事务执行过程中，依次执行各参与者的正向操作，如果所有正向操作均执行成功，那么分布式事务提交。如果任何一个正向操作执行失败，那么分布式事务会去退回去执行前面各参与者的逆向回滚操作，回滚已提交的参与者，使分布式事务回到初始状态。</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724184846396.png" alt="image-20210724184846396" style="zoom:50%;" />

<p>Saga也分为两个阶段：</p>
<ul>
<li>一阶段：直接提交本地事务</li>
<li>二阶段：成功则什么都不做；失败则通过编写补偿业务来回滚</li>
</ul>
<h4 id="（2）优缺点"><a href="#（2）优缺点" class="headerlink" title="（2）优缺点"></a>（2）优缺点</h4><p>优点：</p>
<ul>
<li>事务参与者可以基于事件驱动实现异步调用，吞吐高</li>
<li>一阶段直接提交事务，无锁，性能好</li>
<li>不用编写TCC中的三个阶段，实现简单</li>
</ul>
<p>缺点：</p>
<ul>
<li>软状态持续时间不确定，时效性差</li>
<li>没有锁，没有事务隔离，会有脏写</li>
</ul>
<h3 id="⑤四种模式对比"><a href="#⑤四种模式对比" class="headerlink" title="⑤四种模式对比"></a>⑤四种模式对比</h3><p>我们从以下几个方面来对比四种实现：</p>
<ul>
<li>一致性：能否保证事务的一致性？强一致还是最终一致？</li>
<li>隔离性：事务之间的隔离性如何？</li>
<li>代码侵入：是否需要对业务代码改造？</li>
<li>性能：有无性能损耗？</li>
<li>场景：常见的业务场景</li>
</ul>
<p>如图：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724185021819.png" alt="image-20210724185021819" style="zoom:50%;" />

<hr>
<h2 id="6-5高可用"><a href="#6-5高可用" class="headerlink" title="6.5高可用"></a>6.5高可用</h2><blockquote>
<p>Seata的TC服务作为分布式事务核心，一定要保证集群的高可用性（服务器出现故障要能够解决，保证服务可用）。</p>
</blockquote>
<h3 id="①高可用架构模型"><a href="#①高可用架构模型" class="headerlink" title="①高可用架构模型"></a>①高可用架构模型</h3><p>搭建TC服务集群非常简单，启动多个TC服务，注册到nacos即可。</p>
<p>但集群并不能确保100%安全，万一集群所在机房故障怎么办？所以如果要求较高，一般都会做异地多机房容灾。</p>
<p>比如一个TC集群在上海，另一个TC集群在杭州：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724185240957.png" alt="image-20210724185240957" style="zoom:50%;" />



<p>微服务基于事务组（tx-service-group)与TC集群的映射关系，来查找当前应该使用哪个TC集群。当SH集群故障时，只需要将vgroup-mapping中的映射关系改成HZ。则所有微服务就会切换到HZ的TC集群了。</p>
<h3 id="②实现高可用"><a href="#②实现高可用" class="headerlink" title="②实现高可用"></a>②实现高可用</h3><p>具体实现请参考课前资料提供的文档《seata的部署和集成.md》：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724172549013-16758247818704.png" alt="image-20210724172549013" style="zoom: 67%;" />

<p>第三章节：</p>
<img src="/img/SpringCloudAlibaba.assets/image-20210724185638729.png" alt="image-20210724185638729" style="zoom:50%;" />
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://xxxxxx.com">cloudy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://xxxxxx.com">https://xxxxxx.com</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">此文章版权归cloudy所有，如有转载，请註明来自原作者</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/blog_cover/default_cover_2.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">cloudy</div><div class="author-info__description">welcome to my blog site</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xxxxx" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #000000;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%AE%9E%E7%94%A8%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">一、实用篇</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">1.微服务架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.1.</span> <span class="toc-text">1.1认识微服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98"><span class="toc-number">2.1.1.</span> <span class="toc-text">①服务架构演变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%94"><span class="toc-number">2.1.2.</span> <span class="toc-text">②微服务技术对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2SpringCloud"><span class="toc-number">2.1.3.</span> <span class="toc-text">③SpringCloud</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%E5%8F%8A%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-number">2.2.</span> <span class="toc-text">1.2服务拆分及远程调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E6%8B%86%E5%88%86"><span class="toc-number">2.2.1.</span> <span class="toc-text">①拆分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-number">2.2.2.</span> <span class="toc-text">②远程调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">2.2.3.</span> <span class="toc-text">③服务提供者与消费者</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">2.3.</span> <span class="toc-text">1.3Eureka注册中心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0Eureka%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E4%BD%9C%E7%94%A8"><span class="toc-number">2.3.1.</span> <span class="toc-text">①Eureka的结构和作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1Eureka%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.3.2.</span> <span class="toc-text">②Eureka的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">2.4.</span> <span class="toc-text">1.4Ribbon负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8E%9F%E7%90%86"><span class="toc-number">2.4.1.</span> <span class="toc-text">①负载均衡原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E6%BA%90%E7%A0%81%E8%B7%9F%E8%B8%AA"><span class="toc-number">2.4.2.</span> <span class="toc-text">②源码跟踪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5"><span class="toc-number">2.4.3.</span> <span class="toc-text">③负载均衡策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5"><span class="toc-number">2.4.4.</span> <span class="toc-text">④自定义负载均衡策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4%E9%A5%A5%E9%A5%BF%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.4.5.</span> <span class="toc-text">⑤饥饿加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">2.5.</span> <span class="toc-text">1.5Nacos注册中心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0Nacos%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.5.1.</span> <span class="toc-text">①Nacos注册服务</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Nacos%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.5.1.0.1.</span> <span class="toc-text">Nacos服务端启动注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1Nacos%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%88%86%E7%BA%A7%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.5.2.</span> <span class="toc-text">②Nacos的服务分级存储模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2Nacos%E9%85%8D%E7%BD%AE%E9%9B%86%E7%BE%A4"><span class="toc-number">2.5.3.</span> <span class="toc-text">③Nacos配置集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3Nacos%E6%9D%83%E9%87%8D%E9%85%8D%E7%BD%AE"><span class="toc-number">2.5.4.</span> <span class="toc-text">④Nacos权重配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4Nacos%E7%8E%AF%E5%A2%83%E9%9A%94%E7%A6%BB"><span class="toc-number">2.5.5.</span> <span class="toc-text">⑤Nacos环境隔离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A5Nacos%E4%B8%8EEureka%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.6.</span> <span class="toc-text">⑥Nacos与Eureka的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6Nacos%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86"><span class="toc-number">2.6.</span> <span class="toc-text">1.6Nacos配置管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E7%BB%9F%E4%B8%80%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86"><span class="toc-number">2.6.1.</span> <span class="toc-text">①统一配置管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E9%85%8D%E7%BD%AE%E7%83%AD%E6%9B%B4%E6%96%B0"><span class="toc-number">2.6.2.</span> <span class="toc-text">②配置热更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E9%85%8D%E7%BD%AE%E5%85%B1%E4%BA%AB"><span class="toc-number">2.6.3.</span> <span class="toc-text">③配置共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3%E6%90%AD%E5%BB%BANacos%E9%9B%86%E7%BE%A4"><span class="toc-number">2.6.4.</span> <span class="toc-text">④搭建Nacos集群</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7RestTemplate"><span class="toc-number">2.7.</span> <span class="toc-text">1.7RestTemplate</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="toc-number">2.7.1.</span> <span class="toc-text">①主要功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">2.7.2.</span> <span class="toc-text">②基本用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8Feign%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-number">2.8.</span> <span class="toc-text">1.8Feign远程调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0Feign%E6%9B%BF%E4%BB%A3RestTemplate"><span class="toc-number">2.8.1.</span> <span class="toc-text">①Feign替代RestTemplate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1Feign%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE"><span class="toc-number">2.8.2.</span> <span class="toc-text">②Feign的自定义配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2Feign%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6"><span class="toc-number">2.8.3.</span> <span class="toc-text">③Feign传输文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3Feign%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96"><span class="toc-number">2.8.4.</span> <span class="toc-text">④Feign使用优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4Feign%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">2.8.5.</span> <span class="toc-text">⑤Feign的最佳实践</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9Gateway%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3"><span class="toc-number">2.9.</span> <span class="toc-text">1.9Gateway服务网关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BD%91%E5%85%B3"><span class="toc-number">2.9.1.</span> <span class="toc-text">①为什么需要网关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1Gateway%E4%BD%BF%E7%94%A8"><span class="toc-number">2.9.2.</span> <span class="toc-text">②Gateway使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E6%96%AD%E8%A8%80%E5%B7%A5%E5%8E%82"><span class="toc-number">2.9.3.</span> <span class="toc-text">③断言工厂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3%E8%BF%87%E6%BB%A4%E5%99%A8%E5%B7%A5%E5%8E%82"><span class="toc-number">2.9.4.</span> <span class="toc-text">④过滤器工厂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">2.9.5.</span> <span class="toc-text">⑤全局过滤器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A5%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="toc-number">2.9.6.</span> <span class="toc-text">⑥跨域问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AFDocker"><span class="toc-number">3.</span> <span class="toc-text">2.容器技术Docker</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E8%AE%A4%E8%AF%86Docker"><span class="toc-number">3.1.</span> <span class="toc-text">2.1认识Docker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E4%BB%80%E4%B9%88%E6%98%AFDocker"><span class="toc-number">3.1.1.</span> <span class="toc-text">①什么是Docker?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1Docker%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.2.</span> <span class="toc-text">②Docker与虚拟机的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2Docker%E6%9E%B6%E6%9E%84"><span class="toc-number">3.1.3.</span> <span class="toc-text">③Docker架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%95%9C%E5%83%8F%E5%92%8C%E5%AE%B9%E5%99%A8"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">(1) 镜像和容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Dockerhub"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">(2) Dockerhub</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Docker%E6%9E%B6%E6%9E%84"><span class="toc-number">3.1.3.3.</span> <span class="toc-text">(3) Docker架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%80%BB%E7%BB%93"><span class="toc-number">3.1.3.4.</span> <span class="toc-text">(4) 总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3%E5%AE%89%E8%A3%85Docker"><span class="toc-number">3.1.4.</span> <span class="toc-text">④安装Docker</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.</span> <span class="toc-text">2.2Docker的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.1.</span> <span class="toc-text">①镜像操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%95%9C%E5%83%8F%E5%90%8D%E7%A7%B0"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">(1) 镜像名称</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%95%9C%E5%83%8F%E5%91%BD%E4%BB%A4"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">(2) 镜像命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.2.</span> <span class="toc-text">②容器操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">(1) 容器命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">3.2.3.</span> <span class="toc-text">③数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">（1）什么是数据卷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%95%B0%E6%8D%AE%E9%9B%86%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">（2）数据集操作命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%AE%B9%E5%99%A8%E7%9B%B4%E6%8E%A5%E6%8C%82%E8%BD%BD%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9B%AE%E5%BD%95"><span class="toc-number">3.2.3.3.</span> <span class="toc-text">（3）容器直接挂载宿主机目录</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3Dockerfile%E8%87%AA%E5%AE%9A%E4%B9%89%E9%95%9C%E5%83%8F"><span class="toc-number">3.3.</span> <span class="toc-text">2.3Dockerfile自定义镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E9%95%9C%E5%83%8F%E7%BB%93%E6%9E%84"><span class="toc-number">3.3.1.</span> <span class="toc-text">①镜像结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1Dockerfile%E8%AF%AD%E6%B3%95"><span class="toc-number">3.3.2.</span> <span class="toc-text">②Dockerfile语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E5%9F%BA%E4%BA%8EJava8%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="toc-number">3.3.3.</span> <span class="toc-text">③基于Java8构建镜像</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4Docker-Compose"><span class="toc-number">3.4.</span> <span class="toc-text">2.4Docker-Compose</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0docker-compose-yml"><span class="toc-number">3.4.1.</span> <span class="toc-text">①docker-compose.yml</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%B0%86cloud-demo%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9B%86%E7%BE%A4"><span class="toc-number">3.4.2.</span> <span class="toc-text">②示例：将cloud-demo项目部署微服务集群</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5Docker%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93"><span class="toc-number">3.5.</span> <span class="toc-text">2.5Docker镜像仓库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93"><span class="toc-number">3.5.1.</span> <span class="toc-text">①搭建私有镜像仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E6%8E%A8%E9%80%81%E3%80%81%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F"><span class="toc-number">3.5.2.</span> <span class="toc-text">②推送、拉取镜像</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ"><span class="toc-number">4.</span> <span class="toc-text">3.消息队列RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E8%AE%A4%E8%AF%86MQ"><span class="toc-number">4.1.</span> <span class="toc-text">3.1认识MQ</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E5%90%8C%E6%AD%A5%E9%80%9A%E8%AE%AF%E4%B8%8E%E5%BC%82%E6%AD%A5%E9%80%9A%E8%AE%AF"><span class="toc-number">4.1.1.</span> <span class="toc-text">①同步通讯与异步通讯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E5%90%8C%E6%AD%A5%E9%80%9A%E8%AE%AF"><span class="toc-number">4.1.2.</span> <span class="toc-text">②同步通讯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E5%BC%82%E6%AD%A5%E9%80%9A%E8%AE%AF"><span class="toc-number">4.1.3.</span> <span class="toc-text">③异步通讯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%94"><span class="toc-number">4.1.4.</span> <span class="toc-text">④技术对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E5%8E%9F%E7%94%9FRabbitMQ"><span class="toc-number">4.2.</span> <span class="toc-text">3.2原生RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0RabbitMQ%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.1.</span> <span class="toc-text">①RabbitMQ的基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1RabbitMQ%E7%9A%84%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.2.2.</span> <span class="toc-text">②RabbitMQ的消息模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E5%8E%9F%E7%94%9FRabbitMQ%E7%9A%84Java%E4%BB%A3%E7%A0%81%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">4.2.3.</span> <span class="toc-text">③原生RabbitMQ的Java代码——基本消息队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3SpringAMQP"><span class="toc-number">4.3.</span> <span class="toc-text">3.3SpringAMQP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0BasicQueue%E7%AE%80%E5%8D%95%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.3.1.</span> <span class="toc-text">①BasicQueue简单队列模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1WorkQueue"><span class="toc-number">4.3.2.</span> <span class="toc-text">②WorkQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2Fanout"><span class="toc-number">4.3.3.</span> <span class="toc-text">③Fanout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3Direct"><span class="toc-number">4.3.4.</span> <span class="toc-text">④Direct</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4Topic"><span class="toc-number">4.3.5.</span> <span class="toc-text">⑤Topic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A5%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8"><span class="toc-number">4.3.6.</span> <span class="toc-text">⑥消息转换器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8EElasticsearch"><span class="toc-number">5.</span> <span class="toc-text">4.搜索引擎Elasticsearch</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E5%88%9D%E8%AF%86Elasticsearch"><span class="toc-number">5.1.</span> <span class="toc-text">4.1初识Elasticsearch</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E8%AE%A4%E8%AF%86Elasticsearch"><span class="toc-number">5.1.1.</span> <span class="toc-text">①认识Elasticsearch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95"><span class="toc-number">5.1.2.</span> <span class="toc-text">②倒排索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2ES%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.3.</span> <span class="toc-text">③ES中的一些概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3mysql%E4%B8%8Ees"><span class="toc-number">5.1.4.</span> <span class="toc-text">④mysql与es</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4%E5%AE%89%E8%A3%85ES"><span class="toc-number">5.1.5.</span> <span class="toc-text">⑤安装ES</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A5ES%E4%B8%AD%E7%9A%84%E5%88%86%E8%AF%8D%E5%99%A8"><span class="toc-number">5.1.6.</span> <span class="toc-text">⑥ES中的分词器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2%E7%B4%A2%E5%BC%95%E5%BA%93%E6%93%8D%E4%BD%9C"><span class="toc-number">5.2.</span> <span class="toc-text">4.2索引库操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0mapping%E6%98%A0%E5%B0%84%E5%B1%9E%E6%80%A7"><span class="toc-number">5.2.1.</span> <span class="toc-text">①mapping映射属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E7%B4%A2%E5%BC%95%E5%BA%93%E7%9A%84CRUD"><span class="toc-number">5.2.2.</span> <span class="toc-text">②索引库的CRUD</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C"><span class="toc-number">5.3.</span> <span class="toc-text">4.3文档操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E6%96%87%E6%A1%A3%E7%9A%84CRUD"><span class="toc-number">5.3.1.</span> <span class="toc-text">①文档的CRUD</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4RestAPI-in-Java"><span class="toc-number">5.4.</span> <span class="toc-text">4.4RestAPI in Java</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E5%9C%A8Java%E4%B8%AD%E4%BD%BF%E7%94%A8RestAPI"><span class="toc-number">5.4.1.</span> <span class="toc-text">①在Java中使用RestAPI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1RestClient%E6%93%8D%E4%BD%9C%E7%B4%A2%E5%BC%95%E5%BA%93"><span class="toc-number">5.4.2.</span> <span class="toc-text">②RestClient操作索引库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2RestClient%E6%93%8D%E4%BD%9C%E6%96%87%E6%A1%A3"><span class="toc-number">5.4.3.</span> <span class="toc-text">③RestClient操作文档</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5DSL%E6%9F%A5%E8%AF%A2%E6%96%87%E6%A1%A3"><span class="toc-number">5.5.</span> <span class="toc-text">4.5DSL查询文档</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0DSL%E6%9F%A5%E8%AF%A2%E5%88%86%E7%B1%BB"><span class="toc-number">5.5.1.</span> <span class="toc-text">①DSL查询分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.5.2.</span> <span class="toc-text">②全文检索查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E7%B2%BE%E5%87%86%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.5.3.</span> <span class="toc-text">③精准查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3%E5%9C%B0%E7%90%86%E5%9D%90%E6%A0%87%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.5.4.</span> <span class="toc-text">④地理坐标查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4%E5%A4%8D%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.5.5.</span> <span class="toc-text">⑤复合查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%9B%B8%E5%85%B3%E6%80%A7%E7%AE%97%E5%88%86%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.5.5.1.</span> <span class="toc-text">（1）相关性算分介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%AE%97%E5%88%86%E5%87%BD%E6%95%B0%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.5.5.2.</span> <span class="toc-text">（2）算分函数查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%B8%83%E5%B0%94%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.5.5.3.</span> <span class="toc-text">（3）布尔查询</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86"><span class="toc-number">5.6.</span> <span class="toc-text">4.6搜索结果处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E6%8E%92%E5%BA%8F"><span class="toc-number">5.6.1.</span> <span class="toc-text">①排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%99%AE%E9%80%9A%E5%AD%97%E6%AE%B5%E6%8E%92%E5%BA%8F"><span class="toc-number">5.6.1.1.</span> <span class="toc-text">（1）普通字段排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%9C%B0%E7%90%86%E5%9D%90%E6%A0%87%E6%8E%92%E5%BA%8F"><span class="toc-number">5.6.1.2.</span> <span class="toc-text">（2）地理坐标排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E5%88%86%E9%A1%B5"><span class="toc-number">5.6.2.</span> <span class="toc-text">②分页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E9%AB%98%E4%BA%AE"><span class="toc-number">5.6.3.</span> <span class="toc-text">③高亮</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7RestClient%E6%9F%A5%E8%AF%A2%E6%96%87%E6%A1%A3"><span class="toc-number">5.7.</span> <span class="toc-text">4.7RestClient查询文档</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.7.1.</span> <span class="toc-text">①基本步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%8F%91%E8%B5%B7%E6%9F%A5%E8%AF%A2%E8%AF%B7%E6%B1%82"><span class="toc-number">5.7.1.1.</span> <span class="toc-text">（1）发起查询请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%A7%A3%E6%9E%90%E5%93%8D%E5%BA%94"><span class="toc-number">5.7.1.2.</span> <span class="toc-text">（2）解析响应</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E6%9F%A5%E8%AF%A2-1"><span class="toc-number">5.7.2.</span> <span class="toc-text">②全文检索查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E7%B2%BE%E7%A1%AE%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.7.3.</span> <span class="toc-text">③精确查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3%E5%B8%83%E5%B0%94%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.7.4.</span> <span class="toc-text">④布尔查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4%E5%9C%B0%E7%90%86%E5%9D%90%E6%A0%87%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.7.5.</span> <span class="toc-text">⑤地理坐标查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A5%E6%B7%BB%E5%8A%A0%E7%AE%97%E5%88%86%E5%87%BD%E6%95%B0%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.7.6.</span> <span class="toc-text">⑥添加算分函数查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A6%E6%8E%92%E5%BA%8F%E3%80%81%E5%88%86%E9%A1%B5"><span class="toc-number">5.7.7.</span> <span class="toc-text">⑦排序、分页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A7%E9%AB%98%E4%BA%AE"><span class="toc-number">5.7.8.</span> <span class="toc-text">⑧高亮</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E9%AB%98%E4%BA%AE%E8%AF%B7%E6%B1%82%E6%9E%84%E5%BB%BA"><span class="toc-number">5.7.8.1.</span> <span class="toc-text">（1）高亮请求构建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E9%AB%98%E4%BA%AE%E7%BB%93%E6%9E%9C%E8%A7%A3%E6%9E%90"><span class="toc-number">5.7.8.2.</span> <span class="toc-text">（2）高亮结果解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8%E6%95%B0%E6%8D%AE%E8%81%9A%E5%90%88"><span class="toc-number">5.8.</span> <span class="toc-text">4.8数据聚合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E8%81%9A%E5%90%88%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">5.8.1.</span> <span class="toc-text">①聚合的种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1DSL%E5%AE%9E%E7%8E%B0%E8%81%9A%E5%90%88"><span class="toc-number">5.8.2.</span> <span class="toc-text">②DSL实现聚合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2RestClient%E5%AE%9E%E7%8E%B0%E8%81%9A%E5%90%88"><span class="toc-number">5.8.3.</span> <span class="toc-text">③RestClient实现聚合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8"><span class="toc-number">5.9.</span> <span class="toc-text">4.9自动补全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E5%AE%89%E8%A3%85%E6%8B%BC%E9%9F%B3%E5%88%86%E8%AF%8D%E5%99%A8"><span class="toc-number">5.9.1.</span> <span class="toc-text">①安装拼音分词器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E8%AF%8D%E5%99%A8"><span class="toc-number">5.9.2.</span> <span class="toc-text">②自定义分词器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.9.3.</span> <span class="toc-text">③自动补全查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3RestClient%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.9.4.</span> <span class="toc-text">④RestClient实现自动补全查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-10%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5"><span class="toc-number">5.10.</span> <span class="toc-text">4.10数据同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88"><span class="toc-number">5.10.1.</span> <span class="toc-text">①数据同步方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%A1%88%E4%BE%8B"><span class="toc-number">5.10.2.</span> <span class="toc-text">②实现数据同步案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-11ES%E9%9B%86%E7%BE%A4"><span class="toc-number">5.11.</span> <span class="toc-text">4.11ES集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0ES%E9%9B%86%E7%BE%A4%E6%A6%82%E5%BF%B5"><span class="toc-number">5.11.1.</span> <span class="toc-text">①ES集群概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E6%90%AD%E5%BB%BAES%E9%9B%86%E7%BE%A4"><span class="toc-number">5.11.2.</span> <span class="toc-text">②搭建ES集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E9%9B%86%E7%BE%A4%E8%84%91%E8%A3%82%E9%97%AE%E9%A2%98"><span class="toc-number">5.11.3.</span> <span class="toc-text">③集群脑裂问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3%E9%9B%86%E7%BE%A4%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">5.11.4.</span> <span class="toc-text">④集群分布式存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4%E9%9B%86%E7%BE%A4%E5%88%86%E5%B8%83%E5%BC%8F%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.11.5.</span> <span class="toc-text">⑤集群分布式查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A5%E9%9B%86%E7%BE%A4%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-number">5.11.6.</span> <span class="toc-text">⑥集群故障转移</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%AB%98%E7%BA%A7%E7%AF%87"><span class="toc-number">6.</span> <span class="toc-text">二、高级篇</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4Sentinel"><span class="toc-number">7.</span> <span class="toc-text">5.微服务保护Sentinel</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1%E5%88%9D%E8%AF%86Sentinel"><span class="toc-number">7.1.</span> <span class="toc-text">5.1初识Sentinel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">7.1.1.</span> <span class="toc-text">①雪崩问题及解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%94"><span class="toc-number">7.1.2.</span> <span class="toc-text">②服务保护技术对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2Sentinel%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85"><span class="toc-number">7.1.3.</span> <span class="toc-text">③Sentinel介绍与安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%95%B4%E5%90%88Sentinel"><span class="toc-number">7.1.4.</span> <span class="toc-text">④微服务整合Sentinel</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">7.2.</span> <span class="toc-text">5.2流量控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E7%B0%87%E7%82%B9%E9%93%BE%E8%B7%AF"><span class="toc-number">7.2.1.</span> <span class="toc-text">①簇点链路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99"><span class="toc-number">7.2.2.</span> <span class="toc-text">②流控规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E6%B5%81%E6%8E%A7%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.2.3.</span> <span class="toc-text">③流控模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%85%B3%E8%81%94%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.2.3.1.</span> <span class="toc-text">（1）关联模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E9%93%BE%E8%B7%AF%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.2.3.2.</span> <span class="toc-text">（2）链路模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3%E6%B5%81%E6%8E%A7%E6%95%88%E6%9E%9C"><span class="toc-number">7.2.4.</span> <span class="toc-text">④流控效果</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Warm-Up"><span class="toc-number">7.2.4.1.</span> <span class="toc-text">（1）Warm Up</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%8E%92%E9%98%9F%E7%AD%89%E5%BE%85"><span class="toc-number">7.2.4.2.</span> <span class="toc-text">（2）排队等待</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81"><span class="toc-number">7.2.5.</span> <span class="toc-text">⑤热点参数限流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%85%A8%E5%B1%80%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81"><span class="toc-number">7.2.5.1.</span> <span class="toc-text">（1）全局参数限流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81"><span class="toc-number">7.2.5.2.</span> <span class="toc-text">（2）热点参数限流</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3%E9%9A%94%E7%A6%BB%E5%92%8C%E9%99%8D%E7%BA%A7"><span class="toc-number">7.3.</span> <span class="toc-text">5.3隔离和降级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0FeignClient%E6%95%B4%E5%90%88Sentinel"><span class="toc-number">7.3.1.</span> <span class="toc-text">①FeignClient整合Sentinel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB%EF%BC%88%E4%BB%93%E5%A3%81%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">7.3.2.</span> <span class="toc-text">②线程隔离（仓壁模式）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">7.3.2.1.</span> <span class="toc-text">（1）线程隔离的两种方式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89Sentinel%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB"><span class="toc-number">7.3.2.2.</span> <span class="toc-text">（2）Sentinel实现线程隔离</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7"><span class="toc-number">7.3.3.</span> <span class="toc-text">③熔断降级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%85%A2%E8%B0%83%E7%94%A8"><span class="toc-number">7.3.3.1.</span> <span class="toc-text">（1）慢调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%BC%82%E5%B8%B8%E6%AF%94%E4%BE%8B%E3%80%81%E5%BC%82%E5%B8%B8%E6%95%B0"><span class="toc-number">7.3.3.2.</span> <span class="toc-text">（2）异常比例、异常数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4%E6%8E%88%E6%9D%83%E8%A7%84%E5%88%99"><span class="toc-number">7.4.</span> <span class="toc-text">5.4授权规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E6%8E%88%E6%9D%83%E8%A7%84%E5%88%99"><span class="toc-number">7.4.1.</span> <span class="toc-text">①授权规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99"><span class="toc-number">7.4.1.1.</span> <span class="toc-text">（1）基本规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96origin"><span class="toc-number">7.4.1.2.</span> <span class="toc-text">（2）如何获取origin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E7%BB%99%E7%BD%91%E5%85%B3%E6%B7%BB%E5%8A%A0%E8%AF%B7%E6%B1%82%E5%A4%B4"><span class="toc-number">7.4.1.3.</span> <span class="toc-text">（3）给网关添加请求头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E9%85%8D%E7%BD%AE%E6%8E%88%E6%9D%83%E8%A7%84%E5%88%99"><span class="toc-number">7.4.1.4.</span> <span class="toc-text">（4）配置授权规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%BB%93%E6%9E%9C"><span class="toc-number">7.4.2.</span> <span class="toc-text">②自定义异常结果</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.4.2.1.</span> <span class="toc-text">（1）异常类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">7.4.2.2.</span> <span class="toc-text">（2）自定义异常处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">7.5.</span> <span class="toc-text">5.5规则持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E8%A7%84%E5%88%99%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.5.1.</span> <span class="toc-text">①规则管理模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E5%AE%9E%E7%8E%B0push%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.5.2.</span> <span class="toc-text">②实现push模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1Seata"><span class="toc-number">8.</span> <span class="toc-text">6.分布式事务Seata</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98"><span class="toc-number">8.1.</span> <span class="toc-text">6.1分布式事务问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1"><span class="toc-number">8.1.1.</span> <span class="toc-text">①本地事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">8.1.2.</span> <span class="toc-text">②分布式事务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">8.2.</span> <span class="toc-text">6.2理论基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0CAP%E5%AE%9A%E7%90%86"><span class="toc-number">8.2.1.</span> <span class="toc-text">①CAP定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1BASE%E7%90%86%E8%AE%BA"><span class="toc-number">8.2.2.</span> <span class="toc-text">②BASE理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E8%A7%A3%E5%86%B3%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="toc-number">8.2.3.</span> <span class="toc-text">③解决分布式事务问题的思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3%E5%88%9D%E8%AF%86Seata"><span class="toc-number">8.3.</span> <span class="toc-text">6.3初识Seata</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0Seata%E6%9E%B6%E6%9E%84"><span class="toc-number">8.3.1.</span> <span class="toc-text">①Seata架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E9%83%A8%E7%BD%B2TC%E6%9C%8D%E5%8A%A1"><span class="toc-number">8.3.2.</span> <span class="toc-text">②部署TC服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90Seata"><span class="toc-number">8.3.3.</span> <span class="toc-text">③微服务集成Seata</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4Seata%E5%9B%9B%E7%A7%8D%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.4.</span> <span class="toc-text">6.4Seata四种事务模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0XA%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.4.1.</span> <span class="toc-text">①XA模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">8.4.1.1.</span> <span class="toc-text">（1）两阶段提交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89Seata%E7%9A%84XA%E6%A8%A1%E5%9E%8B"><span class="toc-number">8.4.1.2.</span> <span class="toc-text">（2）Seata的XA模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">8.4.1.3.</span> <span class="toc-text">（3）优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%AE%9E%E7%8E%B0XA%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.4.1.4.</span> <span class="toc-text">（4）实现XA模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1AT%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.4.2.</span> <span class="toc-text">②AT模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Seata%E7%9A%84AT%E6%A8%A1%E5%9E%8B"><span class="toc-number">8.4.2.1.</span> <span class="toc-text">（1）Seata的AT模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%B5%81%E7%A8%8B%E7%A4%BA%E4%BE%8B"><span class="toc-number">8.4.2.2.</span> <span class="toc-text">（2）流程示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89AT%E4%B8%8EXA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.4.2.3.</span> <span class="toc-text">（3）AT与XA的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89AT%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%84%8F%E5%86%99%E9%97%AE%E9%A2%98"><span class="toc-number">8.4.2.4.</span> <span class="toc-text">（4）AT模式的脏写问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89AT%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">8.4.2.5.</span> <span class="toc-text">（5）AT模式优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E5%AE%9E%E7%8E%B0AT%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.4.2.6.</span> <span class="toc-text">（6）实现AT模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2TCC%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.4.3.</span> <span class="toc-text">③TCC模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%EF%BC%88%E5%87%A0%E4%B8%AA%E9%98%B6%E6%AE%B5%EF%BC%89"><span class="toc-number">8.4.3.1.</span> <span class="toc-text">（1）流程分析（几个阶段）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89Seata%E7%9A%84TCC%E6%A8%A1%E5%9E%8B"><span class="toc-number">8.4.3.2.</span> <span class="toc-text">（2）Seata的TCC模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89TCC%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">8.4.3.3.</span> <span class="toc-text">（3）TCC模式优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E4%BA%8B%E5%8A%A1%E6%82%AC%E6%8C%82%E5%92%8C%E7%A9%BA%E5%9B%9E%E6%BB%9A%E9%97%AE%E9%A2%98"><span class="toc-number">8.4.3.4.</span> <span class="toc-text">（4）事务悬挂和空回滚问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E5%AE%9E%E7%8E%B0TCC%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.4.3.5.</span> <span class="toc-text">（5）实现TCC模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3SAGA%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.4.4.</span> <span class="toc-text">④SAGA模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%8E%9F%E7%90%86"><span class="toc-number">8.4.4.1.</span> <span class="toc-text">（1）原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">8.4.4.2.</span> <span class="toc-text">（2）优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4%E5%9B%9B%E7%A7%8D%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">8.4.5.</span> <span class="toc-text">⑤四种模式对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">8.5.</span> <span class="toc-text">6.5高可用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B"><span class="toc-number">8.5.1.</span> <span class="toc-text">①高可用架构模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">8.5.2.</span> <span class="toc-text">②实现高可用</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/05/31/SpringCloudAlibaba/" title="SpringCloudAlibaba"><img src="/img/blog_cover/default_cover_2.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringCloudAlibaba"/></a><div class="content"><a class="title" href="/2024/05/31/SpringCloudAlibaba/" title="SpringCloudAlibaba">SpringCloudAlibaba</a><time datetime="2024-05-30T16:00:00.000Z" title="Created 2024-05-31 00:00:00">2024-05-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/21/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/" title="黑马点评项目笔记"><img src="/img/blog_cover/default_cover_6.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="黑马点评项目笔记"/></a><div class="content"><a class="title" href="/2024/05/21/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/" title="黑马点评项目笔记">黑马点评项目笔记</a><time datetime="2024-05-20T16:00:00.000Z" title="Created 2024-05-21 00:00:00">2024-05-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/21/Vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="常用Vim命令"><img src="/img/blog_cover/default_cover_5.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常用Vim命令"/></a><div class="content"><a class="title" href="/2024/04/21/Vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="常用Vim命令">常用Vim命令</a><time datetime="2024-04-21T14:35:31.000Z" title="Created 2024-04-21 22:35:31">2024-04-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By cloudy</div><div class="footer_custom_text">It's OK to be not OK.<p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>